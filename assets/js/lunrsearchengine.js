
var documents = [{
    "id": 0,
    "url": "/404.html",
    "title": "404",
    "body": "404 Page does not exist!Please use the search bar at the top or visit our homepage! "
    }, {
    "id": 1,
    "url": "/about",
    "title": "about",
    "body": " Malg:eon: 대학에서 자료구조와 알고리즘을 C언어를 기반으로 배웠습니다. 개인적인 필요에 의해 JAVA로 자료구조와 알고리즘을 다시 공부하였고, 최근 개발자의 분야를 정하고 싶어서 실무형 강의인 부스트 코스의 웹 프로그래밍을 수강 중에 있습니다. (현재 프로젝트 5. 웹 앱개발:예약서비스 3/4 진행중에 있습니다. )  3개월간 웹 프로그래밍을 배워오며, Spring에 사용하기 위해 필요한 방대한 이해와 자바스크립트에 대한 이해가 깊어질수록 더 나은 퍼포먼스를 갖춘 웹서비스를 설계할수 있음을 알게 되었으며, 웹 서비스가 전체적으로 어떻게 설계되고 구축되는지 그리고 구축되는 과정에서 Spring 프레임워크가 왜 편리함을 주는지에 대하여 배울수 있었습니다.  부스트코스 강의를 어느정도 배워나가며 그동안 배운 웹 서비스에 대한 이해를 바탕으로 Jekyll Blog 만들고자 하였고, 무료로 제공되는 Theme를 단순히 fork 하는 것보다 선택한 Theme를 기반으로 원하는 블로그로 다시 디자인하여 만들수 있게 되었습니다.  웹 프로그래밍 강의가 끝나가는 현재는 스텝을 밟아 나갈 다음 단계를 모색 중에 있습니다.  신입 개발자가 되기 위해 공부중에 있습니다. Goal: 신입 개발자로 취직 details:  Malg:eon 블로그 제작.  프로그래머스 스킬체크의 레벨 3 통과 (최근 레벨3 87. 5점 기록 - 100점 통과)"
    }, {
    "id": 2,
    "url": "/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 3,
    "url": "/project/index.html",
    "title": "project",
    "body": ""
    }, {
    "id": 4,
    "url": "/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 5,
    "url": "/page2/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 6,
    "url": "/page3/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 7,
    "url": "/page4/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 8,
    "url": "/page5/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 9,
    "url": "/page6/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 10,
    "url": "/page7/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 11,
    "url": "/page8/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 12,
    "url": "/page9/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 13,
    "url": "/study/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 14,
    "url": "/study/page2/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 15,
    "url": "/study/page3/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 16,
    "url": "/study/page4/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 17,
    "url": "/study/page5/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 18,
    "url": "/project/android/index.html",
    "title": "tags",
    "body": "android "
    }, {
    "id": 19,
    "url": "/project/ios/index.html",
    "title": "tags",
    "body": "ios "
    }, {
    "id": 20,
    "url": "/project/web/index.html",
    "title": "tags",
    "body": "web "
    }, {
    "id": 21,
    "url": "/study/android/index.html",
    "title": "tags",
    "body": "android "
    }, {
    "id": 22,
    "url": "/study/db/index.html",
    "title": "tags",
    "body": "db "
    }, {
    "id": 23,
    "url": "/study/java/index.html",
    "title": "tags",
    "body": "java "
    }, {
    "id": 24,
    "url": "/study/java/page2/index.html",
    "title": "tags",
    "body": "java "
    }, {
    "id": 25,
    "url": "/study/java/page3/index.html",
    "title": "tags",
    "body": "java "
    }, {
    "id": 26,
    "url": "/study/javascript/index.html",
    "title": "tags",
    "body": "javascript "
    }, {
    "id": 27,
    "url": "/study/kotlin/index.html",
    "title": "tags",
    "body": "kotlin "
    }, {
    "id": 28,
    "url": "/study/kotlin/page2/index.html",
    "title": "tags",
    "body": "kotlin "
    }, {
    "id": 29,
    "url": "/study/programming/index.html",
    "title": "tags",
    "body": "programming "
    }, {
    "id": 30,
    "url": "/study/web/index.html",
    "title": "tags",
    "body": "web "
    }, {
    "id": 31,
    "url": "/test/bfs/index.html",
    "title": "tags",
    "body": "bfs "
    }, {
    "id": 32,
    "url": "/test/binary/index.html",
    "title": "tags",
    "body": "binary search "
    }, {
    "id": 33,
    "url": "/test/bp/index.html",
    "title": "tags",
    "body": "brute-force "
    }, {
    "id": 34,
    "url": "/test/dfs/index.html",
    "title": "tags",
    "body": "dfs "
    }, {
    "id": 35,
    "url": "/test/dynamic/index.html",
    "title": "tags",
    "body": "dynamic programming "
    }, {
    "id": 36,
    "url": "/test/graph/index.html",
    "title": "tags",
    "body": "graph "
    }, {
    "id": 37,
    "url": "/test/greedy/index.html",
    "title": "tags",
    "body": "greedy "
    }, {
    "id": 38,
    "url": "/test/heap/index.html",
    "title": "tags",
    "body": "heap "
    }, {
    "id": 39,
    "url": "/test/queue/index.html",
    "title": "tags",
    "body": "queue "
    }, {
    "id": 40,
    "url": "/test/sort/index.html",
    "title": "tags",
    "body": "sort "
    }, {
    "id": 41,
    "url": "/test/stack/index.html",
    "title": "tags",
    "body": "stack "
    }, {
    "id": 42,
    "url": "/test/standard/index.html",
    "title": "tags",
    "body": "standard "
    }, {
    "id": 43,
    "url": "/test/standard/page2/index.html",
    "title": "tags",
    "body": "standard "
    }, {
    "id": 44,
    "url": "/test/standard/page3/index.html",
    "title": "tags",
    "body": "standard "
    }, {
    "id": 45,
    "url": "/test/standard/page4/index.html",
    "title": "tags",
    "body": "standard "
    }, {
    "id": 46,
    "url": "/test/index.html",
    "title": "test",
    "body": ""
    }, {
    "id": 47,
    "url": "/test/page2/index.html",
    "title": "test",
    "body": ""
    }, {
    "id": 48,
    "url": "/test/page3/index.html",
    "title": "test",
    "body": ""
    }, {
    "id": 49,
    "url": "/test/page4/index.html",
    "title": "test",
    "body": ""
    }, {
    "id": 50,
    "url": "/study_kotlin_5/",
    "title": "Kotlin - [5]",
    "body": "2020/08/01 - if~else 문의 간략화: 12345var max: Intif (a &gt; b)   max = aelse   max = b1var max = if (a &gt; b) a else b블록과 함께 사용할 경우 1234567891011121314fun main() {  val a = 12  val b = 7  val max = if (a &gt; b) {    println( a 선택 )    a // 블럭의 마지막 식이 반환되어 max에 할당.   }  else {    println( b 선택 )    b // 블럭의 마지막 식이 반환되어 max에 할당.   }  println(max)readLine()콘솔로부터 입력 받는 함수: 1val score = readLine()!!. toDouble() // readLine은 Null이 될수도 있으므로 Null값 처리를 해줘야 한다. 여기선 잠깐 테스트를 위한 것이라 !!로 처리. 범위 연산자: 변수명 in 시작값. . 마지막값 1if(score in 80. . 89) // score가 80~89 사이에 있는 값인지 확인(마지막 값은 포함!)when문(switch … case과 비슷): 범위 연산자, is 키워드 사용 가능. 1234567891011121314151617when(x) {  1 -&gt; print( x == 1 ) //break 필요없이 빠져나온다.   2 -&gt; print( x == 2 )  3, 4 -&gt; print( x == 3, 4 ) //일치되는 여러 조건 사용 가능  parseInt(s) -&gt; print( 일치함! ) // 함수의 반환값 사용 가능  in 10. . 20 -&gt; print( x는 10이상 20이하입니다.  )  !in 10. . 20 -&gt; print( x는 10이상 20이하의 범위에 포함되지 않습니다.  )  else -&gt; { // 블록 구문 사용 가능.     print( else )  }}val str =  안녕하세요.  val result = when(str) {  is String -&gt;  문자열입니다.    else -&gt; false}인자가 없는 when 123456when {  score &lt;= 90. 0 -&gt; grade = 'A'  score in 80. 0. . 89. 9 -&gt; grade = 'B'  score in 70. 0. . 79. 9 -&gt; grade = 'C'  score &lt; 70. 0 -&gt; grade = 'F'}"
    }, {
    "id": 51,
    "url": "/study_kotlin_4/",
    "title": "Kotlin - [4]",
    "body": "2020/07/31 - 코틀린은 다중 패러다임 언어:  함수형 프로그래밍(FP: Functional Programming) 객체 지향 프로그래밍(OOP: Object-Oriented Programming)함수형 프로그래밍:  코드 간략, 테스트나 재사용성 증가 람다식, 고차 함수를 사용해 구성 순수 함수순수 함수(pure function):  부작용(side-effect)이 없는 함수     동일한 입력 인자에 대해서는 항상 같은 결과를 출력 혹은 반환 한다.    값이 예측 가능해 결정적(deterministic)이다.    123 fun sum(a: Int, b: Int): Int {   return a + b //도일한 인자인 a, b를 입력 받아 항상 a + b를 출력(부작용이 없음) } 순수함수의 조건     같은 인자에 대하여 항상 같은 값을 반환   함수 외부의 어떤 상태도 바꾸지 않는다.     순수함수가 아닌 예  1234 fun check() {  val test = User. grade() // check() 함수에 없는 외부의 User 객체를 사용  if (test != null) process(test) // 변수 test는 User. grade()의 실행 결과에 따라 달라짐 }   123456789101112const val global = 10fun main() {  val num1 = 10  val num2 = 3  val result = noPureFunction(num1, num2)  println(result)}fun noPureFunction(a: Int, b: Int): Int {  return a + b + global // global 값이 바뀔 때 마다 return 값이 달라진다. no Pure} 순수 함수가 필요한 이유     입력과 내용을 분리하고 모듈화 하므로 재사용성이 높아진다.          여러가지 함수들과 조합해도 부작용이 없다.           특정 상태에 영향을 주지 않으므로 병행 작업 시 안전하다.    함수의 값을 추적하고 예측 할 수 있기 떄문에 테스트, 디버깅 등이 유리하다.     함수형 프로그래밍에 적용     함수를 매개변수, 인자에 혹은 반환값에 적용(고차 함수)   함수를 변수나 데이터 구조에 저장   유연성 증가   람다식: 람다식(Lambda Expression)이란?:  익명 함수의 하나의 형태로 이름 없이 사용 및 실행이 가능 람다 대수(Lambda calculus)로 부터 유래{ x, y -&gt; x + y } // 람다식의 예 (이름이 없는 함수 형태) 람다식의 이용:  람다식은 고차 함수에서 인자로 넘기거나 결과값으로 반환 등을 할 수 있다. 일급 객체: 일급 객체(First Class Citizen)란?:  일급 객체는 함수의 인자로 전단할 수 있다.  일급 객체는 함수의 반환값에 사용할 수 있다.  일급 객체는 변수에 담을 수 있다. 코틀린에서는 함수는 1급 객체로 다룬다. (1급 함수라고도 한다. ) 고차 함수: 고차 함수(high-order function)란?: 12345fun main() {  println(highFunc({ x, y -&gt; x + y}, 10, 20))}fun highFunc(sum: (Int, Int) -&gt; Int, a: Int, b: Int): Int = sum(a, b)// sum 매개변수는 함수차례로higntFunc =&gt; 고차함수sum =&gt; 람다식 매개변수(Int, Int) -&gt; Int =&gt; 자료형이 람다식으로 선언 되어 { x, y -&gt; x + y } 형태로 인자를 받는 것이 가능a: Int, b: Int) : Int =&gt; 매개 변수와 반환 자료형sum(a, b) =&gt; return 값. 람다식 표현문에 따라 a + b 아래와 같이 바꿀 수 있다. 12345fun main() {  val result = highFunc(1, 3, {x, y -&gt; x + y})}fun highFunc(a: Int, b: Int, sum: (Int, Int) -&gt; Int): Int = sum(a, b)// sum 매개변수는 함수1234567fun main() {  val result = highFunc(1, 3) {x, y -&gt;     x + y  }}fun highFunc(a: Int, b: Int, sum: (Int, Int) -&gt; Int): Int = sum(a, b)// sum 매개변수는 함수 자바스크립트 함수형!?람다의 parameter가 하나인 경우 컴파일러가 추론이 가능하여 해당 값을 it으로 사용이 가능하다. 123456fun more(out: (String) -&gt; String): Unit {  println(out( Hello ))}fun main() {  more{ $it Kotlin } //Hello Kotlin}인라인 함수: 람다식을 이용하게 되면 런타임시 해당 람다식은 함수에 해당하는 객체로 변환되어 메모리 할당이 이루어 진다. 즉, 람다식이 많아지면 많아질수록 객체 변환이 많이 이루어 지게 되어 런타임 오버헤드를 유발한다. 이런 문제점을 해결하는 방법으로 람다식에 inline을 붙임으로써 함수 호출 방식이 아닌 코드 자체를 복사하여 붙여넣는 방식으로 컴파일이 된다. 그렇지만 함수를 만들다 보면 inline 방식을 이용하고 싶은 매개변수가 생길수도 있는데, 그럴 경우 해당 매개변수 앞에 noinline을 붙이면 inline이 아닌 방식으로 동작을 하게 된다. "
    }, {
    "id": 52,
    "url": "/study_kotlin_3/",
    "title": "Kotlin - [3]",
    "body": "2020/07/31 - 함수의 선언: 1234fun sum(a: Int, b: Int): Int { var sum = a + b return sum}fun 함수이름([변수 이름: 자료형, 변수 이름: 자료형. . ]) : [반환값의 자료형] { … [return 반환값]} 반환값이 없는 함수일 경우 반환값의 자료형으로 unit을 사용한다. 이 함수는 반환값이 없다는 unit값을 반환한다. (자바에서 void와 비슷하지만 void는 변환값이 전혀 없다. ) 그리고 Unit은 생략이 가능하다. 1234fun outName(name: String): Unit { println( Name: $name ) return Unit}123fun outName(name: String) { println( Name: $name )} 최상위 함수(Top-level): 소스코드 상위에 있는 함수. 어느 곳에서 선언하든 사용가능하다.  지역 함수 : 소스코드 내에 선언 된 함수. 해당 함수를 사용하기 전에는 무조건 선언되어야 한다. 간략화된 함수: 함수는 아래와 같이 간략화 하여 사용할 수 있다. 1fun sum(a: Int, b: Int): Int = a + b 이때 반환값이 추론이 가능할 경우 반환값의 자료형은 생략 가능하다. (간략화 하지 않을 경우는 불가능) 1fun sum(a: Int, b: Int) = a + b 1fun outName(name: String) = println( Name: $name )Default 매개변수: 매개변수에 Default 값을 설정할 수 있다. 매개변수 중 특정 매개변수 만 값을 설정할 경우 함수의 매개변수에 값을 직접 넣는다. 12fun sum(a: Int, b: Int = 5): Int = a + b println(sum(2)) // 712fun sum(a: Int = 2, b: Int = 5): Int = a + b println(sum(b=2)) // 4가변변수: 매개변수가 가변적일 경우 동일한 자료형에 대해 vararg를 이용하여 사용이 가능하다. 1234567891011fun normalVarargs(vararg a: Int) {  for (num in a) {    print( $num  )  }}fun main() {  normalVarargs(1) // 1  println()  normalVarargs(1, 2, 3, 4, 5) // 1 2 3 4}"
    }, {
    "id": 53,
    "url": "/study_kotlin_2/",
    "title": "Kotlin - [2]",
    "body": "2020/07/31 - 자료형 변환:  변환 메서드 사용  12var a: Int = 1var b: Double = a. toDouble()    표현식에서 자동 변환  1var result = 1L + 3// Long + Int =&gt; result: Long   이중 등호와 삼중 등호: 12345var a: Int = 128var b: Int = 128println(a == b) // trueprintln(a === b) // false12345var a: Int = 128var b: Int? = 128println(a == b) // trueprintln(a === b) // false12345var a: Int = 128var b: Int? = 128println(a == b) // trueprintln(a === b) // false1234567891011var a: Int = 128var c: Int? = avar d: Int? = avar e: Int? = cprintln(c == d) // trueprintln(c === d) // false println(c == e) // trueprintln(c === e) // true스마트 캐스드 Number: Number로 선언함으로써 Int, Long, Float 등 숫자 자료형을 자동으로 변환해준다. 1234var a: Number = 12. 2a = 12a = 120La += 12. 0f스마트 캐스트 Any: 자료형이 정해지지 않는 경우 사용. 언제든 필요한 자료형으로 자동 변환 1234var a: Any = 1a =  Hello a = 120Lprintln( a: $a type: ${a. javaClass} ) // a: 120 type: longis 키워드: 1234567var num = 256if (num is Int) { print(num) } else if(num !is Int) { // !(num is Int)와 동일 print( Not a Int )}비트 연산을 위한 비트 매서드:       표현식   설명         4. shl(bits)   4를 표현하는 비트를 bits만큼 왼쪽으로 이동(부호 있음)       7. shr(bits)   7를 표현하는 비트를 bits만큼 오른쪽으로 이동(부호 있음)       12. ushr(bits)   12를 표현하는 비트를 bits만큼 오른쪽으로 이동(부호 없음)       9. and(bits)   9를 표현하는 비트를 bits를 표현하는 비트로 논리곱 연산       4. or(bits)   4를 표현하는 비트를 bits를 표현하는 비트로 논리곱 연산       24. xor(bits)   24를 표현하는 비트를 bits를 표현하는 비트로 배타적 연산       78. inv( )   78를 표현하는 비트를 모두 뒤집음   "
    }, {
    "id": 54,
    "url": "/study_kotlin_1/",
    "title": "Kotlin - [1]",
    "body": "2020/07/30 - 변수: val(value) - 불변형 (immutable) var(variable) - 가변형 (mutable) val username(: String - 컴파일에서 추론 가능할 경우 생략 가능) = “Eon” 따라서 단순 선언 같은 경우 추론이 불가능하므로 생략 불가 자료형: 기본형(primitive data type):  보통 코틀린에서는 사용하지 않으나 자바에서 사용하므로 알아두자 int, long, float, double참조형(reference type):  동적 공간에 데이터를 둔 다음 이것을 참조하는 자료형 Int, Long, Float, Double자료형 추론: 123 =&gt; Int123L =&gt; Long (접미사 L)123F =&gt; Float (접미사 F)0x0F =&gt; 16진수 Int (접두사 0x)0b00001011 =&gt; 2진수 Int (접두사 0b) 작은 값을 사용하고자 하면 자료형을 명시적으로 지정해주자. 숫자 자료형을 경우 사이에 언더바는 아무런 영향을 주지 않는다. 그냥 자릿수 확인으로 사용 가능 큰수일 경우 3. 14E + 16 이런식으로 사용 코틀린에서는 부동 소수점을 표현할 때, 지수부와 가수부로 나뉘어 저장된다. 이러한 부동 소수점에 대해 연산을 하게 될 경우 공간 제약으로 인해 정확한 값을 return하지 않는다. 유념해서 설계하자. 123456789fun main() { var num: Double = 0. 1 for(x in 0. . . 999) {  num += 0. 1 } println(num) //100. 09999. . . }문자열 자료형: 문자열은 String으로 선언되며 String Pool 이라는 공간에 구성된다. 이때 참조형 변수이기 때문에, 변수를 선언할 경우 Heap에 값은 String Pool 저장되게 되며 이 값은 변경되지 않는다. 즉, 만일 값이 같은 변수를 선언할 경우 똑같은 참조이게 된다. 코틀린에서 [== : 값만 비교] === : 값과 참조 주소 비교 12345678fun main() { var str1: String =  Hello  var str2 =  World  var str3 =  Hello   println( str1 === str2: ${str1 === str2} ) // false println( str1 === str3: ${str1 === str3} ) // true}### 표현식에서 문자열 1234567fun main() { var a = 1 var str1 =  a = $a  var str2 =  a = ${a +2}   println( str1: \ $str1\ , str2: \ $str2\  ) //  를 print하고 싶다면 [\ ] 이렇게 쓰면 된다. }### nullable 코틀린에서는 기본적으로 null을 허용하지 않는다. (프로그램이 NPE에서 자유롭게 구동하려는 의도로 이해하고 있다. ) 그러나 상황에 따라 null이 필요하게 될 경우 자료형에 물음표를 붙임으로써 사용이 가능하다. 그리고 코틀린에서는 nullable 변수를 사용하더라도, 사용할 때 NPE에서 자유롭도록 코딩을 유도한다. 주의할 점은 자료형 과 자료형? 은 다른 Type이다. 1234fun main() { var str1: String println( str1 ) // error null을 허용하지 않는다. }12345fun main() { var str1: String str1 = null println( str1 ) // error null을 허용하지 않는다. }12345fun main() { var str1: String? str1 = null println( str1 ) // return : null}12345fun main() { var str1: String? str1 = null println( str1: $str1, length: ${str1. length ) // error null값의 길이를 참조할 수 있게 된다. }이때 추가적으로 코딩을 하지 않고 해결할 수 있는 방법은 2가지 이다.  세이프콜(?. )을 사용한다.  혹시라도 Null일 경우 ?. 의 뒷부분을 실행하지 않도록 해준다. 12345fun main() { var str1: String? str1 = null println( str1: $str1, length: ${str1?. length ) // error null값의 길이를 참조할 수 있게 된다. } NonNull 단정 기호(!!. )를 사용한다. Null이 아닐것임을 단정해서 컴파일러가 오류를 무시하고 넘어간다. 되도록이면 사용하지 말자. 12345fun main() { var str1: String? str1 = null println( str1: $str1, length: ${str1!!. length ) // NPE 발생. . }물론 if문을 통해 걸러주는 방법을 사용해도 된다. 123456fun main() { var str1: String? str1 =  Hello  var len = if (str1 != null) str. length else -1 println( str1: $str1, length: $len )}그런데 위 문장을 elvis 표현으로 바꿀수 있다. 123456fun main() { var str1: String? str1 =  Hello  var len = str1?. length ?: -1 println( str1: $str1, length: $len )}또한 함수형으로 이렇게도 표현이 가능하다. 123456fun main() { var str1: String? str1 =  Hello  var len = if (str1 != null) str1. length else -1 println( str1: $str1, length: $len )}"
    }, {
    "id": 55,
    "url": "/study_kotlin_start/",
    "title": "Kotlin 시작",
    "body": "2020/07/29 - 코틀린을 배워보자. : 코틀린이란 언어에 대해 알아보게 되어서야 현재 java의 status를 알수 있었다. 단순히 학업의 목적으로 java를 이해하고 있었을 적엔 jdk에 대하여 별다른 신경을 쓰지 않았으나, 공부를 좀 더 해가면서 jdk이는 더 이상 무료가 아니게 되었으며, 이에 대한 나비효과로 kotlin은 더욱 각광을 받고 있음을 알게 되었다. 개인적으로 앱개발에 대해 호기심을 가지고 있었으며, 함수형 프로그래밍이 가능함과 동시에 레거시 java 프로그램들도 전체 커버가 가능하다는 장점이 현재 코틀린을 배우려는 생각을 갖게 하는데 결정적이었다. 부스트코스 코틀린 프로그래밍: 이런 생각을 가질즈음 부스트 코스에서도 코틀린 프로그래밍 강의가 새로 열렸다. 단순히 언어를 배우는데 끝나는 것이 아닌 3단계로 나뉘어서 함수형 - 객체지향형 - 응용(앱 만들기) 강의가 진행하고 있다. 해당 강의에서는 azul에서 제공하는 zulu builds of openJDK를 사용하고, 개발 환경으로는 Intellij를 사용한다. 모두 처음해보는 생소한 것이나, 이클립스와 비교를 해보는 등의 재미가 있을것으로 생각 되어 즐거운 마음으로 진행하고자 한다. 이후 코틀린에 대해 공부하며, 기억해야 할 것들을 정리해서 포스팅 할 예정이다. 모두 배우고 나면 코틀린으로 알고리즘 문제를 풀수 있기를 희망한다. "
    }, {
    "id": 56,
    "url": "/study_aboutintellij/",
    "title": "IntelliJ",
    "body": "2020/07/29 - font : D2coding(네이버 제공)ctrl + Mouse : font 크기 조절 활성화 도구 창의 단축키 : 윈도우(맥):  Messages Alt + 0 (Cmd + 0) Project Alt + 1 (Cmd + 1) Favorites  Alt + 2 (Cmd + 2) Run Alt + 4 (Cmd + 4) Debug  Alt + 5 (Cmd + 5) TODO Alt + 6 (Cmd + 6) Structure  Alt + 7 (Cmd + 7)   Terminal Alt + F12 (Option + F12)   자동 줄 복사 Ctrl + D 실행 Ctrl + Shift + F10 새 파일 생성 Alt + Insert 추론 타입 확인 : Ctrl + Shift + P함수의 console Library 확인: 함수위에서 Ctrl + B * 2 =&gt; 자바 라이브러리 java로 변환: Tools -&gt; Kotlin -&gt; Show Kotlin Bytecode 매뉴에서 Decomplie 클릭. 인자를 받는 main문에 인자 넣기: 우측 상단에 Run 좌측 배너를 클릭하여 Edit Configuration 클릭 Program Argument가 넣을 인자. "
    }, {
    "id": 57,
    "url": "/feat_project_jekyll_blog/",
    "title": "Github page & Jekyll Blog 제작",
    "body": "2020/07/28 - 블로그 제작 과정!Comming Soon! "
    }, {
    "id": 58,
    "url": "/study_FE_Syn&ASyn/",
    "title": "웹 : 동기 그리고 비동기",
    "body": "2020/07/11 - 싱글 스레드갑자기 싱글 스레드? 동기, 비동기라며!?: 프로그래밍 입문을 C, 자바로 해온 나는 자바스크립트를 배우는 지금 자바스크립트에 대한 첫 인상은 forEach에 대한 의아함 이었다. for 문이 잘 돌아가는데 굳이. . ? 최근 동기, 비동기 이슈에 대한 공부를 한 후 해당 의아함을 어느정도 풀 수 있었다. 웹에서 버튼을 눌렀는데, 웹이 멈췄다. 그래서 버튼을 여러번 눌렀다. 답답한 시간이 지나고 난 뒤 버튼이 동작한다. 근데 여러번 동작한다. 그러면 안된다.  답답하니까… 사실 이 문제는 여러 프로그램을 동작시키는 운영체제를 보면 금세 해결할수 있다. 즉 멀티스레드를 통해서 말이다. 그런데 자바스크립트는 싱글 스레드 기반 언어이다. 그렇다면 문제를 해결 할수 없는 것일까? 콜백, 동기 비동기: 아니다. 현재 웹 전체가 멈추는 현상에 대한 기억 없이 잘 쓰고 있는 걸 보면 말이다. 아마도 위의 문제를 해결하기 위해 콜백함수와 비동기식 개발이 나온것 으로 이해했다. 그러고나니 처음 forEach에 대한 의아함은 해결 되었다. 비동기그래서 비동기식 개발이란게 무엇일까? 함수를 만들고 동작 대한 해당 정보를 어떤 곳에 보내버린다. 그리고 하나의 콜스택을 가지고 있는 자바스크립트에서 해당 함수는 보냄으로써 동작을 다 했기 때문에 콜스택에서 사라진다. 보내진 어떤 곳에서 처리를 한 후 다시 자바스크립트에 보낸다. 자바스크립트는 콜백 큐에 해당 정보를 받아서 콜 스택이 비워져 있을 떄(!) event loop는 콜스택에 보낸다. 위의 일련의 과정이 비동식이라 한다. 여기서 끝나지 않는다. 사실 브라우저는 개발된 자바스크립트를 가지고 렌더링을 해야 하는데, 이 repaint 하는 동작 또한 콜백 큐와 같이 동작 한다. 콜 스택이 비워져 있을 때(!) repaint 하는 것이다. 결론위와 같은 내용을 숙지하여 웹 개발을 진행하며 UI를 만들 때, event loop를 막아 버려서 브라우저가 할일을 못하게 되지 않도록, 유동적인 UI를 만들어 보자. "
    }, {
    "id": 59,
    "url": "/study_FE_slide/",
    "title": "슬라이드 효과",
    "body": "2020/07/10 - 이미지 슬라이드FE를 구성하다보면 가장 대표적으로 필요한 기능이 바로 슬라이드다. 버튼식 슬라이드, 무한 슬라이드 등등. 찾아보니 역시 방법은 천차만별이어서 공부한 바를 작성해 둔다. width : Calc(): 사용하고자 할 자식노드들의(이미지) width를 모두 25%로 맞춘다음 해당 부모노드에서 width를 4배한 값 calc(400%)으로 맞추면 이미지들은 100%가 되게 된다. 이때 margin-left를 -100 * n % 순서대로 바꾸게 되면 각 이미지들을 가리키게 된다. 아주 간편하다. 기준점이 설정되어 있기 때문에 한번은 초기화를 해줘야 한다. translate3d() 이용: width :Calc와 같은 매커니즘이다. transform의 translate3d(x축, y축, z축) 에서 조절하고 싶은 축을 조절하면 된다. "
    }, {
    "id": 60,
    "url": "/feat_study_FE_FadeOut/",
    "title": "Fade Out",
    "body": "2020/07/09 - 사라지기단순히 hover시 사라지는 것보다, className 변경에 따른 fade out 효과를 공부해 보자. CSS에서 제공한다. : 123456-webkit-transition: opacity 3s ease-in-out;-moz-transition: opacity 3s ease-in-out;-ms-transition: opacity 3s ease-in-out;-o-transition: opacity 3s ease-in-out;opacity: 0;"
    }, {
    "id": 61,
    "url": "/study_FE_CORS&JSONP/",
    "title": "CORS와 JSONP",
    "body": "2020/07/08 - JSON연습 프로젝트 작업 중 다음과 같은 경고문을 보았다. Access to XMLHttpRequest at 'http://#' from origin 'http://@' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. CORS 정책에 block 되었다는 건데, #의 도메인에서 XMLHttpRequest로 @도메인에 접근을 하게되면 보안상의 이유로 접근을 못하게 된다. Rest한 API을 만드는 작업 중 url에서 Json 파싱을 가능하게 하는 작업이 있다. 이때 해당 url은 database 객체 자료이기 때문에, 누구나 url을 요청하게 되면 해당 database를 public으로 이용하는 것이나 다름없게 된다. 이 같은 이유가 아마도 보안상의 이유라고 생각한다. 내 경우는 파일 Http에서 작업하면서 XMLHttpRequest를 로컬 서버에 요청을 하다 보니 block 된 것이다. 물론 로컬 서버에서 작업을 해도 되지만, 여러가지 이유로 도메인간 접근을 가능하게 해야할 경우가 많다. 때문에 당연히 알아야 할 내용이므로 공부하기로 한다. 그렇다면 도메인간 XMLHttpRequest를 사용하려면 어떻게 해야 할까. // 공부하다보니 너무 어려워서 일단 보류 CORS경고문에서 설명하 듯 block 하는 CORS 정책을 해제해주는 방법이 존재한다. 우선, 단순히 서버에서 CORS 정책을 해제하는 것으로 이해하고, 프레임워크에서 도와주는 것이 존재한다. 정도로 넘어가자. ## @CrossOrigin Spring에서는 @RequestMapping 위에 @CrossOrigin(origins = “도메인 주소, 도메인 주소 … “) 로 사용하여 도와준다. JSONPjson 값을 js를 통해 주고 받게 만드는 방법이다. 우회의 일종이랄까. "
    }, {
    "id": 62,
    "url": "/study_FE_Cookie&Session/",
    "title": "쿠키와 세션",
    "body": "2020/07/07 - 쿠키와 세션Http는 한번 연결하고 나면 끊어진다. 그러나 웹동작에서 상태유지는 필수적인데 이를 위해 쿠키와 세션이 존재한다. 쿠키 : 사용자 컴퓨터에 저장(정보 유출 우려) 세션 : 서버에 저장 "
    }, {
    "id": 63,
    "url": "/study_CODE_Stack,Queue.Tree/",
    "title": "Graph [BFS, DFS]",
    "body": "2020/07/06 - 큐, 스택, 트리자바스크립트로 Queue, Stack, Tree를 구현해보자. ## 큐 (Queue)  큐(queue)는 다음과 같은 성질을 갖는 자료형입니다. 123데이터를 집어넣을 수 있는 선형(linear) 자료형입니다. 먼저 집어넣은 데이터가 먼저 나옵니다. 이 특징을 줄여서 FIFO(First In First Out)라고 부릅니다. 데이터를 집어넣는 enqueue, 데이터를 추출하는 dequeue 등의 작업을 할 수 있습니다. 1234567891011121314151617class Queue { constructor() {  this. _arr = []; } enqueue(item) {  this. _arr. push(item); } dequeue() {  return this. _arr. shift(); }}const queue = new Queue();queue. enqueue(1);queue. enqueue(2);queue. enqueue(3);queue. dequeue(); // 1## 스택 (Stack)  스택(stack) 다음과 같은 성질을 갖는 자료형입니다. 123데이터를 집어넣을 수 있는 선형(linear) 자료형입니다. 나중에 집어넣은 데이터가 먼저 나옵니다. 이 특징을 줄여서 LIFO(Last In First Out)라고 부릅니다. 데이터를 집어넣는 push, 데이터를 추출하는 pop, 맨 나중에 집어넣은 데이터를 확인하는 peek 등의 작업을 할 수 있습니다. 1234567891011121314151617181920class Stack { constructor() {  this. _arr = []; } push(item) {  this. _arr. push(item); } pop() {  return this. _arr. pop(); } peek() {  return this. _arr[this. _arr. length - 1]; }}const stack = new Stack();stack. push(1);stack. push(2);stack. push(3);stack. pop(); // 3## 트리 (Tree) 12345678910111213트리(tree)는 여러 데이터가 계층 구조 안에서 서로 연결된 형태를 나타낼 때 사용됩니다. 트리를 다룰 때 사용되는 몇 가지 용어를 살펴보겠습니다. 노드(node) - 트리 안에 들어있는 각 항목을 말합니다. 자식 노드(child node) - 노드는 여러 자식 노드를 가질 수 있습니다. 부모 노드(parent node) - 노드 A가 노드 B를 자식으로 갖고 있다면, 노드 A를 노드 B의 '부모 노드'라고 부릅니다. 뿌리 노드(root node) - 트리의 가장 상층부에 있는 노드를 말합니다. 잎 노드(leaf node) - 자식 노드가 없는 노드를 말합니다. 조상 노드(ancestor node) - 노드 A의 자식을 따라 내려갔을 때 노드 B에 도달할 수 있다면, 노드 A를 노드 B의 조상 노드라고 부릅니다. 자손 노드(descendant node) - 노드 A가 노드 B의 조상 노드일 때, 노드 B를 노드 A의 자손 노드라고 부릅니다. 형제 노드(sibling node) - 같은 부모 노드를 갖는 다른 노드를 보고 형제 노드라고 부릅니다. 123456789101112131415161718192021222324class Node { constructor(content, children = []) {  this. content = content;  this. children = children; }}const tree = new Node('hello', [ new Node('world'), new Node('and'), new Node('fun', [  new Node('javascript!') ])]);function traverse(node) { console. log(node. content); for (let child of node. children) {  traverse(child); }}traverse(tree);// hello world and fun javascript!"
    }, {
    "id": 64,
    "url": "/study_CODE_stack_1/",
    "title": "스택 : 크레인 인형뽑기 게임",
    "body": "2020/07/05 - category: 2019 카카오 개발자 겨울 인턴십 문제 설명게임개발자인 죠르디는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.  죠르디는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다. 게임 화면은 1 x 1 크기의 칸들로 이루어진 N x N 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 5 x 5 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 1 x 1 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 !!바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. 게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.  제한사항     board 배열은 2차원 배열로 크기는 5 x 5 이상 30 x 30 이하입니다.    board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.    0은 빈 칸을 나타냅니다.    1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.    moves 배열의 크기는 1 이상 1,000 이하입니다.    moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.    문제풀이단순 스택문제 풀이이다. 이걸 자바로 풀 생각해보니 스택 imort하고, 선언하고. . 어휴 상상만으로 머리가 아프다. 이래서 파이썬 자바스크립트 하는듯 하다.  자바스크립트는 push &amp; pop을 기본 지원하지만 peek은 지원하지 않아서 Stack을 함수로 만들어줘야하는것 같다. 1234567891011121314151617181920212223242526272829303132333435function solution(board, moves) {  var answer = 0;  const stack = new Stack();  moves. forEach( idx =&gt; {    var target = board. find(_ =&gt; _[idx-1]);    if (!(target === undefined)) {      var moveItem = target. splice(idx-1, 1, 0);      if (stack. peek() === moveItem[0]) {        stack. pop();        answer++;      } else {        stack. push(moveItem[0]);      }    }    })  return answer*2;}class Stack {  constructor() {    this. _arr = [];  }  push(item) {    this. _arr. push(item);  }  pop() {    return this. _arr. pop();  }  peek() {    return this. _arr[this. _arr. length -1];  }}더 좋은 풀이역시 단순한 문제여도 좋은 테크닉은 계속 나오는 것 같다… (물론 아주 작은 차이라고 생각은 되지만 그 차이가 쌓이면 큰 차이가 되겠지. ) 앞서 한 말 취소. .  기존 문제 풀이 같은 경우. moves에서 나온 idx를 기준으로 row별 Serch하여 0이 아닌값을 찾으며 해당 값을 없애는 방식으로 사용했다. 그러면 undefined이 나올 때까지 매번 find를 해야 하는 반복 이슈를 해결하기 위해 0이 아닌값을 찾아 아예 스택(peek이 필요없는)에 쌓아둔다.  그러면 moves에서 나온 idx에 해당하는 stack row를 pop만 해주면 되는 것 아닌가! 테크닉 : matric의 row를 colunm으로 전체 전환-&gt; 전환 row의 0값을 없애주고 순서 보정(반대 정렬) -&gt; 사용 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const transpose = (matrix) =&gt; matrix. reduce( (result, row) =&gt; row. map((_, i) =&gt; [. . . (result[i] || []), row[i]]), []);function solution(board, moves) {  var answer = 0;  const boardStacks = transpose(board). map(row =&gt;    row. reverse(). filter(el =&gt; el !== 0)  );  debugger;  const stack = new Stack();  moves. forEach( idx =&gt; {    var target = boardStacks[idx-1]. pop();    if (target !== undefined) {      if (stack. peek() === target) {        stack. pop();        answer++;      } else {        stack. push(target);      }    }    })  return answer*2;}class Stack { constructor() {  this. _arr = []; } push(item) {  this. _arr. push(item); } pop() {  return this. _arr. pop(); } peek() {  return this. _arr[this. _arr. length -1]; }}"
    }, {
    "id": 65,
    "url": "/study_CODE_sort_3/",
    "title": "정렬 : 튜플",
    "body": "2020/07/04 - category: 2019 카카오 개발자 겨울 인턴십 문제 설명셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다. (a1, a2, a3, …, an) 튜플은 다음과 같은 성질을 가지고 있습니다. 중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2) 원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2) 튜플의 원소 개수는 유한합니다.  원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 (a1, a2, a3, …, an)이 주어질 때(단, a1, a2, …, an은 자연수), 이는 다음과 같이 집합 기호 ‘{‘, ‘}’를 이용해 표현할 수 있습니다. 예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는 와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로 는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다. 특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.  제한사항 s의 길이는 5 이상 1,000,000 이하입니다.  s는 숫자와 ‘{‘, ‘}’, ‘,’ 로만 이루어져 있습니다.  숫자가 0으로 시작하는 경우는 없습니다.  s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다.  s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다.  return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다. 문제풀이제한조건으로 부터 문제해결방향을 잘 파악해야 하는 것 같다.  여기서 중요하게 생각해야 할 제한 조건은 1. 주어진 s가 가리키는 튜플은 중복되는 원소가 없다. 2. 주어진 s는 하나의 튜플을 올바르게 표현한다. 그렇다면 s를 배열로 바꾸고, 배열의 크기에 따라 정렬한 뒤 Set에 넣어주면 해결 해결 난항 요소 - sort()에서 length 간 비교가 가능하다. 매개변수가 없을시 문자열 비교이다. ( 문자열 비교시 : 10 &lt; 2 ) 1234567891011121314151617181920function solution(s) {  var answer = [];  let len = s. length;  const caliValue = s. substr(2,len-4);  let tupleSet = caliValue. split( },{ ). reduce( (list,item) =&gt; {    list. push(item. split( , ));    return list;  }, []). sort((a,b) =&gt; a. length - b. length);  var tuple = new Set();  tupleSet. forEach( i =&gt; {    i. forEach( k =&gt; {      tuple. add(Number(k));    })  });  answer = [. . . tuple];  return answer;}더 좋은 풀이배열로 바꿀수 있는 문자열을 바꾸고자 할떄, 조건을 잘 살펴봐야 한다.  여기선 객체 문자열로 바꿀수 있다.  replace를 사용하여 객체 문자열로 바꿔준 다음 해당 data를 JSON. parse에 집어넣으면 배열로 완성된다. 12345678910111213141516function solution(s) {  var answer = [];  let tupleSet = JSON. parse(s. replace(/{/g, '['). replace(/}/g, ']'))  . sort((a, b) =&gt; a. length - b. length);  var tuple = new Set();  tupleSet. forEach( i =&gt; {    i. forEach( k =&gt; {      tuple. add(Number(k));    })  });  answer = [. . . tuple];  return answer;}"
    }, {
    "id": 66,
    "url": "/study_CODE_sort_2/",
    "title": "정렬 : H-Index",
    "body": "2020/07/03 - 문제 설명H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다. 어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h의 최댓값이 이 과학자의 H-Index입니다. 어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요.  제한사항     과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다.    논문별 인용 횟수는 0회 이상 10,000회 이하입니다.    입출력 예 | participant | return | | — | — | | [3, 0, 6, 1, 5] | 3 | 문제풀이정렬은 수학적 사고력이 더 중요한것 같다. 수능 수학 푼 느낌. 문제 해결을 위한 조건  h는 결국에는 논문 개수.  생각해 볼때, 논문 인용수가 가장 많은 순서대로 논문 개수를 늘려나가며, 개수보다 논문 인용수가 적어지는 때 그때 의 값의 H가 된다. (논문 인용수가 아무리 많더라도 하나밖에 없다면 h는 1. )12345678910function solution(citations) { citations = citations. sort( (a,b) =&gt; b-a); let idx = 0; while( idx+1 &lt;= citations[idx] ){  idx++; } return idx;}정렬 문제는 이런 식이 많을 것 같다. 이래서 이산수학을 배우는 듯. "
    }, {
    "id": 67,
    "url": "/study_CODE_sort_1/",
    "title": "정렬 : 가장 큰 수",
    "body": "2020/06/29 - 문제 설명0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요. 예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다. 0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.  제한 사항     numbers의 길이는 1 이상 100,000 이하입니다.    numbers의 원소는 0 이상 1,000 이하입니다.    정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.    입출력 예 | participant | return | | — | — | | [6, 10, 2] | 6210 | | [3, 30, 34, 5, 9] | 9534330 | 문제풀이정렬의 기준을 어떻게 효과적으로 생각할 수 있는 여부를 판단하는 문제인거 같다. 내가 처음 생각한 기준은, 모든 값을 전체적으로 동일하게 규정을 해버리는 것이었다.  모든 숫자를 끝의 숫자를 증가하는 방식을 이용해 자릿수를 맞춤으로써 값이 동일하게 규정되었다고 판단했다. 1234567891011 var data = numbers. map( i =&gt; {	let changeData = String(i);  let point;  for(let j=1; j&lt;3; j++) {    if(changeData[j] == undefined) {       point = changeData[j-1];      changeData = changeData. concat(point);    }  }  return changeData;})하지만 30, 301을 기준으로 하면 30 -&gt; 300, 301  ==&gt; 30130 &lt; 30301 으로써 동일하게 규정을 할 수가 없음을 확인 하였다. 동일한 규정을 찾으려면 너무 끝도 없었고 차라리 다른 기준을 생각해야 했다. 찾아본 결과 1:1 정렬을 하되 기준을 a와 b가 아닌 ab, ba로 삼아 진행하면 해결이 되었다. 1 var data = numbers. map( i =&gt; i+''). sort((a,b)=&gt; (b+a)-(a+b));데이터에서 0000이 나올수 있으니 방지 차원에서 1 return data[0] === '0' ? '0' : data;이번 문제를 통해 본 정렬 문제 테크닉은 최대한 작게 볼수 있어야 하는 것 같다. "
    }, {
    "id": 68,
    "url": "/study_CODE_recursive_1/",
    "title": "재귀 : 괄호 변환",
    "body": "2020/06/28 - category: 2020 KAKAO BLIND RECRUITMENT 문제 설명카카오에 신입 개발자로 입사한 콘은 선배 개발자로부터 개발역량 강화를 위해 다른 개발자가 작성한 소스 코드를 분석하여 문제점을 발견하고 수정하라는 업무 과제를 받았습니다. 소스를 컴파일하여 로그를 보니 대부분 소스 코드 내 작성된 괄호가 개수는 맞지만 짝이 맞지 않은 형태로 작성되어 오류가 나는 것을 알게 되었습니다. 수정해야 할 소스 파일이 너무 많아서 고민하던 콘은 소스 코드에 작성된 모든 괄호를 뽑아서 올바른 순서대로 배치된 괄호 문자열을 알려주는 프로그램을 다음과 같이 개발하려고 합니다. 용어의 정의‘(‘ 와 ‘)’ 로만 이루어진 문자열이 있을 경우, ‘(‘ 의 개수와 ‘)’ 의 개수가 같다면 이를 균형잡힌 괄호 문자열이라고 부릅니다. 그리고 여기에 ‘(‘와 ‘)’의 괄호의 짝도 모두 맞을 경우에는 이를 올바른 괄호 문자열이라고 부릅니다. 예를 들어, “(()))(“와 같은 문자열은 균형잡힌 괄호 문자열 이지만 올바른 괄호 문자열은 아닙니다. 반면에 “(())()”와 같은 문자열은 균형잡힌 괄호 문자열 이면서 동시에 올바른 괄호 문자열 입니다. ’(‘ 와 ‘)’ 로만 이루어진 문자열 w가 균형잡힌 괄호 문자열 이라면 다음과 같은 과정을 통해 올바른 괄호 문자열로 변환할 수 있습니다.  입력이 빈 문자열인 경우, 빈 문자열을 반환합니다.  문자열 w를 두 “균형잡힌 괄호 문자열” u, v로 분리합니다. 단, u는 “균형잡힌 괄호 문자열”로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다.  문자열 u가 “올바른 괄호 문자열” 이라면 문자열 v에 대해 1단계부터 다시 수행합니다.  3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다.  문자열 u가 “올바른 괄호 문자열”이 아니라면 아래 과정을 수행합니다.  4-1. 빈 문자열에 첫 번째 문자로 ‘(‘를 붙입니다.  4-2. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다.  4-3. ‘)’를 다시 붙입니다.  4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다.  4-5. 생성된 문자열을 반환합니다. 균형잡힌 괄호 문자열 p가 매개변수로 주어질 때, 주어진 알고리즘을 수행해 올바른 괄호 문자열로 변환한 결과를 return 하도록 solution 함수를 완성해 주세요.    매개변수 설명 p는 ‘(‘ 와 ‘)’ 로만 이루어진 문자열이며 길이는 2 이상 1,000 이하인 짝수입니다. 문자열 p를 이루는 ‘(‘ 와 ‘)’ 의 개수는 항상 같습니다. 만약 p가 이미 올바른 괄호 문자열이라면 그대로 return 하면 됩니다.     입출력 예 | p | result | | “(()())()” | “(()())()” | | “)(“ | “()” | | “()))((()” | “()(())() |  문제풀이단순히 설명한 그대로 구현할수 있느냐 이다. 이 문제의 정답률은 1번보다 오히려 적은 23%인데, 아마도 1번을 풀고나서 시간이 없어서 그랬지 않았나 라고 추측해본다.  개인적으로 1번 문제보단 짜기 쉬웠다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class Stack { //stack의 peek이 필요해서 구현했다. 사용하기 편하다.   constructor() {   this. _arr = [];  }  push(item) {   this. _arr. push(item);  }   pop() {   return this. _arr. pop();  }   peek() {   return this. _arr[this. _arr. length -1];  }}function solution(p) {  const makeCollect = (str) =&gt; {    if(str==='') {      return '';    }    var idx = checkBalance(str)    if(idx&gt;=0) {      var sub = str. substring(0,idx);      if(checkCollect(sub)) {        return sub + makeCollect(str. slice(idx));      } else {        return  (  + makeCollect(str. slice(idx))+ )  + reverse(sub);      }    }  }  var answer = makeCollect(p);  console. log(answer);  return answer;}function checkBalance(str) {  if(str === '') {    return -1  }  const stack = new Stack();  stack. push(str. substring(0,1));  let target = str. slice(1);  let count = 1;    while(target !==   ) {    var compare = stack. peek();    if(compare === undefined) {      return count;    }    var compareItem = target. substring(0,1)    if(compare === compareItem) {      stack. push(compareItem);    } else {      stack. pop();    }    target = target. slice(1);    count++;  }  return count;}function checkCollect(str) {  const stack = new Stack();  var firstElement = str. substring(0,1)    if(firstElement !==  ( ) {    return false;  }  stack. push(firstElement);  let target = str. slice(1);  let flag = true;    while(target !==   ) {    var compare = stack. peek();    var compareItem = target. substring(0,1)    if(compare === undefined) {      if(firstElement !==  ( ) {        return false;      }    } else if(compare === compareItem) {      stack. push(compareItem);    } else {      stack. pop();    }    target = target. slice(1);  }  return true;}function reverse(str) {  if(str. length &lt;=2) {    return '';  }  let target = str. substr(1, str. length-2);  let reverseTarget = '';  while(target !==   ) {    var compare = target. substring(0,1)    if(compare ===  ( ) {      reverseTarget +=  ) ;    } else {      reverseTarget +=  ( ;    }    target = target. slice(1);  }  return reverseTarget;}"
    }, {
    "id": 69,
    "url": "/study_CODE_practice_6/",
    "title": "연습문제 : 2 x n 타일링",
    "body": "2020/06/28 - category: url: https://programmers. co. kr/learn/courses/30/lessons/12900# 문제풀이문제가 동적 프로그래밍을 보기 위해서 만든 문제이다.  그렇다 보니, return 값이 너무나도 커져야 하는 문제가 존재하는데, 이를 해결하기 위한 방법을 제대로 이해하지 못했다. 물론 그전에 동적 프로그래밍인지를 아는 것도 수학적인 문제라 쉽게 파악하지 못했다. 이 문제를 풀기 위해선  타일이 놓일 조건이 가로일 때 1개, 세로일 떄 2개가 깔릴 경우 각각의 경우의 수를 깔리지 않을 값에 더해주는 점화식을 이끌어 낼수 있느냐. n = [n-1] + [n-2] 각각의 조합을 구해보면, 파스칼 삼각형을 통해 피보나치 수열임을 이끌어 낼수 있느냐. 두가지로 나뉠 수 있다.  올림피아드 문제를 그냥 프로그래밍으로 옮겨 놓은 듯한 문제.  따지고 보면 결국 피보나치 동적 프로그래밍을 할수 있느냐인데, 이는 동적 프로그래밍을 배우면 가장 먼저 알게되는 사항이라, 솔직히 상당히 별로인 문제. 그런데 거기서 끝나지 않는다! 문제의 효율성을 파악하기 위해 커져버린 return 값을 해결하기 위해, 출제자는 동적 프로그래밍으로만 풀도록 제한 해야 하는 만큼, limit값이 넘어버리면 다음 피보나치 값은 제한이 걸린 채로 움직인다. 만일 각각의 조합을 직접 구하고 마지막 return에만 제한을 걸어버리면 답이 다르게 된다. 여러모로 신경써야 할 부분이 많았던 문제이다. 1234567function solution1(n) {  let arr = [1, 2];  for (let i = 2; i &lt; n; i++) {    arr[i] = (arr[i - 1] + arr[i - 2])%1000000007; // 제한이 걸린채 값이 정해진다.   }  return arr[n-1];}12345678910111213141516171819202122232425262728293031323334function solution(n) {  var answer = 0;  let twoCount = 0;  let oneCount = n;  answer += getCombination(oneCount, twoCount);  while(n&gt;1) {    n -= 2;    oneCount -= 2;    twoCount++;    answer += getCombination(oneCount, twoCount);  }    return answer%1000000007; //마지막 값에서만 제한을 걸다 보니, 값이 다르다. 그렇다고 아래 total값에 제한을 걸기도 애매하다. }function getCombination(oneCount, twoCount) {  if(oneCount === 0 || twoCount === 0) {    return 1;  }  let total = oneCount+twoCount;  let top = 1;  let bottom = 1;    for(let i=0; i&lt;total; i++) {    top *= total-i;  }  for(let j=0; j&lt;oneCount; j++) {    bottom *= oneCount-j;  }  for(let k=0; k&lt;twoCount; k++) {    bottom *= twoCount-k;  }  return top/bottom}"
    }, {
    "id": 70,
    "url": "/study_CODE_practice_5/",
    "title": "연습문제 : 카펫",
    "body": "2020/06/28 - category: url: https://programmers. co. kr/learn/courses/30/lessons/42842?language=javascript 문제풀이우선 yellow의 약수를 x, y라고 하자.  제한조건에서 brown이 정확하게 들어온다고 가정할 시, brwon은 2(x+y)+4가 될 것이다. 이때 주어진 brown과 값이 같다면 끝. 테스트 케이스에 yellow가 1개인 경우가 있어서 다행히 yellow에 +1를 할 수 있었다. 없을 경우도 생각해서 제출할 때, 테스크 케이스를 확인하고 제출하자. 1234567891011121314151617function solution(brown, yellow) {  var answer = [];  let x, y;  for(let i=1; i&lt;yellow+1; i++) {    if(yellow%i === 0 ) {      x = i;      y = yellow/i;      var brownNum = 2*(x+y)+4;      if(brownNum === brown) {        break;      }    }  }  answer. push(y+2);  answer. push(x+2);  return answer;}"
    }, {
    "id": 71,
    "url": "/study_CODE_practice_4/",
    "title": "연습문제 : 스킬트리",
    "body": "2020/06/27 - category: url: https://programmers. co. kr/learn/courses/30/lessons/49993 문제풀이주어진 조건에 맞춰 구현을 할수 있는지를 묻는 문제이다.  문자열을 다루는 문제라고도 할수 있다. 문제 해결의 방향을 입력에서 오는 문자열을 하나씩 빼면서 검사하도록 잡았는데, 처음 문제를 인식할 때 스킬은 입력한 스킬이며 해당 입력 스킬을 스킬트리 내에서 가능한 개수를 파악하는 것으로 이해했었다. 첫단추부터 잘못 꿰었어서 문제 해결하는 데 시간이 꽤 오래 걸렸다. 또한, 하나씩 빼면서 하는 검사다 보니 반복조건을 문자열이 비었을 경우로 생각을 해야 했다. 그렇게 되면 마지막에 가지게 되는 문자열은 검사를 해보지 못하게 된다. 그래서 마지막에 추가 검사를 해줌으로 해결하였다. 12345678910111213141516171819202122232425262728function enableSkill(skill, skill_tree) {  let compare = skill. slice();  let forUse = skill_tree. slice();    let tree = forUse[0];  forUse = forUse. substring(1);  let target = compare[0];  compare = compare. substring(1);  while(forUse != '') {    if(compare. includes(target)) {      return false;    } else if (target === tree) {      target = forUse[0];      forUse = forUse. substring(1);      tree = compare[0];       compare = compare. substring(1);    } else {      target = forUse[0];      forUse = forUse. substring(1);    }  }  if(compare. includes(target)) {    return false;  }  return true;} for문을 사용하여 더 깔끔하게 코드 작성. ```javascriptfunction solution(skill, skill_trees) { var answer = 0; skill_trees. forEach( i =&gt; {   if(enableSkill(skill, i)) {     console. log(i);     answer++;   }  }) return answer;}function enableSkill(skill, skill_tree) {  let compare = skill. slice();  let forUse = skill_tree. slice();  let tree = compare[0];  compare = compare. substring(1); 1234567891011for(let i=0, len=forUse. length; i&lt;len; i++) {  if(compare. includes(forUse[i])) {    return false;  }  else if(tree === forUse[i]) {    tree = compare[0];    compare = compare. substring(1);  }}return true; } ``` # 다른 풀이  내가 생각한 방법은, false 조건을 만들어서 구현했다. 그런데 아래 풀이는 true 조건을 만들고 구현한 방법이다. 123456789101112function solution(skill, skill_trees) {  function isCorrect(n) {    let test = skill. split('');    for (var i = 0; i &lt; n. length; i++) {      if (!skill. includes(n[i])) continue;      if (n[i] === test. shift()) continue;      return false;    }    return true;  }    return skill_trees. filter(isCorrect). length;}"
    }, {
    "id": 72,
    "url": "/study_CODE_practice_3/",
    "title": "연습문제 : 멀쩡한 사각형",
    "body": "2020/06/27 - category: url: https://programmers. co. kr/learn/courses/30/lessons/62048 문제풀이수학문제를 풀어야 한다. 대각선이 지나는 단위 정사각형.  물론 조금만 더 생각해 보면, 수학적 사고력으로 해결할 수 있는 문제이나, 제한시간이 주어지고 갑자기 수학적 사고를 하도록 한다면 문제를 해결할 수 있을지 부정적이다. 마지막으로 미뤄두고 풀어보도록 해야지. 우선 서로소인 사각형의 대각선을 생각해 보자.  서로소인 관계를 설정하는 이유는, 그렇지 않을 때 대각선은 나뉘어지는 부분이 있기 때문.  예를들어 5X4인 사각형(서로소인 관계의 사각형)의 대각선이 칠해진 개수는 1234567891011121314151617181920212223□□□■■□□■■□□■■□□■■□□□□□□□■□□□■■□□■■□■■■□□ □□□□■□□□□■□□□■■■■■■□□□□□■□□□□■□□□□■■■■■■5+4-1 = 8개가로 + 세로 -1 이 대각선에 의해 칠해진 개수가 된다. mn 사각형에서 m과 n의 최대공약수가 a라고 할 떄, m = ab, n = ac 라고 할 수 있다. (b와 c는 서로소) 그렇게 되면 mn의 사각형의 넓이는 a^2bc이며  이는 bc의 사각형이 a^2개가 있다고 생각할 수 있다. 이때 잘 생각해 보면 대각선이 지나가는 bc의 사각형은 a개가 될수 있다.  따라서 bc의 대각선에 의해 칠해진 사각형 개수는 b+c-1 m*n의 사각형의 경우 a(b+c-1) = ab+ac-a = 가로 + 세로 - 가로와 세로의 최대공약수 이렇게 해결. 123456789101112131415161718192021222324  function solution(n) {  var answer = '';  let value = n;  while(value&gt;3) {    var div = parseInt(value/3);    var rest = value%3;    if(rest === 0) {      value = div-1;      answer = '4' + answer; //먼저 오게 함으로써 자릿수 보정    } else {      value = div;      answer = rest + answer;    }  }  if(value === 3) {    answer = '4' + answer;  } else {    answer = value + answer;  }  return answer;}"
    }, {
    "id": 73,
    "url": "/study_CODE_practice_2/",
    "title": "연습문제 : 124 나라의 숫자",
    "body": "2020/06/27 - category: url: https://programmers. co. kr/learn/courses/30/lessons/12899 문제풀이규칙성을 찾고, 해당 규칙을 구현할 수 있는지 알아보는 문제.  규칙을 구현하기에 걸림이 되었던 부분은 0이 존재하지 않으며, 3진수이지만 자릿수가 올라 갈 경우 올라가지 않고 4가 붙는다는 사실이다. 해당 경우에 대한 대처를 해 놓은다면 문제 풀기는 수월했다. 123456789101112131415161718192021222324  function solution(n) {  var answer = '';  let value = n;  while(value&gt;3) {    var div = parseInt(value/3);    var rest = value%3;    if(rest === 0) {      value = div-1;      answer = '4' + answer; //먼저 오게 함으로써 자릿수 보정    } else {      value = div;      answer = rest + answer;    }  }  if(value === 3) {    answer = '4' + answer;  } else {    answer = value + answer;  }  return answer;}"
    }, {
    "id": 74,
    "url": "/study_CODE_practice_1/",
    "title": "연습문제 : 소수찾기",
    "body": "2020/06/27 - category: 문제 설명1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요. 소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.  (1은 소수가 아닙니다. )  제한사항 n은 2이상 1000000이하의 자연수입니다. 입출력 예 | n | result | | — | — | | 10 | 4 | | 5 | 3 | 문제풀이단순 수학 문제이다.  수학시간에 배운 어떤 체… 를 이용하면 쉽게 해결할 수 있다. 12345678910111213141516  let answer = 0;  let arr = [];  for (let i = 2; i &lt;= n; i++) {    arr[i] = i; // 순서를 맞추기 위함. 2번자리에 2가 들어가게끔 조정.   }  for (let i = 2; i &lt;= n; i++) {    if (arr[i] === 0)       continue;    for (let j = i + i; j &lt;= n; j += i) {      arr[j] = 0;    }  }    return arr. filter( i =&gt; i !== 0). length;(번외) 소수판단12345678910function isPrimeNumber(number) { const notPrime = [0, 1]; if (notPrime. includes(number)) return false; for (let i = 2; i * i &lt;= number; i++) {    //number의 제곱근만 판단해도 소수판단 가능  if (number % i === 0) return false; } return true;}"
    }, {
    "id": 75,
    "url": "/study_CODE_powerSet/",
    "title": "멱집합",
    "body": "2020/06/26 - 멱집합탐색 문제에서 멱집합을 이용해야 하는 경우가 종종 있다. 이해하고 사용하자. ## 부분집합 부분집합을 구성하는 방법은 원소를 사용여부(O/X)로 구분된다. 이는 이진트리로 구현할수 있는데.  단계를 구성하고 각 이진트리에 들어갈때마다 flag에 O,X를 기록한다.  마지막 단계에 들어가게 되면 해당 flag를 바탕으로 해당하는 set을 Array에서 찾고 powerSet에 push한다. 12345678910111213141516171819202122232425const getPowerSet = function (arr) {  let flag = new Array(arr. length). fill(false);  const powerSet = [];  let len = arr. length;  const makePowerSet = (depth) =&gt; {    if (depth === len) {     const subSet = arr. filter((value, idx) =&gt; flag[idx]);     powerSet. push(subSet);     return;   }    flag[depth] = true;    makePowerSet(depth+1);    flag[depth] = false;   makePowerSet(depth+1);  }    makePowerSet(0);  return powerSet; }  const example = [1,2,3]; const result = getPowerSet(example); console. log(result);잘 생각해야 하는건 어차피 각 단계별로 flag를 새로 기입해야 하므로, 함수에 flag를 매개로 넣어줄 필요가 없다. "
    }, {
    "id": 76,
    "url": "/study_CODE_permutation&combination/",
    "title": "순열과 조합",
    "body": "2020/06/26 - 순열과 조합순열과 조합은 여러 군데에서 쓰인다.  쓰이는 방식도 다양한데,  각각의 배열의 값으로써 조합된 숫자로써1하지만 설계하는게 쉬운일이 아니기 때문에, 배열로 사용할수 있는 그리고 조합된 숫자를 사용하도록 String으로 사용하는 각각의 함수를 만들어 놓고자 한다. nPr, nCr 값수학이다.  nPr =&gt; n개의 경우를 r번 사용할경우.  nCr =&gt; nPr에서 중복 제외 123456789101112131415161718192021function combination(n, r) { let top = 1; let bottom = 1; for(let i=0; i&lt;r; i++) {  top *= n-i;  bottom *= r-i; } return top/bottom;}function permutation(n, r) { let value = 1; for(let i=0; i&lt;r; i++) {  value *= n-i; } return value;}배열의 원소로 만들수 있는 가능한 모든 조합자주 나오는 문제이다. 기능을 추가해서 해결해야할 문제들이니 잘 알아두자. 12345678910111213141516171819202122//list 값은 문자열!/*** input은 배열, output은 배열의 순열조합으로 이루어진 String*/var myList = [1, 2, 3, 4];var test = findAllPermutation(myList);function findAllPermutation(list, prevValue) { const frontPaddingValue = prevValue || ''; return list. reduce((listNumbers, value, index) =&gt; {  listNumbers. push(frontPaddingValue+value);  const nextNumberList = [. . . list];  nextNumberList. splice(index, 1);  const result = findAllPermutation(   nextNumberList, frontPaddingValue + value  );  listNumbers. push(. . . result);  return listNumbers; }, []);}잘 생각해 보자. 배열 내 각각의 요소를 저장한 그 전값과 합쳐주면 된다. 단 각각의 요소를 연산할 때 동일한 조건을 가지도록 해야 한다. (reduce의 강점. ) ex [1, 2, 3]  1을 가지고 들어가서 [2, 3]의 요소와 합쳐준다. 그런 행위를 할때마다 push 123456789101112131415161718192021222324/** * output : 배열 * @param {*} inputArr : Input 배열이다.  * 전반적인 매커니즘은 pick에서 하나씩 가지고 재귀함수로 들어간다. */function permutator(inputArr, rValue) { var results = []; var r = inputArr. length-rValue;  function permute(arr, pick) {  var cur, pick = pick || [];  for (var i = 0; i &lt; arr. length; i++) {   cur = arr. splice(i, 1);   results. push(pick. concat(cur));   permute(arr. slice(), pick. concat(cur));   arr. splice(i, 0, cur[0]);  }  return results; } return permute(inputArr);}Permutation12345678910111213141516171819202122232425262728293031/*** 만일 해당 조합을 숫자로 사용할 경우에 쓰도록 output이 String값. */var myList = [1, 2, 3, 4];var test = findAllPermutation(myList, 4); //4개 조합 ex 1234function findPermutation(stringList, rValue) {   const len = stringList. length;  const startCount = 1; //현재 조합을 뽑은 숫자. 재귀로 하나씩 뽑아갈때마다. count가 증가.   function makePermutation(stringList, count, rValue, prevValue) {    const frontPaddingValue = prevValue || ''; //값이 없을 경우 빈 문자로 초기화    let pivotCount = count; //재귀로 들어올때마다 기준 Count를 정함.     //reduce 과정에서 count값이 변경되므로 list의 요소가 끝날때 마다 다시 기준 Count를 잡아줌.     return stringList. reduce( (listNumbers, value, idx) =&gt; {      count = pivotCount;      if(count === rValue) {        listNumbers. push(frontPaddingValue+value);        return listNumbers;      }      const nextNumberList = [. . . stringList];      nextNumberList. splice(idx, 1);      count++; //아래와 동일      //count = 1+len-nextNumberList. length;       const result = makePermutation(nextNumberList, count, rValue, frontPaddingValue + value);      listNumbers. push(. . . result);      return listNumbers;    }, []);  }  return makePermutation(stringList, startCount, rValue);}findAllPermutation에 pivotCount를 지정하여 해당 Count일때의 집합을 저장. 123456789101112131415161718192021222324252627282930/** * * @param {*} inputArr : Input 배열이다.  * @param {*} rValue : nPr에서 r이며, 배열의 길이보다 적게 들어와야한다. * * 전반적인 매커니즘은 pick에서 하나씩 가지고 재귀함수로 들어간다. */function permutator(inputArr, rValue) { var results = []; var r = inputArr. length-rValue; // 정확히는 arr의 length가 남는 개수에 따라 result값에 push를 한다. 즉 1개를 썼으면 3개가 남았으니까 1개 result.   function permute(arr, pick) {   var cur, pick = pick || [];  for (var i = 0; i &lt; arr. length; i++) {   cur = arr. splice(i, 1);   if (arr. length === r) {    results. push(pick. concat(cur));   }   permute(arr. slice(), pick. concat(cur));   arr. splice(i, 0, cur[0]);  }  return results; } return permute(inputArr);}Combination## 하나의 집합 내에서 조합 123456789101112131415161718192021222324const getCombinations = (arr, m) =&gt; {  const combinations = [];  const picked = [];  function find(picked) {    if (picked. length === m) {      const rst = [];      for (let i of picked) {        rst. push(arr[i]);      }      combinations. push(rst);      return;    } else {      let start = picked. length ? picked[picked. length - 1] + 1 : 0;      for (let i = start; i &lt; arr. length; i++) {        picked. push(i);        find(picked);        picked. pop();      }    }  }  find(picked);  return combinations;}하나의 집합 중 같은 값이 있을 경우 ([1, 2, 2, 3] 과 같은 숫자에서 combination을 뽑고자 할떄) 123456789101112131415161718192021222324252627282930const getCombinations = (arr, m) =&gt; { arr. sort(); //같은 값이 연속으로 들어오도록 강제 const combinations = []; const picked = []; const used = new Array(arr. length). fill(false);  function find(picked) {  if (picked. length === m) {   const rst = [];   for (let i of picked) {    rst. push(arr[i]);   }   combinations. push(rst);   return;  } else {   let start = picked. length ? picked[picked. length-1] + 1 : 0;   for (let i = start; i &lt; arr. length; i++) {    if (i === 0 || arr[i] !== arr[i-1] || used[i-1]) {     picked. push(i);     used[i] = 1;     find(picked);     picked. pop();     used[i] = 0;    }   }  } } find(picked); return combinations;}## 두개의 집합간 조합 ### 독립된 두개의 집합 12345678910  function getCombination(arr_a, arr_b) {  var answer = 0;  const combination = [];  arr_a. forEach( a =&gt; {    arr_b. forEach( b =&gt; {      combination. push([a, b]);    })  })  return combination;  } ### 종속적인 두개의 집합  아래의 문제해결은 하나의 배열안에 2개배열을 넣을 경우에 해당하고,  만일 특정 조건으로 2개 배열을 구성할수 있다면 기존 하나의 배열에서의 조합 문제 해결방식을 따른다. (조합문제_1 참고) 12  // parentSet = [0, 1, 2, 3, 4]  var arraySet = [[0, 2], [1, 2], [3, 4]];1234567891011121314151617181920212223242526272829303132333435363738 function getCombination(arrays) {  var answer = {};  function makeCombination(i = 0, selected = []) {    if (!arrays[i]) {      selected. sort(); //당연히 조합이기 때문에 순서가 다른 같은 값은 중복처리해줘야 한다.       answer[selected. join('')] = true;      return;    }    arrays[i]. filter(e =&gt; !selected. includes(e)). forEach(e =&gt; {      makeCombination(i + 1, selected. concat([e]));    });  }    makeCombination();  return answer;}/** 순서가 같은 다른 값 ex) arraySet = [[0, 2], [1, 2], [3, 4], [3, 4]]; 일 경우   [0, 1, 4, 3] , [0, 1, 3, 4] 를 튜플로서 처리하자면 아래와 같다. */ function getCombination(arrays) {  var answer = [];    function makeCombination(i = 0, selected = []) {    if (!arrays[i]) {      answer. push(selected);      return;    }    arrays[i]. filter(e =&gt; !selected. includes(e)). forEach(e =&gt; {      makeCombination(i + 1, selected. concat([e]));    });  }    makeCombination();  return answer;}"
    }, {
    "id": 77,
    "url": "/study_CODE_permutation_1/",
    "title": "순열 : 외벽 점검",
    "body": "2020/06/25 - category: 2020 KAKAO BLIND RECRUITMENT 문제 설명레스토랑을 운영하고 있는 스카피는 레스토랑 내부가 너무 낡아 친구들과 함께 직접 리모델링 하기로 했습니다. 레스토랑이 있는 곳은 스노우타운으로 매우 추운 지역이어서 내부 공사를 하는 도중에 주기적으로 외벽의 상태를 점검해야 할 필요가 있습니다. 레스토랑의 구조는 완전히 동그란 모양이고 외벽의 총 둘레는 n미터이며, 외벽의 몇몇 지점은 추위가 심할 경우 손상될 수도 있는 취약한 지점들이 있습니다. 따라서 내부 공사 도중에도 외벽의 취약 지점들이 손상되지 않았는 지, 주기적으로 친구들을 보내서 점검을 하기로 했습니다. 다만, 빠른 공사 진행을 위해 점검 시간을 1시간으로 제한했습니다. 친구들이 1시간 동안 이동할 수 있는 거리는 제각각이기 때문에, 최소한의 친구들을 투입해 취약 지점을 점검하고 나머지 친구들은 내부 공사를 돕도록 하려고 합니다. 편의 상 레스토랑의 정북 방향 지점을 0으로 나타내며, 취약 지점의 위치는 정북 방향 지점으로부터 시계 방향으로 떨어진 거리로 나타냅니다. 또, 친구들은 출발 지점부터 시계, 혹은 반시계 방향으로 외벽을 따라서만 이동합니다. 외벽의 길이 n, 취약 지점의 위치가 담긴 배열 weak, 각 친구가 1시간 동안 이동할 수 있는 거리가 담긴 배열 dist가 매개변수로 주어질 때, 취약 지점을 점검하기 위해 보내야 하는 친구 수의 최소값을 return 하도록 solution 함수를 완성해주세요.  제한사항 n은 1 이상 200 이하인 자연수입니다.  weak의 길이는 1 이상 15 이하입니다.  서로 다른 두 취약점의 위치가 같은 경우는 주어지지 않습니다.  취약 지점의 위치는 오름차순으로 정렬되어 주어집니다.  weak의 원소는 0 이상 n - 1 이하인 정수입니다.  dist의 길이는 1 이상 8 이하입니다.  dist의 원소는 1 이상 100 이하인 자연수입니다.    친구들을 모두 투입해도 취약 지점을 전부 점검할 수 없는 경우에는 -1을 return 해주세요.   입출력 예 | n | weak | dist | result | | 12 | [1, 5, 6, 10] | [1, 2, 3, 4] | 2 | | 12 | [1, 3, 4, 9, 10] | [3, 5, 7] | 1 |문제풀이문제의 해결 방안을 전혀 생각하지 못하였다.  dist가 큰 값부터 하는 방법으로 생각을 해봤지만, 도저히 방도가 생각이 안났다.  이런 경우는 대부분 완전탐색이라는 것을 기억하자. 우선 dist가 오는 순서를 정할수 있으며, 해당 순서에 맞게 weak값을 지정하는 방법으로 문제를 풀어 나갈 수 있다. dist의 순서는 dist 전체 값으로 하는 순열으로 만들수 있다. 그러면 해결 가능하다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879var n = 12;var weak = [1, 3, 4, 9, 10]; //[1, 3, 4, 9, 10]var dist = 	[3, 5, 7]; //[3, 5, 7]var test = solution(n, weak, dist);function solution(n, weak, dist) { const distLen = dist. length; const distSet = permutator(dist, distLen); let testWeak = weak. slice(); const weakLen = weak. length; let count = -1;  for(let i=0; i&lt;weakLen; i++) {  distSet. forEach( item =&gt; {   var result = check(item, testWeak);   if (result &gt; 0) {    if(count&lt;0) {     count = result    } else{     if(count &gt; result) {      count = result;     }    }   }  })  let change = testWeak. splice(0,1);  testWeak. splice(weakLen, 0, change[0]+n); }  return count;}function check(item, weak) { let weakIdx = 0; let weakLen = weak. length; let count = 0; for(let i=0, len=item. length; i&lt;len; i++) {  var canRepair = item[i] + weak[weakIdx];  count++;  weakIdx++;  while(weakIdx&lt;weakLen){   if(canRepair &gt;= weak[weakIdx]) {    weakIdx++;   } else {    break;   }  }  if(weakIdx === weakLen) {   break;  } }  if(weakIdx === weakLen) {  return count; } else {  return -1; }}function permutator(inputArr, rValue) { var results = []; var r = inputArr. length-rValue; // 정확히는 arr의 length가 남는 개수에 따라 result값에 push를 한다. 즉 1개를 썼으면 3개가 남았으니까 1개 result.   function permute(arr, pick) {   var cur, pick = pick || [];  for (var i = 0; i &lt; arr. length; i++) {   cur = arr. splice(i, 1);   if (arr. length === r) {    results. push(pick. concat(cur));   }   permute(arr. slice(), pick. concat(cur));   arr. splice(i, 0, cur[0]);  }  return results; } return permute(inputArr);}"
    }, {
    "id": 78,
    "url": "/study_CODE_javaScriptTemplet/",
    "title": "자바스크립트",
    "body": "2020/06/24 - 숫자 -&gt; 문자 값을 String으로 변환. 12 var numValue = 1; String(numValue); 값에 ‘‘를 추가  12 var numValue = 1; numValue = numValue + '';   배열에 객체 넣기123 var data = []; var key =  key  //이때 key값의 숫자로 구성되어 있을경우 data는 숫자로 판단한다.  data[key] = anyValue;prototype. sort();매개변수가 없으면 문자열로 정렬. 1 prototype. sort( (a, b) =&gt; a-b );객체를 이용할 경우 1234567891011121314151617181920 var items = [ { name: 'Edward', value: 21 }, { name: 'Sharpe', value: 37 }, { name: 'And', value: 45 }, { name: 'The', value: -12 }, { name: 'Magnetic', value: 13 }, { name: 'Zeros', value: 37 } ];// value 기준으로 정렬items. sort(function (a, b) { if (a. value &gt; b. value) {  return 1; } if (a. value &lt; b. value) {  return -1; } // a must be equal to b return 0;});sort의 return 값이 1이면 바꿈, -1이면 바꾸지 않는다. # sort() sort를 그냥 두면 문자열 정렬이다 (10 &lt; 2)  따라서 숫자 정렬시 무조건 sort((a,b) =&gt; a-b); 꼭 쓰자 # forEach, reduce, filter, map  forEach =&gt; return x  reduce =&gt; return o (한줄시 생략)  map =&gt; return o (한줄시 생략) filter =&gt; return true 이면 가지고 옴. # … 문법  배열 할당 12345678910[a1, a2, . . . rest_a] = [1, 2, 3, 4, 5, 6, 7, 8, 9];console. log(a1); // 1console. log(a2); // 2console. log(rest_a); // [3, 4, 5, 6, 7, 8, 9]var { a1, a2, . . . rest_a } = { a1 : 10, a2 : 20, a3 : 30, a4 : 40 };console. log(a1); // 10console. log(a2); // 20console. log(rest_a); // { a3: 30, a4: 40 }Number()문자열을 숫자로 -&gt; 바꿀수 없을경우 NaN Set()12345678910 const foo = new Set(); foo. add({}); // 빈 객체 추가 foo. add({}); // 또 다른 빈 객체 추가 console. log(foo. size); // 2 console. log(foo) // Set { {}, {} } foo. add(10); // 숫자 10 추가 foo. add('10'); // 문자열  10  추가 foo. add(10); // 이미 10이 있기때문에 무시됩니다 console. log(foo. size); // 4 console. log(set); // Set { {}, {}, 10, '10' }prototype. has(값) — set에 값 존재 확인. true 또는 false를 반환.  prototype. delete(값) — set에서 값을 제거.  prototype. clear() — set에서 모든 값을 제거. 123 const foo = new Set([ '아이폰XR', '갤노트9' ]); const fooInArray = [ . . . foo ]; console. log(fooInArray) // [ '아이폰XR', '갤노트9' ];Array. splice();배열의 기존 요소를 삭제 또는 교체 12345678const months = ['Jan', 'March', 'April', 'June'];months. splice(1, 0, 'Feb'); //1번 index에 삭제 없이 값 추가console. log(months); // expected output: Array [ Jan ,  Feb ,  March ,  April ,  June ]months. splice(4, 1, 'May'); // 4번 index에 1개 삭제 후 값 추가console. log(months);// expected output: Array [ Jan ,  Feb ,  March ,  April ,  May ]or 연산자값이 들어오지 않을 경우 초기값을 설정하고자 할때 다음과 같이 해보자. 1const initValue = (value) =&gt; theTitle ||  initial Vlaue ; 문자열 합치기단순히 더해주면 합쳐진다. 1 1  +  2  //  12 배열 합치기1234const alpha = ['a', 'b', 'c'];alpha. concat(1, [2, 3]);// 결과: ['a', 'b', 'c', 1, 2, 3]중복 값 제거하기 Set() 이용  123prototype = new Set();prototype. add( key );[. . . prototype. keys()];    객체 이용  12prototype[ key ] = true;Object. keys( prototype );   # JSON. parse(text[, reviver]) 배열 및 객체문법에 속한 Text문을 배열 및 객체로 변환해준다. 1234const json1 = '{ result :true,  count :42}';const json2 =  [[1,2,3],[2,1],[1,2,4,3],[2]] ;const obj1 = JSON. parse(json1);const obj2 = JSON. parse(json2); # String. prototype. replace()  String 안에 있는 값을 찾아 원하는 값으로 바꿔준다.  문자열 리턴! 12g : 발생할 모든 pattern에 대한 전역 검색i : 대/소문자 구분 안함12345678910const p = 'The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?';const regex = /dog/gi;console. log(p. replace(regex, 'ferret'));// expected output:  The quick brown fox jumps over the lazy ferret. If the ferret reacted, was it really lazy? console. log(p. replace('dog', 'monkey'));// expected output:  The quick brown fox jumps over the lazy monkey. If the dog reacted, was it really lazy? # 배열 n개로 나누기 123456789101112Array. prototype. division = function (n) { var arr = this; var len = arr. length; var cnt = Math. floor(len / n); var tmp = []; for (var i = 0; i &lt;= cnt; i++) {  tmp. push(arr. splice(0, n)); } return tmp;}12345678910const division = (arr, n) =&gt; { var len = arr. length; var cnt = Math. floor(len / n); var tmp = []; for (var i = 0; i &lt;= cnt; i++) {  tmp. push(arr. splice(0, n)); } return tmp;}matrix row -&gt; column 전환 한줄 전환```javascriptvar row = [0, 0, 0, 4, 3];var result = [];result = row. map( (_, i) =&gt; […(result[i] || []), row[i]]);/*row -&gt; column [0,       0,       0,       4,       3]*/12345678 - 전체 시계반대방향 전환```javascriptconst transpose = (matrix) =&gt; matrix. reduce( (result, row) =&gt; row. map((_, i) =&gt; [. . . (result[i] || []), row[i]]), []); 전체 시계방향 전환  12345678function rotation(key) { let result = []; debugger; for(let i=key. length-1; i&gt;=0; i--) {   result = key[i]. map( (_, $) =&gt; [. . . (result[$] || []), key[i][$]]); } return result; }   디폴트 매개변수디폴트 매개변수를 설정함으로써 함수 밖에서 일부로 설정을 안해줘도 되게 한다. 123456function multiply(a, b = 1) { return a*b;}multiply(5); // 5multiply(5, 2); // 10# nXn matrix 생성 1 new Array(n). fill(0). map( () =&gt; Array(n). fill(0));문자열 빼기str은 변경되지 않는다. 12 var str =  abcd ; var removeFirst = str. substring(1);"
    }, {
    "id": 79,
    "url": "/study_CODE_hashCollision/",
    "title": "해시충돌문제 : 호텔 방 배정",
    "body": "2020/06/23 - category: 2019 카카오 개발자 겨울 인턴십 문제 4문제 설명정확성 &amp; 효율성 테스트 스노우타운에서 호텔을 운영하고 있는 스카피는 호텔에 투숙하려는 고객들에게 방을 배정하려 합니다. 호텔에는 방이 총 k개 있으며, 각각의 방은 1번부터 k번까지 번호로 구분하고 있습니다. 처음에는 모든 방이 비어 있으며 스카피는 다음과 같은 규칙에 따라 고객에게 방을 배정하려고 합니다. 한 번에 한 명씩 신청한 순서대로 방을 배정합니다.  고객은 투숙하기 원하는 방 번호를 제출합니다.  고객이 원하는 방이 비어 있다면 즉시 배정합니다.  고객이 원하는 방이 이미 배정되어 있으면 원하는 방보다 번호가 크면서 비어있는 방 중 가장 번호가 작은 방을 배정합니다.  예를 들어, 방이 총 10개이고, 고객들이 원하는 방 번호가 순서대로 [1, 3, 4, 1, 3, 1] 일 경우 다음과 같이 방을 배정받게 됩니다. 원하는 방 번호	배정된 방 번호   1	1   3	3   4	4   1	2   3	5   1	6 전체 방 개수 k와 고객들이 원하는 방 번호가 순서대로 들어있는 배열 room_number가 매개변수로 주어질 때, 각 고객에게 배정되는 방 번호를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.  제한사항     k는 1 이상 1012 이하인 자연수입니다.    room_number 배열의 크기는 1 이상 200,000 이하입니다.    room_number 배열 각 원소들의 값은 1 이상 k 이하인 자연수입니다.    room_number 배열은 모든 고객이 방을 배정받을 수 있는 경우만 입력으로 주어집니다.    예를 들어, k = 5, room_number = [5, 5] 와 같은 경우는 방을 배정받지 못하는 고객이 발생하므로 이런 경우는 입력으로 주어지지 않습니다.    문제풀이해시를 이용해 값을 저장할 때, 충돌 문제를 얼마나 효율적으로(빠르면서, 공간을 적게쓰도록) 생각보다 재귀함수는 느리지 않았다. (어차피 for문을 도는 거라서 도는 거만큼 함수를 return 하니까. ) 더욱 빠르게 하기 위해 추가로 설정하면 설정한 만큼 동작을 더해야하기 때문에 가장 최소화 하는게 좋다.  그리고 공간 이슈는 [재귀 함수 발생 수 + flag 배열 생성시 차지하는 공간] 을 중점적으로 살펴봐야 한다.  1차 시도 - 정확도 100%, 속도 100%, 공간활용 0%  해시 충돌 문제 해결에서 배운 단순히 flag 설정하여 하나씩 찾아가며 해결했다.   최대속도는 1000ms 최소속도는 10ms 편차가 큰 편1234567891011121314151617181920212223function solution(k, room_number) {  var answer = [];  let used = new Array(k+1). fill(false);  function searchRoom(idx) {    debugger;    if(idx === used. length){      return;    }    if(!used[idx]) {      used[idx] = true;      answer. push(idx);    } else {      searchRoom(idx+1);    }    return;  }    room_number. forEach( i =&gt; {    searchRoom(i);  })  return answer;} 재귀를 이용하지 않고 for문을 통해 다음 index를 찾아 문제 해결 시간 초과…1234567891011121314151617181920212223242526272829function solution(k, room_number) {  var answer = [];  let used = new Array(k+1). fill(false);  function searchRoom(idx) {    if(idx === used. length){      return;    }    if(!used[idx]) {      used[idx] = true;      answer. push(idx);    } else {      var isNext = used. indexOf(false,idx+1)      if(isNext&gt;0){        used[isNext] = true;        answer. push(isNext);      }      else {        return;      }    }    return;  }    room_number. forEach( i =&gt; {    searchRoom(i);  })  return answer;} 재귀를 이용, 찾을때 만 1을 더해주는 것이 아닌 찾지 못할때도 1을 더해준다. 속도와 공간활용에서 향상되긴하는데, 이것밖에 생각 못했나. . 라고 생각이 드는 답안. 12345678910111213141516171819202122232425function solution(k, room_number) {  var answer = [];  let used = new Array(k+1). fill(-1);  function searchRoom(idx) {    debugger;    if(idx === used. length){      return;    }    if(used[idx]&lt;0) {      used[idx] = idx+1;      answer. push(idx);    } else {      searchRoom(used[idx]);      used[idx]++;    }    return;  }    room_number. forEach( i =&gt; {    searchRoom(i);  })  return answer;} 해결 찾을 경우 : 처음 노드의 값이 찾은 노드 다음 위치저장   찾지 못할 경우 : 직전 노드의 값을 다음 노드가 가리키는 위치로 저장.  또한, 위치 저장값은 해시로 저장. 1234567891011121314151617181920212223242526272829function solution(k, room_number) {  var answer = [];  let testUsed = new Map();  function searchRoom(idx) {    if (!testUsed. has(idx)) {      testUsed. set(idx, idx + 1);      answer. push(idx);    } else {      var target = testUsed. get(idx);      while (target &lt;= k) {        if (!testUsed. has(target)) {          testUsed. set(target, target+1);          testUsed. set(idx, target+1);          answer. push(target);          return;        } else {          var nextTarget = testUsed. get(target);          testUsed. set(target, nextTarget+1);          target = nextTarget;        }      }    }  }  room_number. forEach( i =&gt; {    searchRoom(i);  })  return answer;}더 나은 문제풀이위의 해결 방법에서는 값에 따른 속도의 편차가 일정하지 않았다. 아래의 방법은 비교적 일정했다.  재귀로 이동하며 값을 찾아나갈 때, 재귀함수의 return 값이 위치 값을 줌으로써 확인했던 모든 노드의 값을 최종 찾은 값의 다음값으로 저장해준다. (이런 방법이!) 1234567891011121314const solution = (k, roomNumbers) =&gt; { const used = new Map(); return roomNumbers. map((number) =&gt; findRoom(number, used));};function findRoom(room, used) { if (used. get(room) == undefined) {  used. set(room, room + 1);  return room; } let next = findRoom(used. get(room), used); used. set(room, next + 1); return next;}"
    }, {
    "id": 80,
    "url": "/study_CODE_hash_2/",
    "title": "해시 : 완주하지 못한 선수",
    "body": "2020/06/22 - 문제 설명수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.  제한사항 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.  completion의 길이는 participant의 길이보다 1 작습니다.  참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.  참가자 중에는 동명이인이 있을 수 있습니다. 입출력 예 | participant | completion | return | | — | — | — | | [leo, kiki, eden] | [eden, kiki] | leo | | [marina, josipa, nikola, vinko, filipa] | [josipa, filipa, marina, nikola] | vinko | | [mislav, stanko, mislav, ana] | [stanko, ana, mislav] | mislav | 문제풀이해시를 이용해 풀수 있다.  각 data를 Key, data의 개수를 value로 HashMap을 만들어 중복 시 map의 값을 줄여나가며, 0 일경우 지운다.  Key들의 집합이 답이겠으나, 들어오지 못한 인원은 1명이라는 제한 조건으로 인해 단순히 key를 return 하면 된다. 해시를 사용하는 방법은 아래와 같이 2가지이다.  Map()을 이용한 방법.    객체를 사용한 방법   ```javascriptfunction solution(participant, completion) { var answer = ‘’; let comMap = new Map();participant. forEach( (i) =&gt; {  var value = comMap. get(i);  if((value == undefined)) {   comMap. set(i, 1);  } else {   value += 1;   comMap. set(i, value);  } }) completion. forEach( (i) =&gt; {  var value = comMap. get(i);  value -= 1;  if (value === 0 ) {   comMap. delete(i);  }  else {   comMap. set(i, value);  } }) for(let key of comMap. keys()) {  answer = key; } return answer;} 12345672. 객체를 사용하는 방법이다. ```javascriptfunction solution(participant, completion) { return participant. find( i =&gt; !completion[i]--, completion. map( i=&gt; completion[i] = (completion[i]|0)+1));}하나씩 이해해보자. 전체적인 매커니즘은 다음과 같다. completion에 배열의 값을 프로퍼티로 하는 key, 해당 멤버의 값을 value로 하여 값을 추가한다. participant의 값을 통해 completion 프로퍼티로 조사하여 value를 줄여가며, 해당 프로퍼티의 value의 값이 =&lt; 0 또는 undefine 값을 찾아내는 것이다.  arr. map()  map을 통해 completion의 배열 값으로 하는 프로퍼티를 생성하며, 해당 프로퍼티의 값을 0과 or 처리 함으로써 값의 존재유무를 판단한다. (없다면 undefined|0 ==&gt; 0, 있다면 숫자|0 ==&gt; 숫자 Wow!) arr. find(callback[, thisArg])  제한조건상 1개만이 return 값이기 때문에 find 사용. reduce로 대체 가능  callback 함수에 thisArg값으로 1번에서 만든 값을 넣어 줌으로써 하나씩 찾아보도록 한다.  정확환 순서는 (!completion[i]) 값을 찾고 해당값을 – 하고 넘겨준다. map과 객체리터럴이 꽤 강력함을 여기서 확인한다. 또 함수형 프로그래밍으로 매개변수만 받도록 하면 아래와 같다. 1var solution=(_,$)=&gt;_. find(_=&gt;!$[_]--,$. map(_=&gt;$[_]=($[_]|0)+1))!? "
    }, {
    "id": 81,
    "url": "/study_CODE_hash_1/",
    "title": "해시 : 소수 찾기",
    "body": "2020/06/21 - 문제 설명한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다. 각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요. 입출력 예 | n | result | | — | — | | “17” | 3 | | “011” | 2 | 문제풀이전체 순열 조합을 구하고, 그 중 primeNumber를 걸러낸다. 그 개수가 정답. 1234567891011121314151617181920212223242526272829303132333435363738function solution(numbers) {  const numberList = numbers. split('');  const findPrimeNumbers = (stringList, prevNumber) =&gt; {    const caliPrevNumber = prevNumber || '';    return stringList. reduce((list, value, idx) =&gt; {      if (isPrimeNumber(Number(caliPrevNumber + value))) {        list. push(Number(caliPrevNumber + value));      }      const nextList = [. . . stringList];      nextList. splice(idx, 1);      const result = findPrimeNumbers(      nextList,      caliPrevNumber + value,      );      list. push(. . . result);      return list;    }, []);  }  const answers = findPrimeNumbers(numberList);  return [. . . new Set(answers)]. length; //중복값 제거. }function isPrimeNumber(number) {  const notPrime = [0, 1];  if (notPrime. includes(number)) return false;  for (let i = 2; i * i &lt;= number; i++) {    if (number % i === 0) return false;  }  return true;}"
    }, {
    "id": 82,
    "url": "/study_CODE_Graph_1/",
    "title": "그래프 : 가장 먼 노드",
    "body": "2020/06/20 - 문제설명n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다. 노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로  주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요. 제한사항  - 노드의 개수 n은 2 이상 20,000 이하입니다.   - 간선은 양방향이며 총 1개 이상 50,000개 이하의 간선이 있습니다.   - vertex 배열 각 행 [a, b]는 a번 노드와 b번 노드 사이에 간선이 있다는 의미입니다.       Vertex   Edge   return         6   [[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]   3   풀이우선 V,E 를 그래프를 표현한다.  행렬과 리스트 둘다 가능하나, 여기선 리스트로 만든다. 1234567var v = 6;var edge = [[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]];const arr = Array(+1). fill(null). map(() =&gt; Array());for(let i of edge) {    arr[i[0]]. push(i[1]);    arr[i[1]]. push(i[0]);  }해당 그래프를 BFS 또는 DFS를 통해 순회를 할 수 있는데, 여기선 노드간 거리를 측정하므로 BFS를 이용한다. Queue를 이용해 순회를 하며 해당 거리를 추가로 입력해준다. 1234567891011121314151617const queue = [[1,0]]; //Node, Distanceconst dist = []; //Node 별 Distance 값 저장. function inputQueue(i, weight) { const arrLeng = arr[i]. length; for(let j=0; j&lt;arrLeng; j++) {  const num = arr[i]. shift();  queue. push([num, weight]);  for(let k=1; k&lt;=n; k++) {   const index = arr[k]. indexOf(num);  if(index != -1)    arr[k]. splice(index, 1);  } }}그렇게 되면 Max 거리를 알수 있게 되며, max거리를 가진 값의 개수만 return해주면 된다. 1234567891011121314151617181920212223inputQueue(1, 1); while(queue. length &gt; 0) {  const shifted = queue. shift();  if(dist[shifted[0]] == null || dist[shifted[0]]&gt;shifted[1])   dist[shifted[0]] = shifted[1];  inputQueue(shifted[0], dist[shifted[0]]+1); } let max = 0; let answer = 0; for(let i=1; i&lt;=n; i++) {   if(dist[i]&gt;max) {     max = dist[i];     answer = 1;   } else if(dist[i] == max) {     answer++;   } }  return answer;해결 Point: 그래프 표현으로 전환 -&gt; BFS 순회하며 거리측정 -&gt; Max 거리 count "
    }, {
    "id": 83,
    "url": "/study_CODE_Graph-BFS,DFS/",
    "title": "Graph [BFS, DFS]",
    "body": "2020/06/20 - Graph [DFS, BFS]자바 스크립트를 이용한 개념 구현 ## Graph 위와 같은 Graph를 구현해 보자.       Vertex   Edge         8   [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [5, 8], [6, 8], [7, 8]]    Vertex는 1부터 n까지 이며, Weight가 없는 경우1234567 var edge = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [5, 8], [6, 8], [7, 8]]; var v = 8; const arr = Array(v+1). fill(null). map(() =&gt; Array()); for(let i of edge) {  arr[i[0]]. push(i[1]);  arr[i[1]]. push(i[0]); } Vertex, Edge, Weight 전체 관리123456789101112131415class UndirectGraph { edge = {}; addVertex(vertex) {  this. edge[vertex] = {}; } addEdge(vertex1, vertex2, weight) {  this. edge[vertex1][vertex2] = weight;  this. edge[vertex2][vertex1] = weight; }}const graph = new UndirectGraph();graph. addVertex(1);graph. addVertex(2);graph. addEdge(1, 2, 5);그래프를 구현하였으니 이제 DFS와 BFS를 이용해 탐색을 해보자. ## DFS  노드를 설정한 방향대로 끝까지 간 뒤 가장 최근으로 backtacking을 진행하여 해당 방향 끝까지 보내며 전체 탐색을 하는 방법 재귀 호출 방법과 스택을 사용한 방법이 있다. 1→2→4→8→5→(8)→6→3→(6)→(8)→7→(8)→(4)→(2)→(1)  재귀1234567891011121314151617const graph = (arr, start) =&gt; {  let visited = new Array(arr. length). fill(false);  const recDFS = (idx) =&gt; {     visited[idx] = true;    console. log(idx +    );    arr[idx]. forEach( i =&gt; {      if(visited[i] == false) {        recDFS(i);      }    })        return;  }  return recDFS(start); // idx start 부터 시작}graph(arr,1); 스택12345678910111213141516171819202122232425262728293031323334353637383940414243444546const graph = (arr, start) =&gt; {    class Stack {    constructor() {     this. _arr = [];    }    push(item) {     this. _arr. push(item);    }    pop() {     return this. _arr. pop();    }    peek() {     return this. _arr[this. _arr. length - 1];    }  }  const stack = new Stack();  let visited = new Array(arr. length). fill(false);  const recDFS = (idx) =&gt; {     stack. push(idx);    let flag;    visited[idx] = true;    console. log(idx);    let value = stack. peek();    while(!(value === undefined)) {      flag = false;      for( i of arr[value]) {        if(visited[i] === false) {          stack. push(i);          console. log(i);          visited[i] = true;          flag = true;          break;        }      }      if(!flag) {        stack. pop();      }      value = stack. peek();    }    return;  }  return recDFS(start); // idx start 부터 시작}BFS:  한 노드에 연결된 노드를 전체 탐색한 뒤 설정한 방향대로 차례로 진행하며 전체를 탐색 하는 방법 큐를 사용한다. 1→(1)→2→3→(2)→4→5→(3)→6→7→(4)→8→(5)→(6)→(7)→(8) 1234567891011121314151617181920212223242526272829303132333435363738394041424344const graph = (arr, start) =&gt; {    class Queue {    constructor() {     this. _arr = [];    }    enqueue(item) {     this. _arr. push(item);    }    dequeue() {     return this. _arr. shift();    }    peek() {      return this. _arr[0];    }  }  const queue = new Queue();  let visited = new Array(arr. length). fill(false);  const recBFS = (idx) =&gt; {     queue. enqueue(idx);    let flag;    visited[idx] = true;    console. log(idx);    let value = queue. peek();    while(!(value === undefined)) {      flag = false;      for( i of arr[value]) {        if(visited[i] === false) {          queue. enqueue(i);          console. log(i);          visited[i] = true;          flag = true;        }      }      if(!flag) {        queue. dequeue();      }      value = queue. peek();    }    return;  }  return recBFS(start); // idx start 부터 시작}DFS, BFS의 컨셉을 이용해 문제를 해결해야 하는 것들이 있음을 인지하자. "
    }, {
    "id": 84,
    "url": "/study_CODE_design_1/",
    "title": "설계 : 기둥과 보 설치",
    "body": "2020/06/19 - category: 2020 KAKAO BLIND RECRUITMENT 문제 설명빙하가 깨지면서 스노우타운에 떠내려 온 죠르디는 인생 2막을 위해 주택 건축사업에 뛰어들기로 결심하였습니다. 죠르디는 기둥과 보를 이용하여 벽면 구조물을 자동으로 세우는 로봇을 개발할 계획인데, 그에 앞서 로봇의 동작을 시뮬레이션 할 수 있는 프로그램을 만들고 있습니다. 프로그램은 2차원 가상 벽면에 기둥과 보를 이용한 구조물을 설치할 수 있는데, 기둥과 보는 길이가 1인 선분으로 표현되며 다음과 같은 규칙을 가지고 있습니다. 기둥은 바닥 위에 있거나 보의 한쪽 끝 부분 위에 있거나, 또는 다른 기둥 위에 있어야 합니다. 보는 한쪽 끝 부분이 기둥 위에 있거나, 또는 양쪽 끝 부분이 다른 보와 동시에 연결되어 있어야 합니다. 단, 바닥은 벽면의 맨 아래 지면을 말합니다. 2차원 벽면은 n x n 크기 정사각 격자 형태이며, 각 격자는 1 x 1 크기입니다. 맨 처음 벽면은 비어있는 상태입니다. 기둥과 보는 격자선의 교차점에 걸치지 않고, 격자 칸의 각 변에 정확히 일치하도록 설치할 수 있습니다. 예를 들어, 다음 순서에 따라 구조물을 만들었습니다. (1, 0)에서 위쪽으로 기둥을 하나 설치 후, (1, 1)에서 오른쪽으로 보를 하나 만듭니다. (2, 1)에서 위쪽으로 기둥을 하나 설치 후, (2, 2)에서 오른쪽으로 보를 하나 만듭니다. (5, 0)에서 위쪽으로 기둥을 하나 설치 후, (5, 1)에서 위쪽으로 기둥을 하나 더 설치합니다. (4, 2)에서 오른쪽으로 보를 설치 후, (3, 2)에서 오른쪽으로 보를 설치합니다. 만약 (4, 2)에서 오른쪽으로 보를 먼저 설치하지 않고, (3, 2)에서 오른쪽으로 보를 설치하려 한다면 2번 규칙에 맞지 않으므로 설치가 되지 않습니다. 기둥과 보를 삭제하는 기능도 있는데 기둥과 보를 삭제한 후에 남은 기둥과 보들 또한 위 규칙을 만족해야 합니다. 만약, 작업을 수행한 결과가 조건을 만족하지 않는다면 해당 작업은 무시됩니다. 벽면의 크기 n, 기둥과 보를 설치하거나 삭제하는 작업이 순서대로 담긴 2차원 배열 build_frame이 매개변수로 주어질 때, 모든 명령어를 수행한 후 구조물의 상태를 return 하도록 solution 함수를 완성해주세요.  제한사항 n은 5 이상 100 이하인 자연수입니다.  build_frame의 세로(행) 길이는 1 이상 1,000 이하입니다.  build_frame의 가로(열) 길이는 4입니다.  build_frame의 원소는 [x, y, a, b]형태입니다.  x, y는 기둥, 보를 설치 또는 삭제할 교차점의 좌표이며, [가로 좌표, 세로 좌표] 형태입니다.  a는 설치 또는 삭제할 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다.  b는 구조물을 설치할 지, 혹은 삭제할 지를 나타내며 0은 삭제, 1은 설치를 나타냅니다.  벽면을 벗어나게 기둥, 보를 설치하는 경우는 없습니다.  바닥에 보를 설치 하는 경우는 없습니다.  구조물은 교차점 좌표를 기준으로 보는 오른쪽, 기둥은 위쪽 방향으로 설치 또는 삭제합니다.  구조물이 겹치도록 설치하는 경우와, 없는 구조물을 삭제하는 경우는 입력으로 주어지지 않습니다.  최종 구조물의 상태는 아래 규칙에 맞춰 return 해주세요.  return 하는 배열은 가로(열) 길이가 3인 2차원 배열로, 각 구조물의 좌표를 담고있어야 합니다.  return 하는 배열의 원소는 [x, y, a] 형식입니다.  x, y는 기둥, 보의 교차점 좌표이며, [가로 좌표, 세로 좌표] 형태입니다.  기둥, 보는 교차점 좌표를 기준으로 오른쪽, 또는 위쪽 방향으로 설치되어 있음을 나타냅니다.  a는 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다.  return 하는 배열은 x좌표 기준으로 오름차순 정렬하며, x좌표가 같을 경우 y좌표 기준으로 오름차순 정렬해주세요.    x, y좌표가 모두 같은 경우 기둥이 보보다 앞에 오면 됩니다.   입출력 예 | n | build_frame | result | | 5 | [[1,0,0,1],[1,1,1,1],[2,1,0,1],[2,2,1,1],[5,0,0,1],[5,1,0,1],[4,2,1,1],[3,2,1,1]] | [[1,0,0],[1,1,1],[2,1,0],[2,2,1],[3,2,1],[4,2,1],[5,0,0],[5,1,0]] | | 5 | [[0,0,0,1],[2,0,0,1],[4,0,0,1],[0,1,1,1],[1,1,1,1],[2,1,1,1],[3,1,1,1],[2,0,0,0],[1,1,1,0],[2,2,0,1]] | [[0,0,0],[0,1,1],[1,1,1],[2,1,1],[3,1,1],[4,0,0]] |문제풀이주어진 조건에 맞춰 설계를 할수 있느냐 문제이다. 이 문제는 생각보다 간단했는데, 정답률이 낮은 이유는 아마도 시간이 부족해서 일 것 이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129function solution(n, build_frame) { var build = []; //debugger; build_frame. forEach(i =&gt; {  if (i[3]) {   if (canBuild(i, build, n)) {     i. pop()    build. push(i);   }  } else {   if (canDelete(i, build, n)) {    i. pop();    var deleteBuild = build. filter(_ =&gt; !(_[0] === i[0] &amp;&amp; _[1] === i[1] &amp;&amp; _[2] === i[2]));    build = deleteBuild;   }  } }) var answer = build. sort( (a,b) =&gt; {  if(a[0] === b[0]) {    if(a[1] === b[1]) {      return a[2]-b[2];    } else {      return a[1]-b[1];    }  } else {    return a[0] - b[0];  }}); if(answer == 0) {  return [[]]; } else {  return answer; }}function canBuild( data, build, n ) { if(data[2]) {  if(data[0]&lt;0 || data[0]&gt;=n) {   return false;  }  if(data[1]&lt;=0 || data[1]&gt;n) {   return false;  }  return checkBeam(data, build); } else {  if(data[0]&lt;0 || data[0]&gt;n) {   return false;  }  if(data[1]&lt;0 || data[1]&gt;=n) {   return false;  }  return checkPillar(data, build); }}function checkPillar (data, build) { if(data[1] === 0){  return true; } else if(build. filter( i =&gt; i[0] === data[0] &amp;&amp; i[1] === data[1]-1 &amp;&amp; i[2] === 0 ) != 0){  return true; } else if(build. filter( i =&gt; (i[0] === data[0] || i[0] === data[0]-1) &amp;&amp; i[1] === data[1] &amp;&amp; i[2] === 1 ) != 0){  return true; }  else {  return false; }}function checkBeam (data, build) { if(build. filter( i =&gt; (i[0] === data[0] || i[0] === data[0]+1) &amp;&amp; i[1] === data[1]-1 &amp;&amp; i[2] === 0 ) != 0) {  return true; } else if( build. filter( i =&gt; i[0] === data[0]-1 &amp;&amp; i[1] === data[1] &amp;&amp; i[2] === 1) != 0 &amp;&amp;  build. filter( j =&gt; j[0] === data[0]+1 &amp;&amp; j[1] === data[1] &amp;&amp; j[2] === 1 ) != 0) {  return true; }  else {  return false; }}function canDelete( data, build, n) { var testBuild = build. filter( i =&gt; !(i[0] === data[0] &amp;&amp; i[1] === data[1] &amp;&amp; i[2] === data[2])); var testData = []; var isData = generateData(data, n); // 삭제하고자 할때, 영향을 받는 값들은 build안에 있는 값들이니 다시 filter! isData. forEach( j =&gt; {  var item = testBuild. filter( k =&gt; k[0] === j[0] &amp;&amp; k[1] === j[1] &amp;&amp; k[2] === j[2] );  if(item != 0) {   testData. push(item[0]);  } }) for(let j=0, len = testData. length; j&lt;len; j++) {  if(testData[j][2]) {   if(!checkBeam(testData[j], testBuild)) {    return false;   }  } else {   if(!checkPillar(testData[j], testBuild)) {    return false;   }  } } return true;}function generateData(data, n) { var result = []; if(data[2]) { //지우고자 하는 값이 보  result. push([data[0]-1,data[1], 1, 1]); //보  result. push([data[0]+1,data[1], 1, 1]); //보  result. push([data[0],data[1], 0, 1]); //기둥  result. push([data[0]+1,data[1], 0, 1]); //기둥 } else { //지우고자 하는 값이 기둥  result. push([data[0],data[1]+1, 1, 1]); //보  result. push([data[0]-1,data[1]+1, 1, 1]); //보  result. push([data[0],data[1]+1, 0, 1]); //기둥 } return result. filter(i =&gt; 0&lt;=i[0] &amp;&amp; i[0]&lt;=n &amp;&amp; 0&lt;=i[1] &amp;&amp; i[1] &lt;= n); //여기서 마지막 값 을 n이 아닌 다른 숫자를 입력해서 테스트 코드에선 맞았는데, 제출한 결과 맞지 않았다. 이런 실수는 다시는 없어야 한다. !!}"
    }, {
    "id": 85,
    "url": "/study_CODE_combination_1/",
    "title": "Combination : 불량 사용자",
    "body": "2020/06/18 - category: 2019 카카오 개발자 겨울 인턴십 문제 설명개발팀 내에서 이벤트 개발을 담당하고 있는 무지는 최근 진행된 카카오이모티콘 이벤트에 비정상적인 방법으로 당첨을 시도한 응모자들을 발견하였습니다. 이런 응모자들을 따로 모아 불량 사용자라는 이름으로 목록을 만들어서 당첨 처리 시 제외하도록 이벤트 당첨자 담당자인 프로도 에게 전달하려고 합니다. 이 때 개인정보 보호을 위해 사용자 아이디 중 일부 문자를 ‘’ 문자로 가려서 전달했습니다. 가리고자 하는 문자 하나에 ‘’ 문자 하나를 사용하였고 아이디 당 최소 하나 이상의 ‘*’ 문자를 사용하였습니다. 무지와 프로도는 불량 사용자 목록에 매핑된 응모자 아이디를 제재 아이디 라고 부르기로 하였습니다. 예를 들어, 이벤트에 응모한 전체 사용자 아이디 목록이 다음과 같다면 응모자 아이디frodofradicrodoabc123frodoc 다음과 같이 불량 사용자 아이디 목록이 전달된 경우, 불량 사용자frdabc1** 불량 사용자에 매핑되어 당첨에서 제외되어야 야 할 제재 아이디 목록은 다음과 같이 두 가지 경우가 있을 수 있습니다. 제재 아이디frodoabc123 제재 아이디fradiabc123 이벤트 응모자 아이디 목록이 담긴 배열 user_id와 불량 사용자 아이디 목록이 담긴 배열 banned_id가 매개변수로 주어질 때, 당첨에서 제외되어야 할 제재 아이디 목록은 몇가지 경우의 수가 가능한 지 return 하도록 solution 함수를 완성해주세요.  제한사항     user_id 배열의 크기는 1 이상 8 이하입니다.    user_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다.    응모한 사용자 아이디들은 서로 중복되지 않습니다.    응모한 사용자 아이디는 알파벳 소문자와 숫자로만으로 구성되어 있습니다.    banned_id 배열의 크기는 1 이상 user_id 배열의 크기 이하입니다.    banned_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다.    불량 사용자 아이디는 알파벳 소문자와 숫자, 가리기 위한 문자 ‘*’ 로만 이루어져 있습니다.    불량 사용자 아이디는 ‘*’ 문자를 하나 이상 포함하고 있습니다.    불량 사용자 아이디 하나는 응모자 아이디 중 하나에 해당하고 같은 응모자 아이디가 중복해서 제재 아이디 목록에 들어가는 경우는 없습니다.    제재 아이디 목록들을 구했을 때 아이디들이 나열된 순서와 관계없이 아이디 목록의 내용이 동일하다면 같은 것으로 처리하여 하나로 세면 됩니다.    123456var user_id = [ frodo ,  fradi ,  crodo ,  abc123 ,  frodoc ];//var banned_id = [ fr*d* ,  abc1** ]; // result : 2var banned_id = [ *rodo ,  *rodo ,  ****** ]; // result : 2//var banned_id = [ fr*d* ,  *rodo ,  ****** ,  ****** ]; //result : 3문제풀이종속적인 두 배열간 조합문제이다. 우선 ban id에 존재하거나, 사용하지 않았다면 picked 배열에 집어넣어 다음 find를 구성하도록 하고 다시 빼낸다음에 나머지 for문을 돌게 하는 방식 banned_id로 인해 종속적인 배열들이 생성될수 있는데,  하나의 배열로 조합을 구성하면서 banned_id 조건을 추가해 주는 방식으로 해결했다. 또한 문자열 배열이지만 간단한 계산을 위해 문자의 index를 값으로 하는 배열로 구성해야 한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function solution(user_id, banned_id) {  var answer = 0;  const picked = [];  let len = banned_id. length;  const banSets = new Set();  const usedFlag = new Array(user_id. length). fill(false);  function find(picked, banId) {    if(picked. length === len) {      const usedId = [];      picked. forEach( item =&gt; {        usedId. push(item);      })      banSets. add(usedId. sort(). join(''));      return;    } else {      for(let i=0; i&lt;user_id. length; i++) {        if(!usedFlag[i] &amp;&amp; banCompare(user_id[i], banned_id[banId])) {          picked. push(i);          usedFlag[i] = true;          find(picked, banId+1);          //↓↓↓ for문이 돌기 때문에 안뽑은 것을 돌게한다.           picked. pop();          usedFlag[i] = false;        }      }    }  }  find(picked, 0);  return banSets. size;}function banCompare(id, ban) {  var check = (userId, banId) =&gt; {    return userId. reduce((check, cur, idx) =&gt; {      if (cur === banId[idx]) {        check += cur;      } else {        check += '*';      }      return check;    }, '');  }  return check(id. split(''), ban) === ban;}다른 풀이위에선 중속적인 배열 생성 조건을 유지한 채 풀었다면,  배열을 만들어 준 뒤, 조합 문제를 해결하는 방법이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243var u_id = [ frodo ,  fradi ,  crodo ,  abc123 ,  frodoc ];//var b_id = [ fr*d* ,  abc1** ];var b_id = [ *rodo ,  *rodo ,  ****** ];//var b_id = [ fr*d* ,  *rodo ,  ****** ,  ****** ];var test = solution(u_id, b_id);function solution(user_id, banned_id) {  const candidates = [];  const answer = {};  banned_id. forEach(ban =&gt; {    const candidate = [];    user_id. forEach((id, i) =&gt; {      if (comp(ban, id)) candidate. push(i);    });    candidates. push(candidate);  });  function f(i = 0, selected = []) {    if (!candidates[i]) {      selected. sort();      answer[selected. join('')] = true;      return;    }    candidates[i]. filter(e =&gt; !selected. includes(e)). forEach(e =&gt; {      f(i + 1, selected. concat([e]));    });  }    f();  debugger;  return Object. keys(answer). length;}function comp(ban, id) {  if (id. length !== ban. length) return false;  for (let i = 0; i &lt; ban. length; i++) {    if (ban[i] === '*') continue;    if (ban[i] !== id[i]) return false;  }  return true;}"
    }, {
    "id": 86,
    "url": "/study_CODE_bruteForce_4/",
    "title": "완전탐색 : 괄호 변환",
    "body": "2020/06/18 - category: 2020 KAKAO BLIND RECRUITMENT 문제 설명고고학자인 튜브는 고대 유적지에서 보물과 유적이 가득할 것으로 추정되는 비밀의 문을 발견하였습니다. 그런데 문을 열려고 살펴보니 특이한 형태의 자물쇠로 잠겨 있었고 문 앞에는 특이한 형태의 열쇠와 함께 자물쇠를 푸는 방법에 대해 다음과 같이 설명해 주는 종이가 발견되었습니다. 잠겨있는 자물쇠는 격자 한 칸의 크기가 1 x 1인 N x N 크기의 정사각 격자 형태이고 특이한 모양의 열쇠는 M x M 크기인 정사각 격자 형태로 되어 있습니다. 자물쇠에는 홈이 파여 있고 열쇠 또한 홈과 돌기 부분이 있습니다. 열쇠는 회전과 이동이 가능하며 열쇠의 돌기 부분을 자물쇠의 홈 부분에 딱 맞게 채우면 자물쇠가 열리게 되는 구조입니다. 자물쇠 영역을 벗어난 부분에 있는 열쇠의 홈과 돌기는 자물쇠를 여는 데 영향을 주지 않지만, 자물쇠 영역 내에서는 열쇠의 돌기 부분과 자물쇠의 홈 부분이 정확히 일치해야 하며 열쇠의 돌기와 자물쇠의 돌기가 만나서는 안됩니다. 또한 자물쇠의 모든 홈을 채워 비어있는 곳이 없어야 자물쇠를 열 수 있습니다. 열쇠를 나타내는 2차원 배열 key와 자물쇠를 나타내는 2차원 배열 lock이 매개변수로 주어질 때, 열쇠로 자물쇠를 열수 있으면 true를, 열 수 없으면 false를 return 하도록 solution 함수를 완성해주세요.  제한사항     key는 M x M(3 ≤ M ≤ 20, M은 자연수)크기 2차원 배열입니다.    lock은 N x N(3 ≤ N ≤ 20, N은 자연수)크기 2차원 배열입니다.    M은 항상 N 이하입니다.    key와 lock의 원소는 0 또는 1로 이루어져 있습니다.    0은 홈 부분, 1은 돌기 부분을 나타냅니다.     입출력 예 | key | lock | result | | [[0, 0, 0], [1, 0, 0], [0, 1, 1]] | [[1, 1, 1], [1, 1, 0], [1, 0, 1]] | true |문제풀이문제는 배열을 이용한 작업을 할수 있느냐는 문제이다. 보통 이런 문제는 완전 탐색으로 자주 나오는 것 같다. 배열을 잘 사용할수 있는지 확인하는 차원에서 전체를 검색하도록 말이다.  고민하기 까지 상당한 시간이 걸렸는데, 자바스크립트는 각 값이 연결되어 있어서, 자바와는 다르게 독립적으로 값을 변경하면서 다룰수가 없었다. 그래서 객체를 이용했다.  key를 나타내는 객체와 lock에서 비어있는 곳을 나타내는 객체를 만든 뒤, key의 움직임에 따라 lock과 일치할 경우 해결되도록 구현하였다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102function solution(key, lock) {  const keyLen = key. length;  const lockLen = lock. length;  let lockPosition = makePosition(lock, 0); //처음엔 lock은 그냥 배열로 해결하려고 했는데, 배열 값을 따로 받아서 바꾸려니 값이 이어져서 바뀌어 버려서 그냥 이것 또한 객체로 만들었다.   let rotatedKey = rotation(key);  let rotatedKeyPosition;  for(let i=0; i&lt;4; i++) { // 마지막으로 헤멘 포인트, 한번 돌려주면 끝나는게 아니라 네번 모두 돌려줘야 한다. 생각해 보면 당연하다.     rotatedKey = rotation(rotatedKey);    rotatedKeyPosition = makePosition(rotatedKey, 1);        if(moveMatchKey(rotatedKeyPosition, lockPosition, keyLen, lockLen)) {      return true;    }  }  return false;}function moveMatchKey(keyPosition, lockPosition, keyLen, lockLen) { //position으로 받아오니 key의 size와 lock의 size가 필요해졌다.   let checkCount = lockPosition. length;  let count;  for (let i = -keyLen + 1; i &lt; lockLen; i++) { //움직일수 있는 거리를 설정함. (key size)    for (let j = -keyLen + 1; j &lt; lockLen; j++) {      count = 0;      var caliPositionSet = [];      keyPosition. forEach(k =&gt; {        var position = {};        var caliPositionX = k. x + i;        var caliPositionY = k. y + j;        if (validation(caliPositionX, lockLen) &amp;&amp; validation(caliPositionY, lockLen)) { //lockSize 안에 들어와야 하므로 lockSize가 필요          position. x = caliPositionX;          position. y = caliPositionY;          caliPositionSet. push(position);          count++;        }      })      if (checkCount === count) {        if(checkOkay(caliPositionSet, lockPosition)) {          return true;        }      }    }  }  return false;}function validation(point, pivotSize) {  if(point&lt;0 || point&gt;=pivotSize){    return false;  }  if(point&gt;=pivotSize){    return false;  }  return true;} function checkOkay(moveKey, lock) {  var len = lock. length;  for (let i = 0; i &lt; len; i++) {    if(moveKey[i]. x !== lock[i]. x || moveKey[i]. y !== lock[i]. y) { //완벽히 같아야 인정      return false;    }   }  return true;}function rotation(key) {  if(key. length === 1) {    return key;  }  let result = [];  for(let i=key. length-1; i&gt;=0; i--) {    result = key[i]. map( (_, $) =&gt; [. . . (result[$] || []), key[i][$]]); //잘쓰이는 rotation  }  return result; }function makePosition(item, keyOrLock) {  var positionSet = [];  if(item. length ===1) {    var position = {};    position. x =0;    position. y =0;    positionSet. push(position);    return positionSet;  }  item. forEach( (i, rowIdx) =&gt; {    i. forEach( (j, colIdx) =&gt; {      var position = {};      if(j===keyOrLock) {        position. x =rowIdx;        position. y =colIdx;        positionSet. push(position);      }    })  })  return positionSet;}"
    }, {
    "id": 87,
    "url": "/study_CODE_bruteForce_3/",
    "title": "완전탐색 : 문자열 압축",
    "body": "2020/06/17 - category: 2020 KAKAO BLIND RECRUITMENT 문제 설명데이터 처리 전문가가 되고 싶은 어피치는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다. 간단한 예로 aabbaccc의 경우 2a2ba3c(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, abcabcdede와 같은 문자열은 전혀 압축되지 않습니다. 어피치는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다. 예를 들어, ababcdcdababcdcd의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 2ab2cd2ab2cd로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 2ababcdcd로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다. 다른 예로, abcabcdede와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 abcabc2de가 되지만, 3개 단위로 자른다면 2abcdede가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다. 압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요.  제한사항 s의 길이는 1 이상 1,000 이하입니다.    s는 알파벳 소문자로만 이루어져 있습니다.   입출력 예 | s | result | | “aabbaccc” | 7 | | “ababcdcdababcdcd” | 9 | | “abcabcdede” | 8 | | “abcabcabcabcdededededede” | 14 | | “xababcdcdababcdcd” | 17 |문제풀이문자열을 비교한 뒤 압축 여부를 판단하고, 가능 하다면 압축 뒤 결과 글자를 비교하여 가장 작은 값을 return 하면 된다. 압축 여부를 판단하는 것이 중요한데, 압축은 모두 동일하게 적용되어야 하며, 제일 앞에서 부터 차례로 적용된다.  즉, 문자열을 일정한 기준으로 자르고, 앞문자와 뒷문자를 비교하여 같으면 압축을 할수 있다는 의미이다. 압축은 문자열의 1/2부터 가능하며, 모든 값을 해 본 뒤 가장 작은 값을 구하는 방법으로 진행하였다. 정답률 25. 9%가 level 2 라니. . 이상하다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function solution(s) {  let answer = 0;  let strLen = s. length; //여러번 쓰이기 때문에 글자수 길이를 따로 저장해준다.   if(strLen == 1) { //중복 길이를 제외    return 1;  }  for (let i = 1, len = parseInt(strLen / 2); i &lt;= len; i++) {     let zipSet = makeZip(s, i);    let restCharNum = strLen - zipSet. reduce((num, cur) =&gt; {      num += cur * i;      return num;    }, 0);    let zipCharNum = restCharNum + zipSet. map(i =&gt; i + ''). reduce((num, cur) =&gt; {      num += cur. length + i; //여기서 만일 압축숫자가 단위수가 증가하면 그만큼 글자수도 증가한다는것을 놓쳐서 꽤 많애 헤멨다. 단순한걸 놓치면 답을 찾기가 어렵다.       return num;    }, 0)    if (answer === 0) {      answer = zipCharNum;    } else if (answer &gt; zipCharNum) {      answer = zipCharNum;    }  }  return answer;}function makeZip(str, sliceNum) {  let len = Math. ceil(str. length / sliceNum);  let start = 0;  let target;  let prevTarget = -1;  let strCount = 0;  let strFlag = []; //처음엔 맵으로 저장을 했는데, 규칙상 바로 오지않으면 압축이 되지 않는다는 것을 이해하지 못했다. 처음 헤멘 포인트.   let flag = false;  let sliceStr = str;  while (start &lt; len) {    prevTarget = target;    target = sliceStr. substring(0, sliceNum);    if (target. length &lt; sliceNum) {      break;    }    if (prevTarget === target) {      if (flag) {        strFlag. push(2)        strCount++;        flag = false;      } else {        strFlag[strCount - 1]++;      }    } else {      flag = true;    }    sliceStr = sliceStr. slice(sliceNum);    start++;  }  return strFlag;}"
    }, {
    "id": 88,
    "url": "/study_CODE_bruteForce_2/",
    "title": "완전탐색 : 소수 찾기",
    "body": "2020/06/16 - 문제 설명한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다. 각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.  제한 조건     numbers는 길이 1 이상 7 이하인 문자열입니다.    numbers는 0~9까지 숫자만으로 이루어져 있습니다.    013은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다.    입출력 예 | participant | return | | “17” | 3 | | “011” | 2 | 문제풀이완전히 Combination 문제이다. "
    }, {
    "id": 89,
    "url": "/study_CODE_bruteForce_1/",
    "title": "완전탐색 : 모의고사",
    "body": "2020/06/16 - 문제 설명수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, … 2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, … 3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, … 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.  제한 조건     시험은 최대 10,000 문제로 구성되어있습니다.    문제의 정답은 1, 2, 3, 4, 5중 하나입니다.    가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.    입출력 예 | participant | return | | [1,2,3,4,5] | [1] | | [1,3,2,4,2] | [1,2,3] | 문제풀이단순하다. 순번을 만들어 내고, 해당 순번에 맞는 값이 답과 동일한지 판단하는 것.  순번을 어떻게 만들어 내느냐가 관건. 내가 해결한 방법은 규칙성을 찾고, 규칙에 맞게끔 순번을 만들어 냈다.  2번 수포자의 경우 홀수번 2 고정에 짝수번 1,3,4,5 규칙 3번 수포자의 경우 순번을 2번씩 적용 1234567891011121314151617let idx1, idx2=-1, idx3=-1;let i=0, len=answers. length;while(i&lt;len) {  idx1 = i%5;  if(!(i%2)){    var tmpIdx2 = (idx2+1)%5;    if( tmpIdx2 === 1 ){      idx2 = tmpIdx2+1;    }    else {      idx2 = tmpIdx2;    }    idx3 = (idx3+1)%5;  }   i++;}이 순번에 따라 값을 비교하면 나온다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748let sample1 = [1, 2, 3, 4, 5];let sample2 = [3, 1, 2, 4, 5];let count=[0, 0, 0];let idx2=-1, idx3=-1;let i=0, len=answers. length;while(i&lt;len) {  idx1 = i%5;  if(!(i%2)){    var tmpIdx2 = (idx2+1)%5;    if( tmpIdx2 === 1 ){      idx2 = tmpIdx2+1;    }    else {      idx2 = tmpIdx2;    }    idx3 = (idx3+1)%5;    if(answers[i] === 2) {      count[1]++;    }  } else {    if(answers[i] === sample1[idx2]) {      count[1]++;    }  }  if(answers[i] === sample1[idx1]) {    count[0]++;  }  if(answers[i] === sample2[idx3]) {    count[2]++;  }  i++;}var max=0;count. forEach( i=&gt; {  if(max &lt;= i) {    max = i;  }});var result = count. reduce( (acc, cur, idx) =&gt; {  if(cur === max) {    acc. push(idx+1)  }  return acc}, []);잘 살펴보면 3번 수포자의 idx는 1, 1, 2, 2, 3, 3, 4, 4, 5, 5 … 의 순서이고, sample에 매칭이 되어야 비로소 수포자의 순번이 동일하게 된다. (3, 3, 1, 1, 2, 2, 4, 4, 5, 5) 이는 직관적이지 않다. 찾아보니 직관적으로 풀어낸 답이 존재 하다. 1234567891011let a1 = [1, 2, 3, 4, 5];let a2 = [2, 1, 2, 3, 2, 4, 2, 5];let a3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5];let lenA1 = a1. length;let lenA2 = a2. length;let lenA3 = a3. length;let a1c = answers. filter( (v,idx) =&gt; v === a1[idx%lenA1]). length;let a2c = answers. filter( (v,idx) =&gt; v === a2[idx%lenA2]). length;let a3c = answers. filter( (v,idx) =&gt; v === a3[idx%lenA3]). length;filter를 통해 주어진 배열에서 조건에 맞는 값을 뺴낸다. 그러면 a1c, a2c, a3c 은 length로 인해 답을 Count 하게 되며 해당 값의 max를 구해 max와 값이 같으면 순서대로 답에 push 해주면 된다. 12345678910111213141516171819202122function solution(answers) { var answer = []; var a1 = [1, 2, 3, 4, 5]; var a2 = [2, 1, 2, 3, 2, 4, 2, 5] var a3 = [ 3, 3, 1, 1, 2, 2, 4, 4, 5, 5]; let lenA1 = a1. length; let lenA2 = a2. length; let lenA3 = a3. length; var a1c = answers. filter((a,i)=&gt; a === a1[i%lenA1]). length; var a2c = answers. filter((a,i)=&gt; a === a2[i%lenA2]). length; var a3c = answers. filter((a,i)=&gt; a === a3[i%lenA3]). length; var max = Math. max(a1c,a2c,a3c); if (a1c === max) {answer. push(1)}; if (a2c === max) {answer. push(2)}; if (a3c === max) {answer. push(3)}; return answer;}상당히 직관적이다. 이렇게 문제해결하자. "
    }, {
    "id": 90,
    "url": "/study_CODE_binarySearch_3/",
    "title": "이분탐색 : 가사 검색",
    "body": "2020/06/16 - category: 2020 KAKAO BLIND RECRUITMENT 문제 설명친구들로부터 천재 프로그래머로 불리는 프로도는 음악을 하는 친구로부터 자신이 좋아하는 노래 가사에 사용된 단어들 중에 특정 키워드가 몇 개 포함되어 있는지 궁금하니 프로그램으로 개발해 달라는 제안을 받았습니다. 그 제안 사항 중, 키워드는 와일드카드 문자중 하나인 ‘?’가 포함된 패턴 형태의 문자열을 뜻합니다. 와일드카드 문자인 ‘?’는 글자 하나를 의미하며, 어떤 문자에도 매치된다고 가정합니다. 예를 들어 “fro??”는 “frodo”, “front”, “frost” 등에 매치되지만 “frame”, “frozen”에는 매치되지 않습니다. 가사에 사용된 모든 단어들이 담긴 배열 words와 찾고자 하는 키워드가 담긴 배열 queries가 주어질 때, 각 키워드 별로 매치된 단어가 몇 개인지 순서대로 배열에 담아 반환하도록 solution 함수를 완성해 주세요.    가사 단어 제한사항 words의 길이(가사 단어의 개수)는 2 이상 100,000 이하입니다. 각 가사 단어의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다. 전체 가사 단어 길이의 합은 2 이상 1,000,000 이하입니다. 가사에 동일 단어가 여러 번 나올 경우 중복을 제거하고 words에는 하나로만 제공됩니다. 각 가사 단어는 오직 알파벳 소문자로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다.     검색 키워드 제한사항 queries의 길이(검색 키워드 개수)는 2 이상 100,000 이하입니다. 각 검색 키워드의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다. 전체 검색 키워드 길이의 합은 2 이상 1,000,000 이하입니다. 검색 키워드는 중복될 수도 있습니다. 각 검색 키워드는 오직 알파벳 소문자와 와일드카드 문자인 ‘?’ 로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다. 검색 키워드는 와일드카드 문자인 ‘?’가 하나 이상 포함돼 있으며, ‘?’는 각 검색 키워드의 접두사 아니면 접미사 중 하나로만 주어집니다. 예를 들어 “??odo”, “fro??”, “?????”는 가능한 키워드입니다. 반면에 “frodo”(‘?’가 없음), “fr?do”(‘?’가 중간에 있음), “?ro??”(‘?’가 양쪽에 있음)는 불가능한 키워드입니다.     입출력 예| words | queries | result || [“frodo”, “front”, “frost”, “frozen”, “frame”, “kakao”] | [“fro??”, “????o”, “fr???”, “fro???”, “pro?”] | [3, 2, 4, 1, 0] |  문제풀이정답률 0. 8%에 빛나는 극악의 난이도 문제이다. 정확성 정답률은 34%이나 배점이 100점중 25점인게 함정. 이진탐색을 타이틀로 걸었지만, 사실 이것보다 더 효율적으로 풀 수 있는 방법이 있다. 아래에서 설명하고겠다.  극악의 난이도를 자랑 하는 이유는 단순히 이진 탐색에서 답을 찾는 것아 아닌 upper_bound와 lower_bound를 찾아야 하는 것이었다.  그러나 그것 만으로 부족하다며 이진 탐색 compare 조건이 2중으로 만들어야 해결이 가능했다. (물론 해설에서는 앞서 언급한 이것보다 더 좋은 방법을 해설하였지만. . )  첫 시도 단순 선형 풀이 정확도 100%, 속도 40%  일일히 찾는 방법. 아마도 대부분 이렇게 풀엇을 것으로 추측한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687function solution(words, queries) {  var result = new Array(queries. length). fill(0);  var querySet = makeQuerySet(queries);  querySet. forEach((i, idx) =&gt; {    words. forEach(j =&gt; {      if (compare(j, i)) {        result[idx]++;      }    })  })  return result;}function makeQuerySet(queries) {  var querySet = [];    queries. forEach( i =&gt; {    var queryInfo = {};    var len = i. length;    queryInfo. length = len;    if(i[0] === '?'){      queryInfo. frontFlag = true;      var num = markNum(i, true);      queryInfo. mark = num;      queryInfo. str = i. slice(num)    } else {      queryInfo. frontFlag = false;      var num = markNum(i, false);      queryInfo. mark = num;      queryInfo. str = i. substring(0,len-num);    }    querySet. push(queryInfo);  })  return querySet;}function markNum(query, frontFlag) {  let count = 1;  var check = query. split('');  if(frontFlag) {    for(let i=1,len=check. length; i&lt;len; i++) {      if(check[i] === '?') {        count++;      } else {        return count;      }    }  } else {    for(let j=check. length-2; j&gt;=0; j--) {      if(check[j] === '?') {        count++;      } else {        return count;      }    }  }}function compare(oneWord, oneQuery) {  if(oneWord. length !== oneQuery. length) {    return false;  }  if(oneQuery. frontFlag) {    if(frontCompare(oneWord, oneQuery)) {      return true;    } else {      return false;    }  } else {    if(backCompare(oneWord, oneQuery)) {      return true;    } else {      return false;    }  }}function frontCompare(oneWord, oneQuery) {  return oneQuery. str === oneWord. slice(oneQuery. mark);}function backCompare(oneWord, oneQuery) {  return oneQuery. str === oneWord. substring(0,oneWord. length-oneQuery. mark);}   다음 여럿 시도 : querySet을 개수별로 다시 묶은 다음, 해당 범위 내에서 다시 찾기. 이진탐색으로 특정 값을 찾은 뒤 양옆으로 앞글자가 바뀔때까지 탐색 재개.     문자열을 우선 길이 순으로 정렬한 뒤, 길이가 같다면 문자순으로 정렬을 하고, 해당 기준을 바탕으로 upper_bound 와 lower_bound를 찾는다. (단순한 bound와 다르니 찾아보자. )  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115function solution(words, queries) { 'use strict'; var answer = []; var reverseWords = []; let wordStart = 0; let wordEnd = words. length-1; words. forEach(i =&gt; reverseWords. push(i. split(  ). reverse(). join(  ))); let sortedWords = words. sort((a, b) =&gt; {  if (a. length &lt; b. length) {   return a. length - b. length  } else if (a. length === b. length) {   return (a &gt; b) - (a &lt; b);  } else {   return a. length - b. length;  } });  let reverseSortedWords = reverseWords. sort((a, b) =&gt; {  if (a. length &lt; b. length) {   return a. length - b. length  } else if (a. length === b. length) {   return (a &gt; b) - (a &lt; b);  } else {   return a. length - b. length;  } });  let len; let left; let right; queries. forEach(_ =&gt; {  len = _. length;  if (_[0] === '?') {   var pivot = _. split(  ). reverse(). join(  );   var leftPivot = pivot. split(  ). map((_, idx) =&gt; _ === '?' ? 'a' : _). join('');   left = lowerBound(reverseSortedWords, wordStart, wordEnd, leftPivot);   var rightPivot = pivot. split(  ). map((_, idx) =&gt; _ === '?' ? 'z' : _). join('');   right = upperBound(reverseSortedWords, wordStart, wordEnd, rightPivot);  } else {   //debugger;   var leftPivot = _. split(  ). map((_, idx) =&gt; _ === '?' ? 'a' : _). join('');   left = lowerBound(sortedWords, wordStart, wordEnd, leftPivot);   var rightPivot = _. split(  ). map((_, idx) =&gt; _ === '?' ? 'z' : _). join('');   right = upperBound(sortedWords, wordStart, wordEnd, rightPivot);  }  answer. push(right - left); }) return answer;}// [ frame ,  frodo ,  front ,  frost ,  kakao ,  frozen ] 에서 [ fro??? ] 를 lower는 5를 upper는 6을 찾는게 핵심이다. function lowerBound(list, start, end, key) { let it; let step; let advance; let first = start; let count = end - start + 1; while (count &gt; 0){  step = Math. floor(count/2);  advance = first+step;  it = list[advance];  if(compare(it,key) &amp;&amp; it !== undefined) {   first = ++advance;   count -= step+1;  } else {   count = step;  } } return first;}function upperBound(list, start, end, key) { let it; let step; let advance; let first = start; let count = end - start + 1; //debugger; while (count &gt; 0){  step = Math. floor(count/2);  advance = first+step;  it = list[advance];  if(!compare(key, it) &amp;&amp; it !== undefined) {   first = ++advance;   count -= step+1;  } else {   count = step;  } } return first;}function compare(a, b) { if(a. length&lt;b. length) {  return true; } else if(a. length === b. length) {  if(a &lt; b) {   return true;  } } return false;}# 트라이 구조 트라이 구조는 다음에 공부하자! "
    }, {
    "id": 91,
    "url": "/study_CODE_binarySearchTree(BST)/",
    "title": "자바스크립트 : 이진탐색트리(BST)",
    "body": "2020/06/16 - BST를 만들어 보자. 우선 Data를 담을 노드. 12345678910 class Node{  constructor(data, left, right){   this. data = data;   this. left = left;   this. right = right;  }  show(){   return this. data;  } }BST, Right Node가 존재해야 Successor를 찾는 것으로 들어가므로 굳이 Successor를 사용해서 중복 제한을 하는 것 보다 Minimum 값을 사용하는게 좋아 보인다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105 class BST{  constructor(){   this. root = null;  }   getRoot(){   return this. root;  }   insert(data){   let n = new Node(data, null, null);   if(this. root == null){    this. root = n;   }   else{    let current = this. root;    let parent;    while(true){     parent = current;     if(data &lt; current. data){      current = current. left;      if(current == null){       parent. left = n;       break;      }     } else {      current = current. right;      if(current == null){       parent. right = n;       break;      }     }    }   }  }   inOrder(node){   if(!(node == null)) {    this. inOrder(node. left);    console. log(node. show());    this. inOrder(node. right);   }  }   find(data){   let current = this. root;   while(current. data != data)   {    if(data &lt; current. data) {     current = current. left;    } else {     current = current. right;    }    if(current == null){     return null;    }   }   return current;  }  remove(data){   this. root = this. removeNode(this. root, data);  }  removeNode(node, data){   if(node == null){    return null;   }   if(data == node. data){    if(node. left == null &amp;&amp; node. right == null){     return null;    }    if(node. left == null){     return node. right;    }    if(node. right == null){     return node. left;    }    let tempNode = this. getMinimum(node. right);    node. data = tempNode. data;    node. right = this. removeNode(node. right, tempNode. data);    return node;   } else if(data &lt; node. data) {    node. left = this. removeNode(node. left, data);    return node;   } else {    node. right = this. removeNode(node. right, data);    return node;   }  }  getMinimum(node){   let current = node;   while(!(current. left == null))   {    current = current. left;   }   return current;  } } 이제 문제 나오면 사용하도록 하자. "
    }, {
    "id": 92,
    "url": "/feat_study_CODE_binarySerch/",
    "title": "이진탐색 : Upper Bound, Lower Bound",
    "body": "2020/06/16 - 이진탐색이진 탐색은 기본적으로 매우 중요한 개념이다.  특히 수학적인 부분에서 미적분과 같은 계산하기 어려운 값을 근사치로 나타내고자 할때, 주로 쓰이는 방법 중 하나라는 점에서 말이다. (수치해석 과목에서 잘 찾아볼수 있다. ) 수학적인 부분에서 잘 쓰인다면 역시 프로그래밍에서도 잘 쓰일 수 있는데, 이유는 방대한 양의 데이터를 찾고, 저장하고, 이용하고자 할때 소요되는 시간 (Big-O)에서 큰 활약을 할수 있기 때문이다. 그렇기 때문에 숙지하고 문제해결에 있어서 잘 사용하도록 하자. 기본 개념정렬된 배열에서 처음값과 끝값을 잡은 다음 (보통 처음 : 0, 끝 : 배열의 끝) 중간값을 (처음값 + 끝값)/2 로 잡는다. 중간값에 해당하는 값을 찾은 뒤 해당값이 찾고자 하는 값과 비교하여 크거나 작을때 처음값 또는 끝값을 중간값으로 조정하면서 다시 중간값을 잡는다. 값을 찾거나 처음값이 끝값보다 커질때까지 반복 123456789101112131415161718function binarySeach(list, key) { let low = 0; let high = list. length-1; let mid; while(low &lt;= high) {  mid = parseInt((low + high)/2);  if(key&gt;list[mid]) {   low = mid+1;  } else if (key&lt;list[mid]) {   high = mid-1;  } else {   return mid;  } }  return -(low+1);}# 찾고자 하는 값이 여러개일 경우 이 문제를 해결하기위해 Upper_Bound와 Lower_Bound가 필요하다. 물론 기본 개념에서 약간 조정한 정도이나, 어쨌든 다르다.  C++같은 경우 stl에서 내장된 메소드로 지원을 해주지만 자바에서는 제공을 해주지 않기 때문에 여기서 구현해 놓고자 한다. Upper_Bound와 Lower_Bound를 구분짓는 장치는 key값과 찾고자 하는 값이 같을 경우 처리방법이다.  Upper 같은 경우 해당 값이 나오면 mid+1값으로 low값을 정하며 Lower 같은 경우 mid 값을 high값으로 정한다. 잘 생각해 보면, 이 차이로 Upper는 key 값보다 큰 직후값을 Lower는 key값이 시작되는 값을 갖게된다.   (찾고하 하는 값의 index : Lower &lt;= index &lt; Upper)  Lower_Bound12345678910111213141516function lowerBound(list, key) { let low = 0; let high = list. length-1; let mid; while(low &lt; high) {  mid = parseInt((low + high)/2);  if(key &lt;= list[mid]) {   high = mid;  } else {   low = mid+1;  } }  return low;} Upper_Bound12345678910111213141516function upperBound(list, key) { let low = 0; let high = list. length-1; let mid; while(low &lt; high) {  mid = parseInt((low + high)/2);  if(key &gt;= list[mid]) {   low = mid+1;  } else {   high = mid;  } }  return low;}# 샘플 123456789101112131415161718192021222324252627282930313233343536373839 /* * Javascript version of C++ equal_range via lower_bound and upper_bound * * Input: The array A in ascending order and a target T * Output: The tightly bound indices [i, j] where A[i] &lt;= T &lt; A[j] if T exists in A * otherwise [-1, -1] is returned if T does not exist in A */let lowerBound = (A, T) =&gt; {  let N = A. length,    i = 0,    j = N - 1;  while (i &lt; j) {    let k = Math. floor((i + j) / 2);    if (A[k] &lt; T)      i = k + 1;    else      j = k;  }  return A[i] == T ? i : -1;};let upperBound = (A, T) =&gt; {  let N = A. length,    i = 0,    j = N - 1;  while (i &lt; j) {    let k = Math. floor((i + j + 1) / 2);    if (A[k] &lt;= T)      i = k;    else      j = k - 1;  }  return A[j] == T ? j + 1 : -1;};let equalRange = (A, T) =&gt; {  return [lowerBound(A, T), upperBound(A, T)];};# C++ Std: Upper_Bound 와 Lower_Bound를 구현해 보자 숫자로만 된 배열 같은 경우 그냥 위에 있는것을 써도 되는데, 예를 들어 length와 value를 함께 비교해야 하는 경우 위의 배열은 통하지가 않는다. (이진탐색문제 3 참조) 그런데 C++ Std에서 제공하는 Upper_Bound와 Lower_Bound는 다중 제한 조건의 탐색이 가능한데, 자바에서는 제공하지 않는다. 따라서 구현해서 사용하자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var test = [10, 10, 10, 20, 20, 20, 30, 30, 40, 40, 40];var lo = lower1Bound(test,0,10,40);var up = upper1Bound(test,0,10,40);console. log( lower:   + lo +  , upper:   + up);function lowerBound(list, start, end, key) { let it; let step; let advance; let first = start; let count = end - start + 1; //debugger; while (count &gt; 0){  step = Math. floor(count/2);  advance = first+step;  it = list[advance];  if(it &lt; key &amp;&amp; it !== undefined) { //advance의 값이 0보다 작게 되면 false를 가리켜야 한다.    first = ++advance;   count -= step+1;  } else {   count = step;  } } return first;}function upperBound(list, start, end, key) { let it; let step; let advance; let first = start; let count = end - start + 1; //debugger; while (count &gt; 0){  step = Math. floor(count/2);  advance = first+step;  it = list[advance];  if(!(key &lt; it) &amp;&amp; it !== undefined) {   first = ++advance;   count -= step+1;  } else {   count = step;  } } return first;}"
    }, {
    "id": 93,
    "url": "/study_CODE_binarySearch_2/",
    "title": "이분탐색 : 징검다리 건너기",
    "body": "2020/06/15 - category: 2019 카카오 개발자 겨울 인턴십 문제 설명[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다. ] 카카오 초등학교의 니니즈 친구들이 라이언 선생님과 함께 가을 소풍을 가는 중에 징검다리가 있는 개울을 만나서 건너편으로 건너려고 합니다. 라이언 선생님은 니니즈 친구들이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다. 징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.  디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.  단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.  니니즈 친구들은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다.  니니즈 친구들은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다. 디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.  제한사항     징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.    stones 배열의 크기는 1 이상 200,000 이하입니다.    stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.    k는 1 이상 stones의 길이 이하인 자연수입니다.    문제풀이문제 사고력이 가장 큰 영향을 주는것 같다.  stones index의 값이 연속으로 0이 되는 개수가 k값보다 커지기 직전의 건넌 횟수 핵심 포인트는 결국 stones에 있는 값에서 return 값이 나온다! 라는 것.  (stones에 있는 값 보다 1보다 클수도 작을수도 없다. ) 처음은 문제 설명을 문자 그대로 이용하여 문제해결하고자 하였다.  그러다 보니 설계를 다행히 핵심 포인트는 잡았지만 각 stone별 해당 값을 빼고 값 중 현재값이 양수이면서 0보다 작아지는 index를 바탕으로 k값보다 커지는 순간을 측정하였다. 정확도도 해결해야 했으나, 속도도 같으 병행하며 문제 해결을 해 나갔는데, 조금 더 생각해 보면 stones의 값 중 중복된 값을 제외하고 정렬을 한뒤 작은 값부터 빼내면  해당 값들이 각 index 별 0이 되는 값이기 때문에 (stone이 사라지는 값) 더 빠르게 사용할수 있었다. 여기까지가 할 수 있었던 최대한의 해결. 처음 문제 풀이 : 정확도는 100%, 속도: 0%, 공간: 속도로 인한 측정 불가. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 function solution(stones, k) {  let countStone = 0;  var check;  const fadeStoneSet = [];  let countSet = new Set();  stones. forEach(i =&gt; countSet. add(i));  let stoneSet = [. . . countSet]. sort((a, b) =&gt; b - a);  let curStone = 0;  curStone = stoneSet. pop();  if(k===1) {    return curStone;  }  while (curStone !== undefined) {    let fadeStone = [];    stones. forEach((item, idx) =&gt; {      if (item === curStone) {        fadeStone. push(idx);        countStone++;      }    });    fadeStoneSet. push(. . . fadeStone);    fadeStoneSet. sort( (a, b) =&gt; a-b);    let size = fadeStoneSet. length;    if (countStone &gt;= k) {      var item = fadeStone. pop();      while (item !== undefined) {        check = 1;        let idx = fadeStoneSet. indexOf(item);        let start=idx-k;        if(start&lt;0) {           start=0;        }        let end = idx+k;        if(end&gt;size) {          end = size;        }        for(let i=start, len=end; i&lt;len; i++){          if(check ===2) {            debugger;          }          if((fadeStoneSet[i+1]-fadeStoneSet[i]) === 1) {            check++;            if(check===k) {              return curStone;            }          } else {            check = 1;          }        }        item = fadeStone. pop();      }    }    curStone = stoneSet. pop();  }  return curStone;}위 같이 해결하고 찾아보니 위의 방법은 사실상 완전탐색과 다름이 없고 이분탐색을 한다면 문제 해결은 매우 빨라짐을 알게 되었다. 그래도 stones 내에 있는 값이 결국은 return 값이 된다는 사실을 통해 정렬된 stones 값을 기준으로 left mid right 값을 확인하도록 할 수 있었던 부분에 위안을 삼아야 했다. (다른 풀이를 보니 0과 최대값을 기준으로 이분탐색시도) 최종 풀이 1234567891011121314151617181920212223242526272829303132333435363738function checkStone(stones, mid, k) {  let now = 0;  for(let i = 0; i &lt; stones. length; i++) {    if(stones[i] &lt; mid) {       now += 1;    }    else {      now = 0;    }    if(now &gt;= k) {      return false;    }   }   return true;}function solution(stones, k) {  let countSet = new Set();  stones. forEach(i =&gt; countSet. add(i));  let stoneSet = [. . . countSet]. sort((a, b) =&gt; a-b);  let right=stoneSet. length-1;  let left=0;  let mid;  while(left &lt;= right) {    mid = parseInt((left+right)/2);    if(checkStone(stones, stoneSet[mid], k)) {      left = mid+1;    } else {      right = mid-1;    }  }  return stoneSet[left-1];}"
    }, {
    "id": 94,
    "url": "/study_CODE_binarySearch_1/",
    "title": "이분탐색 : 예산",
    "body": "2020/06/14 - 문제 설명국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것입니다. 국가예산의 총액은 미리 정해져 있어서 모든 예산요청을 배정해 주기는 어려울 수도 있습니다. 그래서 정해진 총액 이하에서 가능한 한 최대의 총 예산을 다음과 같은 방법으로 배정합니다.  모든 요청이 배정될 수 있는 경우에는 요청한 금액을 그대로 배정합니다.  모든 요청이 배정될 수 없는 경우에는 특정한 정수 상한액을 계산하여 그 이상인 예산요청에는 모두 상한액을 배정합니다.   상한액 이하의 예산요청에 대해서는 요청한 금액을 그대로 배정합니다. 입출력 예 | budgets | M | return | | — | — | — | |[120, 110, 140, 150] | 485 | 127 | 문제풀이단순히 BST를 사용해서 문제를 해결하는 것이 아닌 BST의 컨셉을 이용해 가장 근사치 값을 찾는 것이다. (수치해석. . ) 계산적으로 budgets의 상한값의 MAX값은 150이며, MIN 값은 0이다.  이를 시작점을 삼아 middle 값을 정해서, result를 계산하고 해당 result 값과 근사치를 비교하여 크면 middle point를 right로, 작으면 middle point를 left로 기준을 잡고 다시 middle 값을 구한다. (가장 근사치가 나오는 left가 right를 넘어서는 직전 종료) 따라서 풀이는 단순하다. 123456789101112131415161718192021222324252627282930313233343536 function solution(budgets, M) {     let left = 0;  let right = 0;  var answer = 0;    budgets. forEach( (i) =&gt; {   if(i&gt;right) {    right = i;   }  })  let middle = 0;  while (left &lt;= right) {   let sum = 0;   middle = parseInt((left + right)/2);   budgets. forEach( (i) =&gt; {    if (i &gt;= middle) {     sum += middle;    } else {     sum += i;    }   })   if (sum &gt; M) {    right = middle-1;   }   else {    answer = middle;    left = middle+1;   }  }   return answer; }"
    }, {
    "id": 95,
    "url": "/study_CODE_BFS_1/",
    "title": "BFS : 블록 이동하기",
    "body": "2020/06/13 - 문제 설명로봇개발자 무지는 한 달 앞으로 다가온 카카오배 로봇경진대회에 출품할 로봇을 준비하고 있습니다. 준비 중인 로봇은 2 x 1 크기의 로봇으로 무지는 0과 1로 이루어진 N x N 크기의 지도에서 2 x 1 크기인 로봇을 움직여 (N, N) 위치까지 이동 할 수 있도록 프로그래밍을 하려고 합니다. 로봇이 이동하는 지도는 가장 왼쪽, 상단의 좌표를 (1, 1)로 하며 지도 내에 표시된 숫자 0은 빈칸을 1은 벽을 나타냅니다. 로봇은 벽이 있는 칸 또는 지도 밖으로는 이동할 수 없습니다. 로봇은 처음에 아래 그림과 같이 좌표 (1, 1) 위치에서 가로방향으로 놓여있는 상태로 시작하며, 앞뒤 구분없이 움직일 수 있습니다. 로봇이 움직일 때는 현재 놓여있는 상태를 유지하면서 이동합니다. 예를 들어, 오른쪽으로 한 칸 이동한다면 (1, 2), (1, 3) 두 칸을 차지하게 되며, 아래로 이동한다면 (2, 1), (2, 2) 두 칸을 차지하게 됩니다. 로봇이 차지하는 두 칸 중 어느 한 칸이라도 (N, N) 위치에 도착하면 됩니다. 로봇은 다음과 같이 조건에 따라 회전이 가능합니다. 로봇은 90도씩 회전할 수 있습니다. 단, 로봇이 차지하는 두 칸 중, 어느 칸이든 축이 될 수 있지만, 회전하는 방향(축이 되는 칸으로부터 대각선 방향에 있는 칸)에는 벽이 없어야 합니다. 로봇이 한 칸 이동하거나 90도 회전하는 데는 걸리는 시간은 정확히 1초 입니다. 0과 1로 이루어진 지도인 board가 주어질 때, 로봇이 (N, N) 위치까지 이동하는데 필요한 최소 시간을 return 하도록 solution 함수를 완성해주세요.  제한사항     board의 한 변의 길이는 5 이상 100 이하입니다.    board의 원소는 0 또는 1입니다.    로봇이 처음에 놓여 있는 칸 (1, 1), (1, 2)는 항상 0으로 주어집니다.    로봇이 항상 목적지에 도착할 수 있는 경우만 입력으로 주어집니다.     입출력 예      board   result       [[0, 0, 0, 1, 1],[0, 0, 0, 1, 0],[0, 1, 0, 1, 1],[1, 1, 0, 0, 1],[0, 0, 0, 0, 0]]   7   문제풀이어떤방식으로 설계를 해야할지 부터가 고민이었다.  상하 좌우 이동은 단순히 해당 point로부터 각각 옮기면 되었지만, 2개의 축을 두고 회전하는 것을 표현하는 방법을 설계하기가 어려웠다. 해결책은 생각보다 간단한데, 그냥 기준점을 하나의 point로 가지고 진행을 하면 된다.  가로상태일때 기준점은 좌측, 세로일때 기준점을 위측 으로 잡는다.  그렇게 되면 상하좌우는 단순히 기준점만 옮기면 되며, 2개의 축을 가지고 회전하는 경우 각각의 상태를 그냥 표현해 주면 된다.  좌측기준 위로 옮기기 =&gt; 기준점을 상향, 우측 기준 위로 옮기기 =&gt; 기준점을 우측 이동 후 상향 또한 rotate 조건은 기준점을 상하좌우로 옮기는 조건과 동일하다. 이 기준을 가지고 해결해 주면 된다. 위와 같이 기준점이 바뀌는 복잡한 경우 그냥 하나의 기준점을 잡아주고 그 기준을 바탕으로 조건을 설정해주면 해결할 수 있다. 또한 가장 빠른 시간(가장 낮은 걸음수)에 도착하는 문제 같은 경우 해당 point에 시간(걸음수)를 간직한채 방문을 해주면, 해당 값을 update하면서 풀어 주면 된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160function solution(map) { const n = map. length,  dx = [0, 0, 1, -1], //direction x, y 상 하 좌 우 를 나타낸다.   dy = [1, -1, 0, 0],  rowToColDx = [-1, -1, 0, 0], //가로에서 세로로 변경할 좌표. 좌측 up, 우측 up, 좌측 down, 우측 down.   rowToColDy = [0, 1, 0, 1],  colToRowDx = [0, 1, 0, 1], // 세로에서 가로로 변경할 좌표. 위와 동일.   colToRowDy = [0, 0, -1, -1],  q = [   [0, 0, 0, 0] //starting point, BFS의 Queue를 받는다. //이렇게 BFS를 사용할 수 있다.   ],  visited = []; // 방문할때마다, 방문자의 시간을 보고 가장 낮은 값을 간직.  for (let i = 0; i &lt; n; i++) {  visited. push([]);  for (let j = 0; j &lt; n; j++) {   visited[i]. push([Infinity, Infinity]); //가장 낮은값을 간직하기 위해 Infinity 설정  } } visited[0][0][0] = 0; //처음은 0초 let min = Infinity; const canGoRight = (x, y, p) =&gt; { //x,y는 좌표 p는 상태 (가로 상태, 세로 상태)  if (p === 0) {   if (y + 2 &gt;= n || map[x][y + 1] === 1 || map[x][y + 2] === 1)    return false;  } else {   if (y + 1 &gt;= n || x + 1 &gt;= n || map[x][y + 1] === 1 || map[x + 1][y + 1] === 1)    return false;  }  return true; }; const canGoLeft = (x, y, p) =&gt; {  if (p === 0) {   if (y - 1 &lt; 0 || map[x][y - 1] === 1)    return false;  } else {   if (y - 1 &lt; 0 || x + 1 &gt;= n || map[x][y - 1] === 1 || map[x + 1][y - 1] === 1)    return false;  }  return true; }; const canGoDown = (x, y, p) =&gt; {  if (p === 0) {   if (x + 1 &gt;= n || y + 1 &gt;= n || map[x + 1][y] === 1 || map[x + 1][y + 1] === 1)    return false;  } else {   if (x + 2 &gt;= n || map[x + 1][y] === 1 || map[x + 2][y] === 1) {    return false;   }  }  return true; }; const canGoUp = (x, y, p) =&gt; {  if (p === 0) {   if (x - 1 &lt; 0 || y + 1 &gt;= n || map[x - 1][y] === 1 || map[x - 1][y + 1] === 1)    return false;  } else {   if (x - 1 &lt; 0 || map[x - 1][y] === 1) {    return false;   }  }  return true; }; const canRotateUp = (x, y) =&gt;  !(x - 1 &lt; 0 || y + 1 &gt;= n || map[x - 1][y] === 1 || map[x - 1][y + 1] === 1); const canRotateDown = (x, y) =&gt;  !(x + 1 &gt;= n || y + 1 &gt;= n || map[x + 1][y] === 1 || map[x + 1][y + 1] === 1); const canRotateRight = (x, y) =&gt;  !(y + 1 &gt;= n || x + 1 &gt;= n || map[x][y + 1] === 1 || map[x + 1][y + 1] === 1); const canRotateLeft = (x, y) =&gt;  !(y - 1 &lt; 0 || x + 1 &gt;= n || map[x][y - 1] === 1 || map[x + 1][y - 1] === 1); const canGoMap = [ //한번에 이동 및 rotate를 해주기 위한 작업. canGoMap[0] =&gt; canGoRight  canGoRight,  canGoLeft,  canGoDown,  canGoUp ],  canRotateMap = [   [    canRotateUp,    canRotateUp,    canRotateDown,    canRotateDown   ], [    canRotateRight,    canRotateRight,    canRotateLeft,    canRotateLeft   ],  ],  deltaMap = [   [rowToColDx, rowToColDy],   [colToRowDx, colToRowDy]  ]; while (q. length) {  debugger;  const [x, y, t, p] = q. shift();  // 만일 (n,n)에 도착했다면 최소시간을 갱신합니다  if (   (x === n - 1 &amp;&amp; y === n - 2 &amp;&amp; p === 0)   || (x === n - 2 &amp;&amp; y === n - 1 &amp;&amp; p === 1)  ) {   debugger;   min = Math. min(min, t);  }  // 회전 없이 우좌하상으로 움직일때  for (let k = 0; k &lt; 4; k++) {   if (!canGoMap[k](x, y, p)) {    continue;   }   const nx = x + dx[k],    ny = y + dy[k];   if (visited[nx][ny][p] &gt; t + 1) {    visited[nx][ny][p] = t + 1;    q. push([nx, ny, t + 1, p]);   }  }  for (let k = 0; k &lt; 4; k++) {   // 가로로 놓인 상황인 경우 세로로 돌려보자   // 세로로 놓인 상황인 경우 가로로 돌려보자   if (!canRotateMap[p][k](x, y)) continue;   const nx = x + deltaMap[p][0][k],    ny = y + deltaMap[p][1][k],    _p = p ? 0 : 1;   if (visited[nx][ny][_p] &gt; t + 1) {    visited[nx][ny][_p] = t + 1;    q. push([nx, ny, t + 1, _p]);   }  } } return min;}"
    }, {
    "id": 96,
    "url": "/study_BE_WebApi/",
    "title": "Spring : Web-Api",
    "body": "2020/06/12 - Web-Api개요: Api가 무엇인지에 대해서 보다 Web-Api에서 도움을 주는 라이브러리에 대해 살펴보고자 한다. javax. servlet: Http 통신을 위한 라이브러리. 현재 WAS Runtime을 Tomcat으로 지정했고, Tomcat에는 서블릿 라이브러리가 있기 때문에 바로 Tomcat에 올릴경우 없어도 되지만, 올리지 않을 경우 컴파일 단계에서 필요하다. 따라서 scope는 provided javax. jstl: jstl 문법과 EL 표기법을 사용하게 도와주는 라이브러리. (EL표기법은 다이나믹 웹 모듈 2. 4 이후부터 지원)  웹 모듈 3. 1이 되도록 하는 방법  web. xml :  1  &lt;!DOCTYPE web-app PUBLIC  -//Sun Microsystems, Inc. //DTD Web Application 2. 3//EN   http://java. sun. com/dtd/web-app_2_3. dtd  &gt;    ↓   1  &lt;?xml version= 1. 0  encoding= UTF-8 ?&gt;    . settings/org. eclipse. wst. common. project. facet. core. xml : version 변경.  mysql-connector-java: JDBC를 사용할 수 있게 해준다. jDBC: Java Database Connectivity MySQL 사이트에서 가지고 올수 있으며, 자바를 이용한 데이터베이스 접속 및 쿼리 실행 데이터 핸들링을 제공한다. jackson-databind: json 라이브러리이다.  json 데이터를 사용할수 있게 해준다. javax. servlet. jsp: jsp api를 만들수 있게 해준다. "
    }, {
    "id": 97,
    "url": "/study_BE_SpringMVC/",
    "title": "SPRING : Mvc",
    "body": "2020/06/12 - Spring MVC개요: 서블릿과 같은 웹 구현을 위한 작업물을 관리하며 도와준다. 구체적으로 어떤 도움을 주는지 알아보자. WEB: spring-webmvc에서 다루고 있다.  org. springframework. web. servlet. DispatcherServlet : 프론트 컨트롤러에 해당한다. 초기화함께 @EnableWebMvc 를 찾는다.  xml에서 parameter로 AnnotationConfigWebApplicationContext와 FrontController를 도와줄 Main에 해당하는 클래스(보통 WebMvcContextConfiguration) 을 받는다.      WebMvcConfigurerAdapter : 초기 기본 설정 이외 필요한 동작을 할수 있게 해준다.          addResourceHandlers(__) : http 같은 경우 css와 js이 있는 곳을 연결해 준다. ResourceHandlerRegistry 객체를 받아 입력.      configureDefaultServletHandling(__) : //Mapping 정보가 없는 url을 defaultservlet이 처리하게끔 enable! -&gt; was에서 static한 자원을 읽어서 보여준다. DefaultServletHandlerConfigurer 객체를 받아 enable 사용.      addViewControllers(__) : Controller annotation 하지 않아도 특정 url에 대해 Mapping 해준다.  addViewControllers에서 주소값을 설정해주고, setViewName에서 해당 view 파일을 보여준다.      getInternalResourceViewResolver(__) : view 파일의 위치를 정해준다. InternalResourceViewResolver 할당하여 해당 객체에 prefix로 주소를 serffix에 확장자를 더해서 반환한다.            ModelMap : Request scope을 직접 사용하기 보다 Spring이 제공하는 데이터 전달 객체. Spring이 알아서 Request scope로 전달해준다. (여러 객체 존재 Model, ModelView 등등)"
    }, {
    "id": 98,
    "url": "/study_BE_SpringJDBC/",
    "title": "Spring : JDBC",
    "body": "2020/06/11 - Spring JDBC개요: Database와 연결하는 동작을 도와준다.  구체적으로 어떤 도움을 주는지 알아보자. Data Access: DataBase와 연결 부분을 도와준다. spring-jdbc에서 다루고 있다. spring-tx에서 다루고 있다. 또한 추가로 db 연결을 위해 mysql-connector-java가 필요하다. basic data source를 다루기 위해 apache 제공하는 commons-dbcp2 사용한다.  javax. sql. DataSource 객체(이 객체는 다음에 공부하도록 하자. )에 apache에서 제공하는 basicDataSource를 사용하여 데이터를 저장하여 관리한다. jdbcTemplate. queryForInt : 쿼리문을 작성해서 결과 데이터 수를 return jdbcTemplate. queryForObject : 쿼리 결과를 원하는 객체로 받을 수 있다. 이때 new Object[]{1212L}를 사용하는 이유를 잘 모르겠다.  NamedparameterJdbcTemplate : jdbcTempate에서 인자를 ?로 받는 대신 파라미터명을 사용하여 작성하는 것을 지원한다.  NamedparameterJdbcTemplate   query Method : query(Sql문, 바인딩 할 Parameter를 위한 빈 객체- collection. empty객체, dto에서 가져온 rowMapper)   RowMapper : Dto 클래스를 가져와 해당 필드를 parameter로 바꿔준다. (BeanpropertyRowMapper =&gt; 카멜 표기법 &lt;-&gt; 언더스코어 표기법) 즉, 반환을 Dto 객체로 하고 싶을 경우 해당 틀을 RowMapper가 제공하는 것 같다. 와 신기하네 그렇다면 (NamedparameterJdbcTemplate)query(쿼리문, 빈객체, rowMapper) = Dto 객체 이렇단 소린데 자동으로 연결해준단 소리인건가?  update Method : 쿼리문과 바인딩할 parameter 객체를 받아 datebase값을 변경한다. (UPDATE, DELETE) 성공시 1, 실패시 0 반환 UPDATE시 SqlparameterSource에 BeanPropertSqlParameterSource에서 Dto를 받아 각 parameter를 전달한다. 전달된 parameter를 Query문에 바인딩 하여 실행.    DELETE시 Map에 parameter와 값을 가진 singletonMap(1개를 지우는데 사용!)으로 parameter 전달한다. 전달된 parameter를 Query문에 바인딩 하여 실행.     queryForObject Method : queryForObject(SQL 문 , Map에 parameter와 값을 가진 singletonMap으로 parameter 전달한다. , Dto 객체로 반환하기 위해 RowMapper) 전달된 parameter를 Query문에 바인딩 하여 실행. 이떄 해당 parameter에 값이 없을 경우를 대비(Exception)     SimpleJdbcInsert : insert 쿼리를 생성해준다. dataSource에 객체를 생성할때 whtiTableName에 table명을 넣어주면 생성 되며, 객체 안 execute를 통해 쿼리를 실행한다. usingGeneratedKeyColumns(“파라미터”)을 통해 자동으로 파라미터의 값을 가진다. (보통 id) 그리고 excuteAndReturnKey를 통해 반환한다.   TransactionManagementConfigurer : 보통 transaction 하기 위해 DBConfig에서 implements 받아 사용한다.      annotationDrivenTrasactionManager() : transaction을 하기 위해 PlatformTransactionManager의 transactionManager()를 사용하여 DataSourceTransactionManager를 DataSource로 할당시키며, PlatformTransactionManager을 반환한다.    "
    }, {
    "id": 99,
    "url": "/study_BE_SpringFramework/",
    "title": "SPRING : Framework",
    "body": "2020/06/10 - Spring개요: 전문적이다. 처음 Spring을 접할때 느낀 생각이다. 사실 이전에 Spring없이 간단한 dao, dto를 만드는 공부를 할 때, 이 두개의 작업물과 함께 매 프로젝트에는 동일한 용도로 사용되는 과정물이 많을 것 예상되었고, 실무에서는 이같은 중복 작업을 최소한 줄이는 형태로 작업을 진행하고 있곘다로 생각을 했다. 더 편하고, 빠르면서, 유지보수에 그리고 협업하기에도 용이하도록 위와 같은 목적에 부합한 형태에 맞게 framework가 만들어 졌고 그중 Spring은 여러 개발자들이 위와 같은 목적에 부합하다고 판단을 했기 때문에 여전히 인기가 있다고 생각을 한다. 따라서 그와 같은 맥락에서 Spring을 공부하고자 한다. Spring Framework Module: 이제까지 배운 내용을 토대로 정리한다. 웹개발을 크게 3가지로 나누자면 웹구현 - 메모리 할당 및 관리 - 데이터 관련 작업 이 될수 있겠다. Sping은 요소를 각각 Web - Core Container - Data Access/Integration로 나눴다. 각각의 요소를 차차 살펴보고자 한다. Core Container: Data Access: "
    }, {
    "id": 100,
    "url": "/study_BE_Spring-Layered-Architecture/",
    "title": "Spring : Layerd Achitecture",
    "body": "2020/06/09 - Spring - Layered Achitectur개요: 처음 Spring Framework Module에서 볼 때, 아마도 web 개발을 MVC를 통해서. DB관리를 data Access를 통해서 독자적으로 하도록 나누고자 할때 이 둘을 체계적으로 관리할 필요에 의해 존재하는 것 같다. 그와 동시에 각 부분에서 전문화 되도록 관리 하도록 도와주는 것 같다. Layered Achitectur: 우선 xml에서 listener를 통해 MVC와 Data Access를 Data Access가 root, MVC는 그 밑으로 정의 한다    listener : 특정한 이벤트가 발생할 때 동작한다.     ContextLodaerListener : listener에 의해 Context가 Loading 될때 수행 하는데 parameter로 AnnotationConfigWebApplicationContext와 Data Access의 Main Configuration을 가지고 온다. (보통 ApplicationConfig)     filter : 요청이 수행되기 전 응답이 나가기 전 한번 씩 걸쳐나갈수 있게 해준다.  "
    }, {
    "id": 101,
    "url": "/study_BE_Spring-Container/",
    "title": "Spring : Container",
    "body": "2020/06/09 - Spring - Container개요: Core Container: Been: 프로젝트시 대표적인 반복작업인 new 메소드를 통한 메모리 할당을 Spring에서는 해당 작업을 Bean을 통해 도와준다. 그리고 Bean을 spring-context에서 다루고 있다. 아마도 메모리 할당을 위한 클래스를 만들 때 다음과 같은 약속은 당연한것 같다.  자유도가 넓어야 한다. 즉, 기본 생성자를 가지고 있어야 한다.  보안 측면에서 필드는 private로 선언.  필드가 private이기 떄문에 getter, setter 메소드는 필수. 그렇기 때문에 위와 같은 약속이 Bean의 조건인건 자연스럽다. 위와 같은 조건을 만족한 Class를 Bean Class로 사용할수 있다. 추가로 Bean에서 아마도 확장성의 이유로 각각의 getter, setter를 프로퍼티라고 약속하고 관리한다. (ex setName =&gt; name이란 name을 가진 프로퍼티) Bean Class로 사용할수 있는 Class를 사용하기 위해선 ‘사용하겠다!’라고 선언(Bean 선언)을 해야한다.  그리고 Spring은 Bean 선언을 확인하고 getBean()을 통해 메모리 할당을 한다.  할당은 SingleTon. 즉, 여러번 getBean()을 하더라도 결국 인스턴스는 하나인 방식이다. 선언하는 방법은 여러 방법이 있다.    Xml에 선언 Bean 선언을 Xml에 선언하여 따로 관리한다. 보통 src/main/resources에 applicationContext. xml로 관리한다. 이때, Spring:ApplicationContext가 Spring:ClassPathXmlApplicationContext 에서 ‘xml파일 이름’을 받아 src파일 내에 받은 xml 파일 이름에 xml 파일을 찾아 작성된 선언을 확인한다. 프로퍼티를 활용하여 Bean Class를 객체로 가진 Bean Class를 다룰수도 있다.     Class에 선언 (annotation 이용) Class에 선언하여 따로 관리한다. ‘@annotation’과 같이 Spring에서는 단순 Bean 선언과 더불어 더 많은 annotation을 지원하여 각 annotation에 맞는 다양한 동작을 도와준다.          @configuration : Xml을 Class로 가져온 것이라고 할수 있는데, 선언문을 가진 class임을 나타낸다. 보통 configuration이기 때문에 config라는 패키지에 각 목적에 맞는 Config. class로 관리한다. Main config는 ApplicationConfig이때, Spring:ApplicationContext가 Spring:AnnotationConfigApplicationContext 에서 (이름. class) 또는 (“이름”) 을 받아 해당 클래스에 annotation이 있는지 확인하고 선언을 다룬다. 클래스를 가지고 오기 때문에 method이름이 달라서 생기는 error를 걱정할 필요가 없다.           @Bean : Bean Class를 메모리 할당을 해주는 method임을 나타낸다. @configuration클레스에서 실제 메모리 할당하는 작업을 작성한다.           @Import : 두개 이상의 Configuration을 나눠서 다루고자 할때 사용한다. import할 클래스 이름을 받아 해당 클래스의 Configuration을 가져다 쓴다.       @ComponenetScan : annotation 선헌 할때 root를 받아[(프로젝트 전체), 패키지를 받으려면 (basePackages - {“패키지”})] root에 속해있는 Class 중 ComponenetScan이 Scan할수 있는 annotation을 찾고 찾은 Class에서 각 annotation에 맞는 동작을 한다. (@Component, @Repository, @Controller, @Service)         @Component : Bean Class로 사용안 Class안에 있으며 Bean Class임을 나타낸다.              @Autowired : Bean Class에서 다른 Bean 객체를 받게 될 경우 자동으로 해주도록 나타낸다.                 @Repository : 저장소의 역할을 나타낸다.           @EnableTransactionManagement : transaction과 관련된 설정을 자동으로 해준다. 단 TransactionManagementConfigurer를 implements 받아 구현해야 하며, annotationDrivenTransactionManager()를 오버라이딩 해야 한다. 그리고 spring-jdbc에서 다루고 있다. 왜 그런지는 모르겟는데, 사실 transaction은 spring-tx에서 관리할것 처럼 이지만 jdbc에서 관리하고 있다. 여하튼 jdbc를 사용하려면 tx와 같이 사용하고 있다.          @Primary          MVC: 웹에서 서블릿 반복 작업을 Spring에서는 WebMvc을 통해 도와준다. 그리고 WebMvc는 spring-webmvc에서 다루고 있다.  @EnableWebMvc생각해 보자.  웹에서 어떤 주소를 입력을 하면 Http에서 해당 주소에 Request를 보낸다. 그렇다면 그 주소에 해당하는 곳에서 2가지 방법으로 받을수 있는데, xml방식과 자바 class(annotation) 방법이다.    xml  xml에서 해당주소를  주소 - sevlet name : sevlet name - sevlet class 로 매핑을 시킨다.   그러면 해당 sevlet 클래스가 나오는 것이다.     class  서블릿 경우 @WebServlet  컨트롤러의 경우도 있으나 이 경우는 Xml을 사용하지 않고 쓸 장점이 별로 없어서 xml을 사용한다.  여하튼 두가지 방법으로 받아오면 servlet class로 org. springframework. web. servlet. DispatcherServlet를 연결시키고 Main Controller를 parameter로 가지고 오는데(보통 WebMvcContextConfiguration) 해당 클래스에서 @EnableWebMvc을 선언하면 초기화 해준다.  @ComponenetScan : 앞서 설명함.      @Controller : 서블릿으로 사용할 Class를 나타낸다.          @RequestMapping : Http 요창과 이를 다루기 위한 Controller의 메소드를 연결한다.              @GetMapping : @RequestMapping(path=””, method=RequestMethod. Get)       @PostMapping : @RequestMapping(path=””, method=RequestMethod. Post)       @PutMapping       @DeleteMapping       @PatchMapping                @RequestParam : Mapping된 Method의 Argument에 붙일수 있게한다. required는 필수 여부 판단.              defaultValue – This is the default value as a fallback mechanism if request is not having the value or it is empty.        name – Name of the parameter to bind       required – Whether the parameter is mandatory or not. If it is true, failing to send that parameter will fail.        value – This is an alias for the name attribute                @PathVariable : 상위 Mapping의 path에 변수명을 받아와 사용할 수 있게 한다.      @RequestHeader : 요청정보의 헤더 받아온다.      @ModelAttribute : Dto 객체 앞에 붙여서 해당 Dto를 parameter로 사용할 수 있게 해준다.            @Service : 서비스 Class임을 나타낸다.    @Transactional : Default는 ReadOnly이다. 해당 ReadOnly를 false를 해주게 되면 동시성으로 안될 떄 rollback해주게 된다.   @RestController : Controller를 Rest API로 만들게 해준다. 하나의 url에 각각의 작업을 해준다. "
    }, {
    "id": 102,
    "url": "/study_BE_MySQLUTF8/",
    "title": "MySqlUTF8",
    "body": "2020/06/08 - MySQL개요: MySQL 윈도우작업시 한글 입력하지 못하는 현상을 혹시 몰라 작성해둔다. UTF-8 적용여부 확인: show variables like ‘c%’; stauts; 사실 하나씩 테이블 alter로 변경하는 방법이 있으나, 매우 귀찮기 때문에 새로 my. ini를 만들어 변경하는 방법을 사용한다. basedir 경로: show variables where variable_name like ‘%dir’; 해당 경로에 my. ini파일을 집어 넣어야 한다. my. ini: 메모장을 열어 my. ini파일을 만들어 보자. MySQL utf-8 적용하기: MySQL이 설치된 폴도에 가면 my-default. ini 파일을 복사하여 my. ini 파일을 만든다. 들어갈 내용은 show variables where variable_name like ‘%dir’;에서 basedir datadir 그리고 port port 번호는 status 또는 show global variables like ‘port’;로 확인 가능하다.  이때 인코딩을 ANSI로 저장하자.  저장한 my. ini는 basedir에 저장하자. mysql 서비스 종료 후 재시작. 다시 show variables where variable_name like ‘%dir’; 를 통해 basedir datadir port 값이 이상이 없을 경우 123456789101112131415 [client] default-character-set = utf8  [mysqld] character-set-client-handshake=FALSE init_connect=&amp;quot;SET collation_connection = utf8_general_ci&amp;quot; init_connect=&amp;quot;SET NAMES utf8&amp;quot; character-set-server = utf8 collation-server = utf8_general_ci  [mysqldump] default-character-set = utf8  [mysql] default-character-set = utf8추가 후 저장 mysql 서비스 종료 후 재시작. 해결. "
    }, {
    "id": 103,
    "url": "/study_BE_MySQLQuery/",
    "title": "MySQL Query",
    "body": "2020/06/07 - MySQL개요: Database Query문에 대해 알아보자. Table Join: 기본 명렁어는 ~ FROM 기준테이블 JOIN join할테이블 ON 조건 Cross Join: Table A의 모든 레코드들에 대해 Table B가 모두 Mapping 되는 것.  Table A 레코드 10개 Table B 레코드 5개 = 10 X 5 = 50개 출력 단순하 From절에 복수의 테이블 지정 SELECT * FROM table_a, table_b Inner Join: Table A의 특정 컬럼값이 Table B의 지정 컬럼값과 일치하는 레코드만을 선별. ~ FROM table_a INNER JOIN table_b ON table_a. Col = table_b. Col ~ FROM table_a, table_b WHERE table_a. Col = table_b. Col SELECT table_a. ID, table_b. * FROM table_a INNER JOIN table_b ON table_a. ID = table_b. ID WHERE Table_a. Date &gt;= ‘1/1/2012’ Alias를 사용하여 간략히 SELECT a. ID, b. * FROM table_a a INNER JOIN table_b b ON a. ID = b. ID WHERE a. Date &gt;= ‘1/1/2012’ Outer Join: Inner Join + 매칭이 되지 않는 나머지 레코드 또한 출력(NULL) (원하는 레코드에 따라 left, right, full로 나뉜다. ) SELECT a. Name, SUM(b. Total) ‘합계’ FROM table_a a LEFT OUTER JOIN table_b b ON a. Code = b. CityCode GROUP BY a. Name ### Self Join 자신을 Join함 SELECT a. EmpID, a. Name, b. Name AS Boss FROM table_a a, table_b b WHERE a. MgrId = b. EmpId AND b. Name = ‘Kim’ "
    }, {
    "id": 104,
    "url": "/study_BE_MysqlPractice/",
    "title": "MySql",
    "body": "2020/06/02 - MySQL개요: 알아두면 좋을 MySQL을 사용해보며 잊기 전에 명령어 등을 작성해두자. MySQL 유저 생성 및 삭제: root계정으로 접속하여 유저를 생성한다.    생성  create user ‘아이디’@’%’ identified by ‘비밀번호’;     삭제  drop user ‘아이디’;  delete from user whrer user =’아이디’;  권한 부여: grant all privileges on . to ‘아이디’@’%’; // 모든 데이터베이스의 모든 테이블에 대한 권한 부여(. 이 모든 테이블이란 뜻이다. ) grant all privileges on DB이름. * to ‘아이디’@’%’; // 특정 DB에 대한 모든 권한 부여. grant select, insert, update on DB이름. * to ‘아이디’@’%’; // 특정 DB에 대한 특정 권한(select,insert,update) 부여. FLUSH PRIVILEGES; // 변경한 권한을 즉시 반영시켜주는 명령어 SQL문 실행하기:    예시. sql 이 있는 폴더로 이동한 후, 아래와 같은 명령 수행. 명령 수행 후 계정 암호 입력.  mysql -u user아이디 -p 대상database &lt; 예시. sql     MySQL에 접속 후 해당 database에서 아래와 같은 명령문 실행  mysql&gt; source C:/. . (파일주소). . /예시. sql  MySQL utf-8 적용하기: MySQL이 설치된 폴더에 가면 my-default. ini 파일을 복사하여 my. ini 파일을 만든다. "
    }, {
    "id": 105,
    "url": "/study_BE_GitCommand/",
    "title": "Git",
    "body": "2020/06/02 - Linux Command개요: 알아두면 좋을 Linux 명령어와 git 명령어를 사용해보며 잊기 전에 작성해두자. GIT:  git diff 주소1. . 주소2 : 주소 1과 주소 2간 정보차이를 본다. (branch이름도 가능) git 명령어 –help : 도움말 git tag 이름 branch이름 : tag를 달아준다. (Light weight tag)     -a : git tag -a 이름 -m “annotation” branch이름 으로 anntated tag를 달아준다. (git tag -a 1. 0 -m “first release” master)    git push –tags : 태그를 원격저장소에 올려준다. (Release)Reset:  git reset –hard 돌아가려는커밋주소 : 커밋을 뒤로 돌려준다. (복원지점을 건드리는 거라 잘 생각하고 하자. )     –soft : repository에 있는 값을 지우고 해당 커밋 주소의 repository 값으로 바꿈   –mixed : repository, index(add)에 있는 값을 지우고 해당 커밋 주소의 repository 값으로 둘다 바꿈   –hard : repository, index(add), work directory에 있는 값을 지우고 해당 커밋 주소의 repository 값으로 셋다 바꿈   Log:  git log : git 의 log기록을 알려준다.      -p : git의 commit 로그기록과 차이를 알려준다.    –branches : 현재 저장소에 있는 모든 branch들을 보여준다.    –decorate : git의 log에서 branch정보를 알려주는데, 최근버전부터 default값이 된거 같다. 사용 안해도 됨.    –graph : git의 branch의 구도를 graph로 보여준다.    –oneline : graph와 함께 쓰이면서 더 간결하게 graph를 보여준다.    branch이름1. . branch이름2 : branch 간 로그차이를 보여준다.    –reverse : 역순으로 보여준다.    Merge:  git merge 들어가려는 대상(Starting Point) : 받아들이려는 branch로(Destination) checkout하여 Starting Point를 입력하여 병합한다.          Fast-forward : 만일 병합하려는 두 대상이 하나의 대상 목적지에 종속적이라면 merge하는 것 자체가 사실상 단순히 commit을 대상 목적지로 이동시키는 것이기 때문에 별도의 commit을 발생하지 아니하는데 이를 Fast-forward라고 한다.           Merge made by the ‘recursive’ strategy. : 병합하려는 두 대상이 하나의 뿌리를 둔 다른 가지 형태로 구성되어 있다면 해당 가지의 마지막 지점을 병합하여 새로운 commit을(merge commit) 만든다. 해당 commit은 Destination이 가지고 있다.                             CONFLICT (content) : merge하려는 대상 중 서로 같은 내용이 동시에 수정될 경우 해당 문구를 발생하며 해당branch status 에서 해당branch       MERGING status로 변하게 된다. (당연히 어떤 branch가 진짜인지는 기계가 판단할수 없기 때문) 이때 명령어 status를 입력하여 Unmerged 된 공간을 확인후 수정하도록 한뒤 commit을 하면 자동으로 merge commit이 진행되게 된다.                      Branch:  git branch 이름 : 새로운 branch를 만듬 git checkout 목적지 : 목적지로 이동(commit의 주소로도 갈 수 있다. )     -b : 새로운 branch를 만들고 그 branch로 이동   -d : branch를 삭제한다. (삭제하고자 하는 branch에서 사용불가하다. )   -D : 해당 branch가 어떤 branch에도 종속적이지 않는 자료를 가지고 있다면, -d로 명령할 경우, 정말 삭제할 것이냐고 묻는다. 이때 강제로 지워준다.    Stash:  git stash : git stash save와 동일한 작업이며, work space에 지장이 있을 파일을 commit하지 않고 어딘가에 잠시 두게 해준다. 해당 명령은 여러번 하게 되고 stack에 저장된다. 단, 해당파일은 추적되고 있어야 한다. 다시 말해 적어도 한번 git에 add가 되어있어야 한다.  git stash apply : 어딘가에 잠시 둔 파일을 팝업해준다.  git stash list : stash로 저장을 해두면 해당 저장 log는 명시적으로 지우지 않는 이상 reset –hard 를 하더라도 남아있는데 이를 보는 명령어이다.  git stash drop : 저장된 로그 중 가장 최근 로그 1개를 지워준다.      동시에 하려면 git stash apply; git stash drop;    git stash pop : git stash apply; git stash drop;와 같은 작업을 해주는 명령어. Linux:  cd : 디렉토리 이동     cd / : root directory 이동   cd ~ : home directory 이동    Ctrl + insert : 복사 Shift + insert : 붙여넣기MAN:  p : 나가기 h : man 사용법 확인 (help) 방향키 &amp; 엔터 : 한줄씩 넘기기 page Up &amp; Down, Space Bar : 한페이지 씩 넘기기 /검색어 (enter) : 검색     n : 다음문자   N : 이전문자   "
    }, {
    "id": 106,
    "url": "/study_BE_Filter/",
    "title": "Spring : Filter",
    "body": "2020/06/02 - Filter개요: 간단하지만, 남겨두면 좋을 것 같아 작성한다. encoding: Spring에서 제공하는 CharacterEncodingFilter를 사용해 한글 지원이 가능하도록 한다. parameter value로 UTF-8로 한다. url-pattern은 전체로 적용 "
    }, {
    "id": 107,
    "url": "/study_BE_codeConvention/",
    "title": "코드 컨벤션",
    "body": "2020/06/01 - 코드 컨벤션코드 컨벤션은 읽고, 관리하기 쉬운 코드를 작성하기 위한 일종의 코딩 스타일 규약이다. 코딩을 할때 일정한 규칙을 가지게 되면, 해당 코드에 대해 나를 포함한 다른 누가 오게 되더라도 상대적으로 이해하기 편하도록 도와줄 수 있다. 특히 실무에서는 협업하기 때문에 코드 컨벤션은 필수라고 할수 있다. 다만 어디까지나 스타일이기 때문에 해당 프로젝트에 대해 동일한 규칙으로 약속만 되어 있다면, 다른 스타일을 가지고 있는 회사도 있을 수 있다. 지금은 코드 컨벤션 중 여러가지 표기법이 있다는 정도로 이해하고 나 또한 개발할 때, 동일한 규칙으로 개발하려고 한다. 아래는 표기법에 대해 설명하려고 한다. 간단한 내용이기에 설명에는 예시만 할것이며, 개발 하며 잊을 때 마다 참고할 예정이다. my + first + item 파스칼 표기법 -&gt; 클래스, 인터페이스 등: MyFirstItem 카멜 표기법 -&gt; 일반 변수, 함수명 등: myFirstItem 언더스코어 표기법: my_first_item 헝가리언 표기법: 설명을 가진 접두어 + MyFirstItem (동적 타입 언어에는 맞지가 않으므로 있다는 정도로 알아두자. ) 변수 선언:  숫자로 시작하면 안된다.  if와 같은 키워드 사용할 수 없다 보통 카멜표기법을 사용한다. (대소문자를 가리지 않는 환경 - MySQL 에서는 언더스코어 표기법을 사용한다. )"
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});