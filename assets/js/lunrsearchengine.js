
var documents = [{
    "id": 0,
    "url": "/404.html",
    "title": "404",
    "body": "404 Page does not exist!Please use the search bar at the top or visit our homepage! "
    }, {
    "id": 1,
    "url": "/about",
    "title": "about",
    "body": "          2020. 01 ~ 02   예약 서비스           2020. 05 ~ 09   Malg:eon 블로그         Web Project             2020. 01 ~ 02   예약 서비스       2020. 05 ~ 09   Malg:eon 블로그   "
    }, {
    "id": 2,
    "url": "/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 3,
    "url": "/project/index.html",
    "title": "project",
    "body": ""
    }, {
    "id": 4,
    "url": "/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 5,
    "url": "/page2/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 6,
    "url": "/page3/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 7,
    "url": "/page4/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 8,
    "url": "/page5/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 9,
    "url": "/page6/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 10,
    "url": "/page7/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 11,
    "url": "/page8/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 12,
    "url": "/page9/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 13,
    "url": "/page10/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 14,
    "url": "/page11/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 15,
    "url": "/page12/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 16,
    "url": "/page13/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 17,
    "url": "/page14/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 18,
    "url": "/page15/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 19,
    "url": "/page16/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 20,
    "url": "/page17/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 21,
    "url": "/page18/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 22,
    "url": "/page19/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 23,
    "url": "/page20/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 24,
    "url": "/page21/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 25,
    "url": "/page22/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 26,
    "url": "/page23/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 27,
    "url": "/page24/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 28,
    "url": "/page25/index.html",
    "title": "Malg:eon",
    "body": ""
    }, {
    "id": 29,
    "url": "/study/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 30,
    "url": "/study/page2/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 31,
    "url": "/study/page3/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 32,
    "url": "/study/page4/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 33,
    "url": "/study/page5/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 34,
    "url": "/study/page6/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 35,
    "url": "/study/page7/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 36,
    "url": "/study/page8/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 37,
    "url": "/study/page9/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 38,
    "url": "/study/page10/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 39,
    "url": "/study/page11/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 40,
    "url": "/study/page12/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 41,
    "url": "/study/page13/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 42,
    "url": "/study/page14/index.html",
    "title": "study",
    "body": ""
    }, {
    "id": 43,
    "url": "/project/android/index.html",
    "title": "tags",
    "body": "android "
    }, {
    "id": 44,
    "url": "/project/ios/index.html",
    "title": "tags",
    "body": "ios "
    }, {
    "id": 45,
    "url": "/project/web/index.html",
    "title": "tags",
    "body": "web "
    }, {
    "id": 46,
    "url": "/study/android/index.html",
    "title": "tags",
    "body": "android "
    }, {
    "id": 47,
    "url": "/study/db/index.html",
    "title": "tags",
    "body": "db "
    }, {
    "id": 48,
    "url": "/study/java/index.html",
    "title": "tags",
    "body": "java "
    }, {
    "id": 49,
    "url": "/study/java/page2/index.html",
    "title": "tags",
    "body": "java "
    }, {
    "id": 50,
    "url": "/study/javascript/index.html",
    "title": "tags",
    "body": "javascript "
    }, {
    "id": 51,
    "url": "/study/javascript/page2/index.html",
    "title": "tags",
    "body": "javascript "
    }, {
    "id": 52,
    "url": "/study/kotlin/index.html",
    "title": "tags",
    "body": "kotlin "
    }, {
    "id": 53,
    "url": "/study/kotlin/page2/index.html",
    "title": "tags",
    "body": "kotlin "
    }, {
    "id": 54,
    "url": "/study/kotlin/page3/index.html",
    "title": "tags",
    "body": "kotlin "
    }, {
    "id": 55,
    "url": "/study/kotlin/page4/index.html",
    "title": "tags",
    "body": "kotlin "
    }, {
    "id": 56,
    "url": "/study/kotlin/page5/index.html",
    "title": "tags",
    "body": "kotlin "
    }, {
    "id": 57,
    "url": "/study/kotlin/page6/index.html",
    "title": "tags",
    "body": "kotlin "
    }, {
    "id": 58,
    "url": "/study/kotlin/page7/index.html",
    "title": "tags",
    "body": "kotlin "
    }, {
    "id": 59,
    "url": "/study/kotlin/page8/index.html",
    "title": "tags",
    "body": "kotlin "
    }, {
    "id": 60,
    "url": "/study/kotlin/page9/index.html",
    "title": "tags",
    "body": "kotlin "
    }, {
    "id": 61,
    "url": "/study/programming/index.html",
    "title": "tags",
    "body": "programming "
    }, {
    "id": 62,
    "url": "/study/programming/page2/index.html",
    "title": "tags",
    "body": "programming "
    }, {
    "id": 63,
    "url": "/study/programming/page3/index.html",
    "title": "tags",
    "body": "programming "
    }, {
    "id": 64,
    "url": "/study/web/index.html",
    "title": "tags",
    "body": "web "
    }, {
    "id": 65,
    "url": "/study/web/page2/index.html",
    "title": "tags",
    "body": "web "
    }, {
    "id": 66,
    "url": "/test/bf/index.html",
    "title": "tags",
    "body": "brute-force "
    }, {
    "id": 67,
    "url": "/test/bfs/index.html",
    "title": "tags",
    "body": "bfs "
    }, {
    "id": 68,
    "url": "/test/binary/index.html",
    "title": "tags",
    "body": "binary search "
    }, {
    "id": 69,
    "url": "/test/dfs/index.html",
    "title": "tags",
    "body": "dfs "
    }, {
    "id": 70,
    "url": "/test/dynamic/index.html",
    "title": "tags",
    "body": "dynamic programming "
    }, {
    "id": 71,
    "url": "/test/graph/index.html",
    "title": "tags",
    "body": "graph "
    }, {
    "id": 72,
    "url": "/test/greedy/index.html",
    "title": "tags",
    "body": "greedy "
    }, {
    "id": 73,
    "url": "/test/heap/index.html",
    "title": "tags",
    "body": "heap "
    }, {
    "id": 74,
    "url": "/test/queue/index.html",
    "title": "tags",
    "body": "queue "
    }, {
    "id": 75,
    "url": "/test/sort/index.html",
    "title": "tags",
    "body": "sort "
    }, {
    "id": 76,
    "url": "/test/stack/index.html",
    "title": "tags",
    "body": "stack "
    }, {
    "id": 77,
    "url": "/test/standard/index.html",
    "title": "tags",
    "body": "standard "
    }, {
    "id": 78,
    "url": "/test/standard/page2/index.html",
    "title": "tags",
    "body": "standard "
    }, {
    "id": 79,
    "url": "/test/standard/page3/index.html",
    "title": "tags",
    "body": "standard "
    }, {
    "id": 80,
    "url": "/test/standard/page4/index.html",
    "title": "tags",
    "body": "standard "
    }, {
    "id": 81,
    "url": "/test/standard/page5/index.html",
    "title": "tags",
    "body": "standard "
    }, {
    "id": 82,
    "url": "/test/standard/page6/index.html",
    "title": "tags",
    "body": "standard "
    }, {
    "id": 83,
    "url": "/test/standard/page7/index.html",
    "title": "tags",
    "body": "standard "
    }, {
    "id": 84,
    "url": "/test/standard/page8/index.html",
    "title": "tags",
    "body": "standard "
    }, {
    "id": 85,
    "url": "/test/standard/page9/index.html",
    "title": "tags",
    "body": "standard "
    }, {
    "id": 86,
    "url": "/test/index.html",
    "title": "test",
    "body": ""
    }, {
    "id": 87,
    "url": "/test/page2/index.html",
    "title": "test",
    "body": ""
    }, {
    "id": 88,
    "url": "/test/page3/index.html",
    "title": "test",
    "body": ""
    }, {
    "id": 89,
    "url": "/test/page4/index.html",
    "title": "test",
    "body": ""
    }, {
    "id": 90,
    "url": "/test/page5/index.html",
    "title": "test",
    "body": ""
    }, {
    "id": 91,
    "url": "/test/page6/index.html",
    "title": "test",
    "body": ""
    }, {
    "id": 92,
    "url": "/test/page7/index.html",
    "title": "test",
    "body": ""
    }, {
    "id": 93,
    "url": "/test/page8/index.html",
    "title": "test",
    "body": ""
    }, {
    "id": 94,
    "url": "/test/page9/index.html",
    "title": "test",
    "body": ""
    }, {
    "id": 95,
    "url": "/test/page10/index.html",
    "title": "test",
    "body": ""
    }, {
    "id": 96,
    "url": "/test/page11/index.html",
    "title": "test",
    "body": ""
    }, {
    "id": 97,
    "url": "/study_kotlin_by(mplementation-by-Delegation)/",
    "title": "Kotlin - by 2. Implementation by Delegation",
    "body": "2021/01/09 - 개요: 지난 포스팅과는 다른 기능을 하는 by를 분석하려고 한다. Implementation by Delegation: kotlin에서 설명하는 Implementation by Delegation의 예시 프로그램을 이용하여 by Delegation을 이해해보자. 1234567891011121314interface Base {  fun print()}class BaseImpl(val x: Int) : Base {  override fun print() { print(x) }}class Derived(b: Base) : Base by bfun main() {  val b = BaseImpl(10)  Derived(b). print()}110우선 레퍼런스는 위의 예시에 대해 아래와 같이 설명한다. 상속을 표현하는 슈퍼타입 리스트 내의 by 절은 b(에 대한 참조)가 상속 오브젝트의 내부에 저장되고 컴파일러가 b가 가지는 Base 인터페이스의 모든 메소드를 생성함을 나타냅니다 그렇다면 여기서 1class Derived(b: Base) : Base by b이 부분을 디컴파일 해보면 다음과 같다. (그 윗부분은 알고있는 상속 인터페이스) 1234567891011121314public final class Derived implements Base {  // $FF: synthetic field  private final Base $$delegate_0;  public Derived(@NotNull Base b) {   Intrinsics. checkParameterIsNotNull(b,  b );   super();   this. $$delegate_0 = b;  }  public void printX() {   this. $$delegate_0. printX();  }}$$delegate_0가 Base 타입의 본래 인스턴스를 참조할 수 있도록 생성되며, printX()도 정적 메소드로 생성되어 $$delegate_0의 printX()를 호출할 수 있도록 생성된다. 그렇기 때문에, Derived를 사용할 때 Base에 대한 명시적 참조를 생략하고, printX() 메소드를 호출하는 것이 가능하다. 그렇다면 오버라이딩 한 멤버를 위임할 경우는 어떻게 될까? 12345678910111213141516171819interface Base {  fun printMessage()  fun printMessageLine()}class BaseImpl(val x: Int) : Base {  override fun printMessage() { print(x) }  override fun printMessageLine() { println(x) }}class Derived(b: Base) : Base by b {  override fun printMessage() { print( abc ) }}fun main() {  val b = BaseImpl(10)  Derived(b). printMessage()  Derived(b). printMessageLine()}1abc10다시 디컴파일을 해보자 1234567891011121314151617181920public final class Derived implements Base {  // $FF: synthetic field  private final Base $$delegate_0;  public void printMessage() {   String var1 =  abc ;   boolean var2 = false;   System. out. print(var1);  }  public Derived(@NotNull Base b) {   Intrinsics. checkParameterIsNotNull(b,  b );   super();   this. $$delegate_0 = b;  }  public void printMessageLine() {   this. $$delegate_0. printMessageLine();  }}종합적으로 . . 상속과 동일하다!? base를 impl한 b와 base를 impl한 derived는 상속 관계가 된다. 사실 기본적으로 코틀린 클래스는 JVM의 final속성을 가지고 있기 때문에, 상속을 하려면 open 키워드를 사용해야 한다. 그런데 위임을 사용한다면 레퍼런스에서 소개한대로 상속에 대안이 될수가 있다. The Delegation pattern has proven to be a good alternative to implementation inheritance, and Kotlin supports it natively requiring zero boilerplate code 이번에 다른 예제를 살펴보자. CoffeeMaker 프로그램이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566interface Heater {  fun on()  fun off()  fun isHot() : Boolean}class ElectricHeater(var heating: Boolean = false) : Heater {  override fun on() {    println( ~ ~ ~ heating ~ ~ ~ )    heating = true  }  override fun off() {    heating = false  }  override fun isHot() : Boolean {    return heating  }}interface Pump {  fun pump()}class Thermosiphon(heater: Heater) : Pump, Heater by heater {  override fun pump() {    if (isHot()) {      println( =&gt; =&gt; pumping =&gt; =&gt; );    }  }}interface CoffeeModule {  fun getThermosiphon() : Thermosiphon}class MyDripCoffeeModule : CoffeeModule {  companion object {    val electricHeater: ElectricHeater by lazy {      ElectricHeater()    }  }  private val _thermosiphon : Thermosiphon by lazy {    Thermosiphon(electricHeater)  }    override fun getThermosiphon() : Thermosiphon = _thermosiphon}class CoffeeMaker(val coffeeModule: CoffeeModule) {  fun brew() {    coffeeModule. getThermosiphon(). run {      on() // heater. on 이 아니다!      pump()      println(  [_]P coffee! [_]P  )      off() // heater. off 가 아니다!    }  }}fun main(args: Array&lt;String&gt;) {  val coffeeMaker = CoffeeMaker(MyDripCoffeeModule())  coffeeMaker. brew();}위 글은 이 포스트에서 참고하였습니다. "
    }, {
    "id": 98,
    "url": "/study_kotlin_by(Property-Delegation)/",
    "title": "Kotlin - by 1. Property Delegation",
    "body": "2021/01/08 - Delegation: 코틀린에서는 두 가지의 Delegation을 소개한다. Property Delegation과 Implementation by Delegation. 이 둘은 각기 다른 기능을 가지고 있는데, 2개의 포스트로 각각의 기능을 이해해보려 한다. Property Delegation: 프로퍼티 위임(Property Delegation)은 프로퍼티에 대한 getter/setter를 위임하여 위임받은 객체로 하여금 값을 읽고 쓸 때 어떠한 중간 동작을 수행하는 기능이다. 1val/var &lt;property name&gt;: &lt;Type&gt; by &lt;delegate&gt;이제 이름과 나이 그리고 연봉을 저장하는 프로그램에서 위임을 적용하는 과정을 보여주려고 한다. 123456789101112131415161718192021222324252627class Person(val name: String, val _age: Int, val _salary: Int) {  var age = _age    get() {      println( age get: $field )      return field    }    set(value) {      println( age set: $value )      field = value    }  var salary = _salary    get() {      println( salary get: $field )      return field    }    set(value) {      println( salary set: $value )      field = value    }}fun main() {  val p = Person( K , 20, 2000)  p. age = 21  p. salary = 2100  println( ${p. name} - age: ${p. age}, salary: ${p. salary} )}12345age set: 21salary set: 2100age get: 21salary get: 2100K - age: 21, salary: 2100 간단한 프로그램임에도 코드가 많다. 여기서 코드를 줄이기 위해 중복되는 동작인 get과 set을 분리하여 호출하도록 만들었다. 123456789101112131415161718192021222324252627282930class Delegator(val fname: String) {  var value: Int =0  fun getMethod(): Int {    println( $fname get: $value )    return value  }  fun setMethod(newValue: Int) {    println( $fname set: $newValue )    value = newValue  }}class Person(val name: String) {  val ageDelegator = Delegator( age )  val salaryDelegator = Delegator( salary )  var age: Int    get() = ageDelegator. getMethod()    set(value: Int) = ageDelegator. setMethod(value)  var salary: Int    get() = salaryDelegator. getMethod()    set(value: Int) = salaryDelegator. setMethod(value)}fun main() {  val p = Person( K )  p. age = 21  p. salary = 2100  println( ${p. name} - age: ${p. age}, salary: ${p. salary} )}12345age set: 21salary set: 2100age get: 21salary get: 2100K - age: 21, salary: 2100 여기에 더하여 코틀린은 by를 지원하여 프로퍼티의 get과 set을 이어주도록 만들어준다. 실제 Property Delegation에서 제공하는 Delegator가 아래와 같이 만들어져 있다. 1234567891011121314151617181920212223class Person(val name: String, age: Int, salary: Int) {  var age: Int by Delegator(age  var salary: Int by Delegator(salary)}class Delegator(var value: Int) {  operator fun getValue(thisRef: Person, property: KProperty&lt;*&gt;): Int {    println( ${property. name} get: $value )    return value  }  operator fun setValue(thisRef: Person, property: KProperty&lt;*&gt;, newValue: Int) {    println( ${property. name} set: $newValue )    value = newValue  }}fun main() {  val p = Person( K , 20, 2000)  p. age = 21  p. salary = 2100  println( ${p. name} - age: ${p. age}, salary: ${p. salary}  )}12345age set: 21salary set: 2100age get: 21salary get: 2100K - age: 21, salary: 2100 여기서 끝나지 않는다! 해당 Delegater에서는 더 많은 기능 부여 할 수 있다. 아래는 실제 코틀린에서 제공하는 Delegator를 이용해 더 많은 기능을 부여해 보았다. 12345678910111213141516171819202122232425262728293031fun Person. makeDelegator(value: Int) = Delegator(this, value)class Person(val name: String, age: Int, salary: Int) {  val thisName =  Person 객체   var age: Int by makeDelegator(age)  var salary: Int by makeDelegator(salary)}class Delegator(var person: Person, var value: Int) {  init {    println( Delegator 실행!! 여긴 ${person. thisName} )  }  operator fun getValue(thisRef: Person, property: KProperty&lt;*&gt;): Int {    println( ${property. name} get: $value )    return value  }  operator fun setValue(thisRef: Person, property: KProperty&lt;*&gt;, newValue: Int) {    println( ${property. name} set: $newValue )    value = newValue  }}fun main() {  val p = Person( K , 20, 2000)  p. age = 21  p. salary = 2100  println( ${p. name} - age: ${p. age}, salary: ${p. salary}  )}1234567Delegator 실행!! 여긴 Person 객체Delegator 실행!! 여긴 Person 객체age set: 21salary set: 2100age get: 21salary get: 2100K - age: 21, salary: 2100 "
    }, {
    "id": 99,
    "url": "/study_kotlin_Property/",
    "title": "Kotlin - Property",
    "body": "2021/01/07 - 개요: 코틀린이 지원하는 Property 접근 방법을 알아보려고 한다. 이 글은 이 포스트를 기반으로 작성되었다. kotlin: 코틀린은 null을 싫어한다. (개인적인 생각이다. ) 123class MainActivity : AppCompatActivity() {  private var helloMessage : String =  Hello }그러나 아래와 같이 프로그램의 라이프사이클에서 초기화 이후 Property의 참조를 생성해야 하는 경우가 많다. 123456789public class MainActivity extends AppCompatActivity {  private TextView mWelcomeTextView;  @Override  protected void onCreate(Bundle savedInstanceState) {    super. onCreate(savedInstanceState);    setContentView(R. layout. activity_main);    mWelcomeTextView = (TextView) findViewById(R. id. msgView);  }}물론 똑같이 만들수는 있다. 12345678class MainActivity : AppCompatActivity() {  private var mWelcomeTextView: TextView? = null  override fun onCreate(savedInstanceState: Bundle?) {    super. onCreate(savedInstanceState)    setContentView(R. layout. activity_main)    mWelcomeTextView = findViewById(R. id. msgView) as TextView  }}그렇지만 앞서 말했듯 kotlin은 null을 싫어한다. 그래서 하나의 방법으로 lateinit을 지원한다. 12345678class MainActivity : AppCompatActivity() {  private lateinit var mWelcomeTextView: TextView  override fun onCreate(savedInstanceState: Bundle?) {    super. onCreate(savedInstanceState)    setContentView(R. layout. activity_main)    mWelcomeTextView = findViewById(R. id. msgView) as TextView  }}lateinit은 생성자 단계에서 값이 저장되지 않은 상태를 컴파일러가 인정하도록 한다. 따라서 컴파일 단계에서의 값과 처음 값에 접근할 때의 값이 다르므로 해당 프로퍼티는 var만이 사용할 수 있다. 그렇지만 위의 프로그램을 살펴보면 MainActivity의 라이프사이클동안 해당 참조는 동일하기 떄문에 read-only로 주어야 하지 않을까? 이를 위해 kotlin에서는 by lazy를 이용한 초기화 지연을 제공한다. by lazy: 123456789101112class MainActivity : AppCompatActivity() {  private val messageView : TextView by lazy {    // messageView의 첫 액세스에서 실행됩니다    findViewById(R. id. message_view) as TextView  }  override fun onCreate(savedInstanceState: Bundle?) {    super. onCreate(savedInstanceState)  }  fun onSayHello() {    messageView. text =  Hello   }}이제 by lazy의 동작을 살펴보고 이해해보자. lazy를 통해 선언된 프로퍼티를 by가 위임하는 것을 알 수 있다. 그렇다면 lazy의 동작을 살펴보자. 우선 Kotlin 표준 라이브러리에선 이렇게 설명한다.  lazy()는 람다를 전달받아 저장한 Lazy 인스턴스를 반환한다.  최초 getter 실행은 lazy()에 넘겨진 람다를 실행하고, 결과를 기록한다.  이후 getter 실행은 기록된 값을 반환한다. 즉, lazy는 프로퍼티의 값에 접근하는 최처 시점에 초기화를 수행하고 이 결과를 저장한 뒤 기록된 값을 재 반환하는 인스턴스를 생성하는 함수라는 것을 알 수 있다. 설명을 이해하기 위해 lazy를 디컴파일 해보자. 123class Demo {  val myName : String by lazy {  John  }}1234567891011121314151617public final class Demo {  @NotNull  private final Lazy myName$delegate;    // $FF: synthetic field  static final KProperty[] $$delegatedProperties = . . .   @NotNull  public final String getMyName() {    Lazy var1 = this. myName$delegate;    KProperty var3 = $$delegatedProperties[0];    return (String)var1. getValue();  }  public Demo() {    this. myName$delegate =      LazyKt. lazy((Function0)null. INSTANCE);  }}코드를 살펴보자  myName에 $delegate를 붙인 필드(myName$delegate)를 생성한다.  myName$delegate 타입은 String이 아닌 Lazy이다.  생성자에서 myName$delegate에 대하여 LazyKt. lazy()를 할당.  LazyKt. lazy()는 주어진 초기화 블록을 실행하는 역할을 한다. 실제 동작은 getMyName()의 호출 시 Lazy로 선언된 myName$delegate를 가져와 getValue()를 이용하여 초기화 된 값을 가져온다. $$delegatedProperties는 위임된 프로퍼티들의 정보(owner class, 필드명, accessor, modifier, getter의 named signature 등)를 가지고 있는 KProperty[] 타입의 필드이다. 더 많이 알아보고 싶다면 이글을 참고하자. "
    }, {
    "id": 100,
    "url": "/study_Android_Dagger/",
    "title": "Android Dagger",
    "body": "2021/01/01 - 이전 DI 적용 Dagger: 지난 포스트에서 다뤘던 CoffeeMaker에서 더욱 발전시켜 CoffeeMaker와 CafeInfo로 구성된 CafeApp을 만들어 보고자 한다. (CafeInfo는 단순히 카페 정보를 다루는 클래스이다. )또한 프로그램을 발전시킴에 따라 필요해진 기능을 적용해보고자 한다. 이전 Setting과 동일하게: CoffeeBeanCoffeeMaker의 brew 기능을 추가하여 CoffeeBean을 받도록 하겠다. 12345public class CoffeeBean {  public void name(){    System. out. println( CoffeeBean );  }}CoffeeMaker편의상 이전에 만든 CoffeeMaker에서 brew에 CoffeeBean을 받도록 하는 대신 Pumb는 제외하겠다. 123456789101112public class CoffeeMaker{  private Heater heater;  @Inject  public CoffeeMaker(Heater heater){    this. heater = heater;  }  public void brew(CoffeeBean coffeeBean){    System. out. println( CoffeeBeen( +coffeeBean. toString()+ ) [_]P coffee! [_]P  );  }}CafeInfo123456789101112public class CafeInfo {  private String name;  public CafeInfo(){}  public CafeInfo(String name){ this. name = name; }  public void welcome(){    System. out. println( Welcome   + name == null?   :name );  }}CafeModule1234567891011121314151617@Modulepublic class CafeModule {  @Provides  CafeInfo provideCafeInfo(){    return new CafeInfo();  }  @Provides  CoffeeMaker provideCoffeeMaker(Heater heater){    return new CoffeeMaker(heater);  }  @Provides  Heater provideHeater(){    return new Heater();  }}CafeComponent굳이 2가지 방법을 사용할 필요가 없으므로 여기선 provision method 만을 사용한다. 1234567@Component(modules = {    CafeModule. class})public interface CafeComponent {  CafeInfo cafeInfo();  CoffeeMaker coffeeMaker();}Main1234public static void main(String[] args) {  CafeComponent cafeComponent = DaggerCafeComponent. create()  CafeInfo cafeInfo = cafeComponent. cafeInfo();}123456public static void main(String[] args) {  CafeComponent cafeComponent = DaggerCafeComponent. create()  CafeInfo cafeInfo1 = cafeComponent. cafeInfo();  CafeInfo cafeInfo2 = cafeComponent. cafeInfo();  System. out. println( CafeInfo is equal :   + cafeInfo1. equals(cafeInfo2));}1CafeInfo is equal : false그런데 프로그램에서 여러가지 이유로 고유한 인스턴스를 가지고 있어야 할 필요가 있다. 이 프로그램에선 cafeInfo가 그런 예로, 단순히 비유를 하자면 카페가 운영되는 동안 카페 정보는 하나 뿐이며 누가 보더라도 같은 결과를 가져야 한다. 즉, 고유해야한다. 이를 해결 위한 방법은 @Singleton 이다. @Singleton: Singleton은 고유한 인스턴스를 갖도록 해주는 annotation이다. 우선 당연하게도 cafeComponent. cafeInfo()가 singleton이 되어야 하려면 cafeComponent가 singleton이어야 하며 1234567@Singleton@Component(modules = {    CafeModule. class})public interface CafeComponent {  CafeInfo cafeInfo();}cafeComponent. cafeInfo()가 singleton 이어야 하는데, 이것은 Module에서 provide 해주는 것이다. 12345678@Modulepublic class CafeModule {  @Singleton  @Provides  CafeInfo provideCafeInfo(){    return new CafeInfo();  }}그렇다면 동일하게 된다. 123456public static void main(String[] args) {  CafeComponent cafeComponent = DaggerCafeComponent. create()  CafeInfo cafeInfo1 = cafeComponent. cafeInfo();  CafeInfo cafeInfo2 = cafeComponent. cafeInfo();  System. out. println( CafeInfo is equal :   + cafeInfo1. equals(cafeInfo2));}1CafeInfo is equal : trueSubComponent: 여기서 추가로 CafeComponent에서 coffeeMaker는 고유한 인스턴스가 아니어도 되지만, Heater는 CoffeeMaker에서(!) 고유한 인터페이스로 만들고 싶다. 그동안 공부한 Dagger를 살펴보면 CafeComponent라는 기준점으로 Singleton으로 관리할 수 있었다. 따라서 추가 기준점을 만들어야 한다. 그러기 위한 방법이 SubComponent이다. 적용해 보자. 수정Component에서 subcompuonent를 구현하고, subcomponent는 Component와 연결된 module에서 설정한다. (encapsulate)이는 하나의 컴포넌트에서 서브컴포넌트를 다루도록 하게 해준다. 12345678910@Singleton@Component(modules = {    CafeModule. class})public interface CafeComponent {  CafeInfo cafeInfo();  // coffeeMaker는 subcomponent에 의해 다뤄지므로 대체한다.   //Builder는 subcomponent에서 설명하겠다.   CoffeeComponent. Builder coffeeComponent(); }12345678@Module(subcomponents = CoffeeComponent. class)public class CafeModule {  @Singleton  @Provides  CafeInfo cafeInfo(){    return new CafeInfo();  }}추가123@Scope@Retention(RetentionPolicy. RUNTIME)public @interface CoffeeScope {}12345public class CoffeeBean {  public void name(){    System. out. println( CoffeeBean );  }}아래는 subcomponent. builder는 dagger의 component의 인터페이스를 구현하는 빌드 작업에 해당하는 인터페이스이다. @Component에서 별다른 작업이 없었던 것은 생략해도 위와 같은 동작을 자동으로 해주기 때문이다. 그러나 subcomponent에서는 생략할수가 없다. 또한 builder를 작성하면 build 하기 전에 모듈을 파라미터로 넣을수가 있는 장점이 존재한다. 12345678910111213@CoffeeScope@Subcomponent(modules = {    CoffeeModule. class})public interface CoffeeComponent {  CoffeeMaker coffeeMaker();  CoffeeBean coffeeBean();  @Subcomponent. Builder  interface Builder{    CoffeeComponent build();  }}1234567891011121314151617181920@Modulepublic class CoffeeModule {  @CoffeeScope  @Provides  CoffeeMaker provideCoffeeMaker(Heater heater){    return new CoffeeMaker(heater);  }  @CoffeeScope  @Provides  Heater provideHeater(){    return new Heater();  }  @Provides  CoffeeBean provideCoffeeBean(){    return new CoffeeBean();  }}Main1234567891011121314151617181920public static void main(String[] args){  CafeComponent cafeComponent = DaggerCafeComponent. create();  CoffeeComponent coffeeComponent1 = cafeComponent. coffeeComponent(). build();  CoffeeComponent coffeeComponent2 = cafeComponent. coffeeComponent(). build();  CoffeeMaker coffeeMaker1 = coffeeComponent1. coffeeMaker();  CoffeeMaker coffeeMaker2 = coffeeComponent1. coffeeMaker();  System. out. println( CoffeeScope / same component coffeeMaker is equal :   + coffeeMaker1. equals(coffeeMaker2));  CoffeeMaker coffeeMaker3 = coffeeComponent2. coffeeMaker(); //MakerScopeMethod  System. out. println( CoffeeScope / different component coffeeMaker is equal :   + coffeeMaker1. equals(coffeeMaker3));  //Non-scope  CoffeeBean coffeeBean1 = coffeeComponent1. coffeeBean();  CoffeeBean coffeeBean2 = coffeeComponent1. coffeeBean();  System. out. println( Non-scoped coffeebean is equal :   + coffeeBean1. equals(coffeeBean2));  //Encapsulate    CoffeeComponent coffeeComponent = DaggerCafeComponent. create(). coffeeComponent(). build();    coffeeComponent. coffeeMaker(). brew(coffeeComponent. coffeeBean());}1234CoffeeScope / same component coffeeMaker is equal : trueCoffeeScope / different component coffeeMaker is equal : falseNon-scoped coffeebean is equal : falseCoffeeBeen(dagger2example. CoffeeBean@4aa298b7) [_]P coffee! [_]P component. builder: 앞서 subcomponent에서는 builder가 필수라고 했었다. component에서는 생략을 해도 되나, 필요시 만들 수 있다. builder를 만들 경우 동작하기 위해 create()가 아닌 build()를 사용하며, build하기 전에 파라미터를 사용할 수 있다. 여기선 모듈에 멤버변수를 만들고 이를 사용하기 위해 builder를 사용해 보겠다. 모듈의 멤버변수를 사용하기 위해선 member-injection method을 사용할 수 없다. 당연하게도 컴포넌트 안에서 모듈을 가지고 있는 provision method에 반해 member-injection method는 모듈을 가지고 있지 않기 때문이다. 123456789101112131415161718@Module(subcomponents = CoffeeComponent. class)public class CafeModule {  private String name;  public CafeModule(){ }  public CafeModule(String name){    this. name = name;  }  @Singleton  @Provides  CafeInfo cafeInfo(){    if(name == null || name. isEmpty()) return new CafeInfo();    else return new CafeInfo(name);  }}1234567891011121314151617@Singleton@Component(modules = {    CafeModule. class})public interface CafeComponent {  CafeInfo cafeInfo();  CoffeeComponent. Builder coffeeComponent();  @Component. Builder  interface Builder{    Builder cafeModule(CafeModule cafeModule);    CafeComponent build();  }  void inject(CafeInfo cafeInfo);}1234567891011121314public static void main(String[] args){  CafeInfo cafeInfo = new CafeInfo();  CafeComponent cafeComponent = DaggerCafeComponent. builder()      . cafeModule(new CafeModule( example cafe ))      . build();  cafeComponent. inject(cafeInfo);  cafeInfo. welcome();  CafeComponent cafeComponent2 = DaggerCafeComponent. builder()      . cafeModule(new CafeModule( example cafe ))      . build();  cafeComponent2. cafeInfo(). welcome();}12nullexample cafeMultiBinding - @Binds: Module에서 provide할때 같은 타입이지만 다른 객체를 반환하는 경우가 있다. (이 프로그램에서는 CoffeeBean에 에디오피아콩과, 과테말라콩 등등 을 넣어 볼 예정이다. ) 이럴때 @Binds를 사용한다. 물론 @Provides와 함께 @Named 으로 관리를 할 수 있다. 그러나 Binds보다 비효율적이다. 라고 이해하면 된다. 이런 장점에도 굳이 @Named가 있는 이유는 @Binds를 사용하려면 아래와 같은 제약조건이 따르기 때문이다.  오직 1개의 파라미터를 가지고 있어야 한다.  abstract 함수로 호출해야 한다.  해당 항목은 Injectable해야 한다.  해당 항목이 provide되어도 할수는 있다. 그래서 Binds를 적용해 보고자 한다. (@Named는 여기서 참고하자. ) 우선 Injectable항목!bind를 하기위한 모듈이 필요하며 이것도 abstract 여야 한다. 또한 같은 타입이지만 다른 객체인 항목을 구분해주기 위해 Map을 이용해 주며, Key값을 설정해야 한다. 여기선 @StringKey을 이용해 String으로 구분해 주려고 한다. (@MapKey로 커스텀 설정이 가능하다. ) 1234567@Modulepublic abstract class CoffeeBeanModule {  @Binds  @IntoMap  @StringKey( guatemala )  abstract CoffeeBean provideGuatemalaBean(GuatemalaBean guatemalaBean);}이 모듈은 주입을 하는 component 즉, CoffeeComponent와 연결된다. 123456789101112131415@CoffeeScope@Subcomponent(modules = {    CoffeeModule. class    ,CoffeeBeanModule. class})public interface CoffeeComponent {  CoffeeMaker coffeeMaker();  Map&lt;String,CoffeeBean&gt; coffeeBeanMap();  @Subcomponent. Builder  interface Builder{    //Builder coffeeModule(CoffeeModule coffeeModule);    CoffeeComponent build();  }}이제 이용해 보자! 1234public static void main(String[] args){  CoffeeComponent coffeeComponent = DaggerCafeComponent. create(). coffeeComponent(). build();  coffeeComponent. coffeeBeanMap(). get( guatemala ). name();}1GuatemalaBeanprovide된 항목provide된 항목이라고 간단하게 말했지만, 풀어보자면 다음과 같다. Component 인터페이스에 CoffeeBean을 @binds로 구성된 abstract 함수로 provide해준다. 이는 다른 모듈에서 provide된 항목으로 주입 할수 있다. 이 항목은 다시 mapkey를 이용한 항목에도 들어갈 수 있다. 123456789101112131415@CoffeeScope@Subcomponent(modules = {    CoffeeModule. class    ,CoffeeBeanModule. class})public interface CoffeeComponent {  CoffeeMaker coffeeMaker();  CoffeeBean coffeeBean();  @Subcomponent. Builder  interface Builder{    //Builder coffeeModule(CoffeeModule coffeeModule);    CoffeeComponent build();  }}12345678910@Modulepublic abstract class CoffeeBeanModule {  @Binds  abstract CoffeeBean provideCoffeeBean(EthiopiaBean ethiopiaBean);  @Binds  @IntoMap  @StringKey( ethiopia )  abstract CoffeeBean provideEthiopiaBean(EthiopiaBean ethiopiaBean);}1234567891011121314151617181920@Modulepublic class CoffeeModule {  @CoffeeScope  @Provides  CoffeeMaker provideCoffeeMaker(Heater heater){    return new CoffeeMaker(heater);  }  @CoffeeScope  @Provides  Heater provideHeater(){    return new Heater();  }  @Provides  EthiopiaBean provideEthiopiaBean(){    return new EthiopiaBean();  }}12345public static void main(String[] args){  CoffeeComponent coffeeComponent = DaggerCafeComponent. create(). coffeeComponent(). build();  coffeeComponent. coffeeBean(). name();  coffeeComponent. coffeeBeanMap(). get( ethiopia ). name();}12EthiopiaBeanEthiopiaBean방법이 있다 정도로 이해해 두면 좋을 것 같다. 결론: 이 정도면 dagger를 이해하고 다루기엔 부족함이 없을 것이다. 위 글은 이 포스트에서 참고하였습니다. "
    }, {
    "id": 101,
    "url": "/study_Android_DI/",
    "title": "Android DI Dagger",
    "body": "2020/12/31 - DI:  Android Devloper에서 설명하는 DI에서 설명이 잘 되어 있지만, 해당 예시에 Dagger를 적용해서 보여주진 않는다.  그래서 여기서는 커피를 내리는 동작을 하는 예시 프로그램을 수동 종속 삽입(Without DI), 간단한 Injection을 작성하여 자동 종속 삽입(With DI), 그리고 Dagger를 이용하여 종속 삽입(With Dagger) 경우를 살펴보면서 DI의 필요성을, 그리고 편의성을 이해해 보고자 한다. Setting: CoffeeMaker class우선 Coffee를 내리도록 Maker를 셋팅하고, 동작을 구현해 보자. 12345678910111213141516public class CoffeeMaker {  private final Heater heater;  private final Pump pump;  public CoffeeMaker(Heater heater, Pump pump){    this. heater = heater;    this. pump = pump;  }  public void brew(){    heater. on();    pump. pump();    System. out. println(  [_]P coffee! [_]P  );    heater. off();  }}Heater, Pump interface해당 Maker에는 Heater와 Pump가 필요하다. 이때 이 둘은 어떤 종류가 오더라도 상관이 없다. 123456// Heaterpublic interface Heater {  void on();  void off();  boolean isHot();}1234// Pumppublic interface Pump {  void pump();}A_Heater, A_Pump class그리고 A 상품을 사용하려고 한다. 12345678910111213141516171819// A Heaterpublic class A_Heater implements Heater {  boolean heating;  public A_Heater(){ }  public void on() {    System. out. println( A_Heater : ~ ~ ~ heating ~ ~ ~ );    this. heating = true;  }  public void off() {    this. heating = false;  }  public boolean isHot() {    return heating;  }}1234567891011121314// A Pumppublic class A_Pump implements Pump {  private final Heater heater;  public A_Pump(Heater heater) {    this. heater = heater;  }  public void pump() {    if (heater. isHot()) {      System. out. println( A_Pump =&gt; =&gt; pumping =&gt; =&gt; );    }  }}동작: 이제 동작을 시켜보자 Without DI우선 직접 종속 항목을 삽입해 보자. 123456public static void main(String[] args) {  Heater heater = new A_Heater(); // A_heater 를 사용해야한다는 것을 알아야 한다.   Pump pump = new A_Pump(heater); // A_pump 를 사용해야 한다는 것을 알아야 한다.   CoffeeMaker coffeeMaker = new CoffeeMaker(heater,pump);  coffeeMaker. brew();}Main에서 우리는 Heter를 A Heater로 Pump를 A Pump셋팅을 해줘야하고, 커피를 셋팅해 주는 다음 커피를 내려주는 것을 알 수 있다. With DI간단한 Injection을 만들어 자동 종속 항목 삽입을 해보자.  Injection Class1234567891011121314151617public class Injection {  public static Heater provideHeater(){    return new A_Heater();  }  public static Pump providePump(){    return new A_Pump(provideHeater());  }  public static CoffeeMaker provideCoffeeMaker(){    return new CoffeeMaker(provideHeater(),providePump());  }  public static Pump providePump(Heater heater){    return new A_Pump(heater);  }}만든 Injection을 이용하여 커피를 내려보자. 1234567891011//어떤 heater와 pump가 필요한지 몰라도 된다. Injection class에 모두 정의 되어 있다. public static void main(String[] args) {  Heater heater = Injection. provideHeater(); // A heater 가 필요한지 B heater 가 필요한지 몰라도 된다.   Pump pump = Injection. providePump(heater); // A pump가 필요한지 B pump가 필요한지 몰라도 된다.     CoffeeMaker coffeeMaker = new CoffeeMaker(Injection. provideHeater(),Injection. providePump());  coffeeMaker. brew();  // 또는 coffeemaker 자체를 injection class 에서 di를 해줄수도 있다.   Injection. provideCoffeeMaker(). brew();}Main에서 우리는 Heter와 Pump가 A인지, B인지 알 필요가 없다. 그것은 Injection에서 알아서 해준다. 결론: 구성 단계에서 관계도만 잘 구성해 놓는다면 Injection에서 실제로 할당에 필요한 작업을 자동으로 프로세스 해준다. 이게 DI를 사용하는 큰 이유중 하나이다. With Dagger그래서 이제 Dagger를 사용해보자. Android Devloper에서 설명하는 Dagger에서 Dagger에 필요한 annotation을 이해하도록 하자. Module 클래스를 만들어 의존성 관계를 설정해주자. 123456789101112@Modulepublic class CoffeeMakerModule {  @Provides  Heater provideHeater(){    return new A_Heater();  }  @Provides  Pump providePump(Heater heater){    return new A_Pump(heater);  }}그리고 해당 Module을 통해 직접 주입해주는 Component 클래스를 만들자. 이때 Component는 두가지 방법으로 주입을 해줄수 있는데 123456789@Component(modules = CoffeeMakerModule. class)public interface CoffeeComponent {  //provision method   CoffeeMaker make();  //member-injection method  void inject(CoffeeMaker coffeeMaker);}이제 주입을 해줘야 하는 항목들을 찾아 @Inject 해주도록 하자. 12345678910111213141516171819202122232425262728// CoffeeMakerpublic class CoffeeMaker {  @Inject Heater heater;  @Inject Pump pump;  public CoffeeMaker(){}  @Inject  public CoffeeMaker(Heater heater, Pump pump){    this. heater = heater;    this. pump = pump;  }  public void brew(){    heater. on();    pump. pump();    System. out. println(  [_]P coffee! [_]P  );    heater. off();  }  public Heater getHeater() {    return heater;  }  public Pump getPump() {    return pump;  }}12345678910111213141516171819// Pumppublic class A_Pump implements Pump {  private final Heater heater;  @Inject  public A_Pump(Heater heater) {    this. heater = heater;  }  public Heater getHeater() {    return heater;  }  public void pump() {    if (heater. isHot()) {      System. out. println( A_Pump =&gt; =&gt; pumping =&gt; =&gt; );    }  }}이제 모든 준비를 마쳤으니 실행하도록 하자. 1234567891011public static void main(String[] args) {  CoffeeComponent coffeeComponent = DaggerCoffeeComponent. create()  //provision method  coffeeComponent. make(). brew();  //member-injection method  CoffeeMaker coffeeMaker = new CoffeeMaker();  coffeeComponent. inject(coffeeMaker);  coffeeMaker. brew();}Dagger 동작 이해: 이제 Dagger가 어떻게 동작하는지를 살펴보고자 한다. 프로젝트를 빌드하면 Dagger는 자동으로 프로젝트 내의 Inject와 Provide로 구성해 놓은 종속 항목 그래프를 그린다. 이때 @Component로 구성된 interface에서 dagger가 그래프를 그리도록 해준다. 해당 인터페이스는 Dagger__Component로 구현된다. 또한 인터페이스에서 모듈로 연결된 class의 @Provide로 선언된 항목을 찾아 Provide__Factory를 구현한다. 그리고 @Inject로 선언된 항목을 찾아 Factory 내지는 MembersInjector를 구현한다. 여기서 주입하기 위한 방법으로 2가지를 확인 할수 있다. 한꺼번에 보여주기 위해 겹처진 두개의 방법을 하나씩 각각 쪼개보면 다음과 같다.  provision method : 파라미터가 없고 return type은 Module로부터 제공되거나 주입되는 메소드이다. 123456789101112131415161718192021222324252627public class CoffeeMaker {  private Heater heater;  private Pump pump;  public CoffeeMaker(){}  @Inject  public CoffeeMaker(Heater heater, Pump pump){    this. heater = heater;    this. pump = pump;  }  public void brew(){    heater. on();    pump. pump();    System. out. println(  [_]P coffee! [_]P  );    heater. off();  }  public Heater getHeater() {    return heater;  }  public Pump getPump() {    return pump;  }}12345@Component(modules = CoffeeMakerModule. class)public interface CoffeeComponent {  //provision method   CoffeeMaker make();}12345678public static void main(String[] args) {  CoffeeComponent coffeeComponent = DaggerCoffeeComponent. create()  coffeeComponent. make(). brew();  /* 사실 정확히는 아래와 같다.   CoffeeMaker coffeeMaker = coffeeComponent. make();  coffeeMaker. brew();  */} Member-Injection method123456789101112131415161718192021public class CoffeeMaker {  @Inject Heater heater;  @Inject Pump pump;  public CoffeeMaker(){}  public void brew(){    heater. on();    pump. pump();    System. out. println(  [_]P coffee! [_]P  );    heater. off();  }  public Heater getHeater() {    return heater;  }  public Pump getPump() {    return pump;  }}12345@Component(modules = CoffeeMakerModule. class)public interface CoffeeComponent {  //member-injection method  void inject(CoffeeMaker coffeeMaker);}1234567public static void main(String[] args) {  CoffeeComponent coffeeComponent = DaggerCoffeeComponent. create()  CoffeeMaker coffeeMaker = new CoffeeMaker();  coffeeComponent. inject(coffeeMaker);  coffeeMaker. brew();}이렇게 기본적인 Dagger 동작을 살펴 보았다. 다음은 더욱 프로그램을 발전시키고 그에따라 필요해진 기능을 적용하도록 해보려고 한다. Dagger - @Singleton, SubComponent, @Binds…. 위 글은 이 포스트에서 참고하였습니다. "
    }, {
    "id": 102,
    "url": "/study_Android_gradle/",
    "title": "Android gradle - dependencies 관리",
    "body": "2020/12/29 - Gradle: Android Studio에서 제공하는 Gradle Gradle은 android studio에서 기본적으로 제공하는 빌드 배포 도구이다. 위의 링크를 통해 자세히 알수 있다. 여기서 하고 싶은 것은 프로젝트에 필요한 라이브러리를 모듈이 추가되더라도 한꺼번에 관리할 수 있고자 한다. 이때, 기본값으로 설정된 build. gradle(project level)에서 관리하기 보다 추가로 project level의 versions. gradle을 만들어 관리하는 편이 용이하다.  versions. gradle에 한번에 관리하기. : 우선 rootProject에서 versions. gradle 생성한다. file을 #. gradle로 만들면 자동으로 gradle build script가 된다. (이름이 versions가 아니어도 된다. ) 이곳에 build. gradle(proejct level)의 repositories와 dependencies 그리고 build. gradle(module level)의 android version 및 dependencies를 관리하려 한다. 이를 위해선 알아야 할 groovy문법은 다음과 같다.  로컬 변수 : ‘def 변수명’ 으로 선언. 해당 변수는 로컬에서만 접근이 가능하다.  ext 변수 : 프로젝트 전체와 서브 프로젝트에서도 접근이 가능하다.  {} 사용 : 객체를 할당하고자 할 경우 사용한다. proejct level에서 versions. gradle을 만들어 로컬 변수에서 각각의 라이브러리 version과 dependency를 관리하여 해당 로컬 변수를 ext에 할당하여 프로젝트 전체와 서브 프로젝트에서도 접근이 가능하도록 해준다. 방법은 아래와 같다.  build. gradle(proejct level)의 buildscript에 versions. gradle을 사용할수 있도록 한다. 12345// project level build. gradlebuildscript {  apply from: 'versions. gradle'  . . . } dependencies를 관리해주기 위해 empty map을 선언해준다. 12// project level versions. gradleext. deps = [:] version과 build_version을 empty map 로컬 변수로 선언을 하고 각각의 version을 할당해준 뒤, 다시 ext. version과 ext. build_version에 할당해 준다. 이때 version과 같이 많은 라이브러리를 다룰 경우 알파벳 순으로 정렬을 해두는 것이 좋다. (deps에서도 동일하다. )123456789// project level versions. gradledef versions = [:]versions. kotlin =  1. 3. 72 ext. versions = versionsdef kotlin = [:]kotlin. stdlib =  org. jetbrains. kotlin:kotlin-stdlib:$versions. kotlin kotlin. plugin =  org. jetbrains. kotlin:kotlin-gradle-plugin:$versions. kotlin deps. kotlin = kotlin 이제 versions. gradle에 있는 값을 각 dependencies에 적용을 해준다. 123456789// module level build. gradledependencies {  implementation deps. kotlin. stdlib}// project level build. gradledependencies {  classpath deps. kotlin. plugin}또한, 라이브러리를 가져오는 repositories를 역시 versions. gradle에 집어 넣을수 있다. 이를 이용하여 maven을 통해 추가로 필요한 라이브러리 또한 version. gradle에서 관리 할수 있다. 123456// project level versions. gradledef addRepos(RepositoryHandler handler) {  handler. google()  handler. jcenter()}ext. addRepos = this. &amp;addRepos123456789// project level build. gradlebuildscript {  apply from: 'versions. gradle'  addRepos(repositories)  . . . }allprojects {  addRepos(repositories)}앞으로는 versions. gradle을 통하여 전체 모듈의 라이브러리를 관리하도록 하자. "
    }, {
    "id": 103,
    "url": "/study_Android_background_manage_-API/",
    "title": "Android 백그라운드 처리 방법",
    "body": "2020/11/26 - Service: 기본적으로 UI 스레드에서 동작하기 때문에 앱의 느려짐을 방지하기 위해 별도로 처리가 필요하다. 다른 컴포넌트와 bind를 할 수 있다. 그래서 정말로 Service가 필요한 경우가(예를들어 음악 재생 앱이나 앱 스토어 같이 Service bind가 필요한 경우) 아니면 대체로 안쓰는 것이 좋다. JobIntentService: 작업이 순차적으로 수행되며, 10분의 제한시간이 존재한다. 권한 부여가 필수 WorkManager: 대부분의 서비스로 할수 있는것을 대체 가능하며, 오래 걸리는 작업을 Worker로 구현한다. 한 번만 수행과 반복 수행 등의 동작이 가능하며, 네트워크오 배터리 상태 등으로 트리거가 가능하다. foregroundService 로도 동작할 수 있다.  Immediate:    코틀린 코루틴     자바 ExecutorService(Asynk가 안되므로)     WorkManager약간의 Delay가 있어도 된다면 그냥 WorkManager를 사용하면 된다.  Exact:    AlarmManager     WorkManager  Deferred:  WorkManager"
    }, {
    "id": 104,
    "url": "/study_Android_Service/",
    "title": "Android Service",
    "body": "2020/11/26 - ** 201126 기준 공부 지식을 가지고 작성하는 노트** 생존코딩 될 때까지 안드로이드 강의 참고 안드로이드에서 서비스가 필요한 경우: 비동기 작업을 위해 스레드를 동작한 뒤 스레드 내의 동작하고 있는 값을 다루고자 하지만 해당 앱을 종료한 이후 재시작하게 될 경우에는 해당 액티비티에서 스레드 정보는 지워졌기 때문에 접근 할 수가 없다. 이때, 서비스는 접근이 가능하다. 위와 같은 목적을 가진 앱을 구현하기 위해선 서비스가 필요하다. 앱 설치 진행시작 후 해당 화면 나가더라도 앱 설치가 계속해서 진행하는 것이나, 음악 앱에서 앱을 나가더라도 음악이 여전히 재생되는 것을 예로 들수 있다. Service: 동작을 하는 백그라운드 스레드를 구현 해야 하며, 스레드를 서비스 destory하게 될 때 null 값이 되므로 서비스를 통해 스레드 동작을 진행하게 되면 한번만 가능하게 된다. 또한 해당 서비스를 destroy하지 않으면 여전히 스레드는 남아있게 된다. IntentService -&gt; JobIntentService: 백그라운드 스레드가 필요없이 스레드와 동일한 동작을 할수 있으며, 해당 동작은 순차적으로 진행이 된다. 그리고 별다른 구문 없이 destory가 된다. IntentService는 API 30 에서 deprecated 되었다. 대신 JobIntentService를 사용해야 한다. 비슷한 동작을 하나 제한시간이 존재하며(10분), 권한부여가 필수이다. ForegroundService: 서비스를 동작을 시켜놓았지만, 다른 앱과의 메모리 충돌과 같은 여러 이슈로 안드로이드에서 해당 서비스를 Kill 할수 있다. 이때 ForGroundService를 사용하면 절대로 종료가 되지 않는다. 위와 같은 강력한 동작 때문에, 이 서비스를 사용하려면 제약이 존재한다.  ForegroundService가 동작하고 있음을 알려야 한다. (알림 아이디를 0이 아닌 값으로 설정) StartForeground 메서드를 서비스 내부에서 별도로 실행한다. foreground로 승격을 시켜야 한다. 즉 Service에서 ForegroundSerivce를 Start를 해야 한다. BindService: 다른 컴포넌트가 서비스 컴포넌트와 연결 고리를 만든다. 예를들어 음악앱과 같은 경우 서비스 단에서 음악을 실행하면 실행과 동시에 앱의 액티비티에서도 실행하고 있는 화면으로 변경되는 동작이 가능하도록 해준다. "
    }, {
    "id": 105,
    "url": "/android_app_service_clone/",
    "title": "Movie Clone Application",
    "body": "2020/11/23 - SPECAPI: 주어진 API 상세 : 앱 아키텍처: 아래와 같이 안드로이드 개발자 페이지에서 추천하는 아키텍쳐로 구성하였다.  디자인 아키텍쳐 : MVVM: DI - Koin: 다음 프로젝트에서는 Dagger-Hilt를 사용할 예정이다. NetWork - rxJava, retrofit: 현재 작업중MVVM 디자인 패턴에 맞게 다시 구축: MVVM이 아니었다…!!! MVVM의 ViewModel 기능에 맞도록 databinding과 viewbinding을 적용하자. LiveData 활용도: (MVVM의 dataBinding과 연결되어) 단순히 API의 response값만 받는 형태가 아닌, 프래그먼트 primary Key 처리 등활용도를 높이자. MediatorLiveData의 메커니즘을 이해하여 사용하자. Livecycle에 대한 이해: 특정 시점에서 fragment lifecycle이 destroy되지 않는 현상에 대한 대안으로 viewLifecycleOwner를 사용하며, background에서 observing을 필요로 하는 작업에 대하여 observeForever을 사용하는 등 여러 작업을 통해 lifecycle을 이해하며 사용하도록 하자. UI:  Statusbar와 Toolbar가 스크롤에 따라 투명도가 같이 변하는 함수 작업(이미지를 화면 전체로 채우기 위함) 리팩토링 관련 자료LinearLayout -&gt; ConstraintLayout: ConstraintLatout에 관한 글. ListAdapter: ListAdapter에 관한 글. Lifecycle: Lifecycle에 관한 글. ViewLifecycleOwner에 관한 글. LiveData: LiveData에 관한 글. "
    }, {
    "id": 106,
    "url": "/study_Kotlin_practice_10/",
    "title": "2019 KAKAO BLIND RECRUITMENT : 후보키",
    "body": "2020/10/28 - 2019 KAKAO BLIND RECRUITMENT : 후보키: programmers. co. kr 이 경우 brute force로 하나씩 검사를 하며, 중복여부 판단가지 겸해서 같이 해줘야 한다. 문제를 처음 보고 판단할 때, 다른 여타 방법이 생각나지 않는다면 보자마자 생각난 brute force 방법이 맞다. 다만 해당 문제는 설계를 효율적으로 해야 하는데, 그러기 위해서는 멱집합에 대한 이해가 필요하다. 또 조건에 맞는 튜플이 Unique한지 여부를 판단할 떄, 튜플의 각 값을 하나의 String으로 만들어 Set에서 관리를 해주면 간단하게 해결이 가능한줄 알았는데. . unique 집합 중 최소성의 조건에 맞춘 값을 찾아내는 것 또한 쉽지 않았다. 추가할 값이 min에 맞는지 확인 하는 작업이 필요하며, “012”는 “02”로 인해 최소성에 조건에 맞지 않아야 하기에 “012”contains(“02”)는 사용하지 못한다. 이러한 문제를 해결하기 위해, 먼저 최소값이기 때문에 멱집합을 크기가 적은 순서대로 정렬을 한 뒤 조건에 부합한지 들어오는 값을 직접 찾아보는 방법으로 해결을 하였다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970class Solution {  fun solution(relation: Array&lt;Array&lt;String&gt;&gt;): Int {    val arr = Array&lt;Int&gt;(relation[0]. size) { it }    var uniquePivot = relation. size    val arrPowerSet = getPowerSet(arr. toIntArray())    var uniqueSet = mutableSetOf&lt;String&gt;()    arrPowerSet. sortedBy { it. size }. forEach { set -&gt;      var checkUnique = mutableSetOf&lt;String&gt;()      relation. forEach { item -&gt;        var value =           set. forEach {          value += item[it]        }        checkUnique. add(value)      }      if(checkUnique. size == uniquePivot) {        var stringSet = set. joinToString(  )        if(isMin(uniqueSet, stringSet)) uniqueSet. add(stringSet)      }    }    return uniqueSet. size  }  private fun isMin(uniqueSet: MutableSet&lt;String&gt;, stringSet: String): Boolean {    uniqueSet. forEach{      if(isContains(it, stringSet)) return false    }    return true  }  private fun isContains(it: String, stringSet: String): Boolean {    it. forEach {      if(!stringSet. contains(it)) return false    }    return true  }  fun getPowerSet(arr: IntArray): Array&lt;IntArray&gt; {    var visited = Array(arr. size) { false }    var set = arrayListOf&lt;IntArray&gt;()    fun addArr(baseArr: IntArray, visited: Array&lt;Boolean&gt;, size: Int) {      var makeComb = arrayListOf&lt;Int&gt;()      for(i in 0 until size) {        if(visited[i]) {          makeComb. add(baseArr[i])        }      }      set. add(makeComb. toIntArray())    }    fun find(baseArr: IntArray, visited: Array&lt;Boolean&gt;, size:Int, idx: Int) {      if (idx == size) {        addArr(baseArr, visited, size)        return      }      visited[idx] = true      find(baseArr, visited, size, idx + 1)      visited[idx] = false      find(baseArr, visited, size, idx + 1)    }    find(arr, visited, arr. size, 0)    return set. toTypedArray()  }}그리고 “012”이 “02”으로 인해 최소성에 조건에 맞지 않도록 하는 방법으로 containsAll이 있음을 알게 되었다. 다만 이는 collection 힘수이므로 해당 값을 List로 바꿔서 비교하니 동일한 결과를 얻을 수 있었다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class Solution {  fun solution(relation: Array&lt;Array&lt;String&gt;&gt;): Int {    val arr = Array&lt;Int&gt;(relation[0]. size) { it }    var uniquePivot = relation. size    val arrPowerSet = getPowerSet(arr. toIntArray())    var uniqueSet = mutableSetOf&lt;List&lt;Int&gt;&gt;()    arrPowerSet. sortedBy { it. size }. forEach { set -&gt;      var checkUnique = mutableSetOf&lt;String&gt;()      relation. forEach { item -&gt;        var value =           set. forEach {          value += item[it]        }        checkUnique. add(value)      }      if(checkUnique. size == uniquePivot) {        val listSet = set. toList()        if(isMin(uniqueSet, listSet)) uniqueSet. add(listSet)      }    }    return uniqueSet. size  }  private fun isMin(uniqueSet: MutableSet&lt;List&lt;Int&gt;&gt;, set: List&lt;Int&gt;): Boolean {    uniqueSet. forEach{      if(set. containsAll(it)) return false    }    return true  }  fun getPowerSet(arr: IntArray): Array&lt;IntArray&gt; {    var visited = Array(arr. size) { false }    var set = arrayListOf&lt;IntArray&gt;()    fun addArr(baseArr: IntArray, visited: Array&lt;Boolean&gt;, size: Int) {      var makeComb = arrayListOf&lt;Int&gt;()      for(i in 0 until size) {        if(visited[i]) {          makeComb. add(baseArr[i])        }      }      set. add(makeComb. toIntArray())    }    fun find(baseArr: IntArray, visited: Array&lt;Boolean&gt;, size:Int, idx: Int) {      if (idx == size) {        addArr(baseArr, visited, size)        return      }      visited[idx] = true      find(baseArr, visited, size, idx + 1)      visited[idx] = false      find(baseArr, visited, size, idx + 1)    }    find(arr, visited, arr. size, 0)    return set. toTypedArray()  }}그런데 배열 내 멱집합을 bit계산으로 가능하다. 그렇게 되면 동일하게 bit 계산을 통하여 해당 값의 min에 대한 부합 여부를 쉽게 검사 할 수 있다! 또한, 코드량도 현저히 줄어든다…!! 1234567891011121314151617181920212223242526272829303132class Solution {  fun solution(relation: Array&lt;Array&lt;String&gt;&gt;): Int {    val pivot = relation[0]. size    val tupleSize = relation. size    val powerSet = 1 shl pivot    var set = arrayListOf&lt;Int&gt;()    for (i in 1 until powerSet) {      val checkUnique = mutableSetOf&lt;String&gt;()      for (row in 0 until tupleSize){        var value =           for(item in 0 until pivot) {          if ((i and (1 shl item)) &gt; 0) {            value += relation[row][item]          }        }        checkUnique. add(value)      }      if (checkUnique. size == tupleSize &amp;&amp; findMinSet(set,i)) set. add(i)    }    return set. size  }  private fun findMinSet(set: ArrayList&lt;Int&gt;, item: Int): Boolean {    set. forEach {      if((it and item) == it) return false    }    return true  }}"
    }, {
    "id": 107,
    "url": "/study_Kotlin_practice_9/",
    "title": "2019 KAKAO BLIND RECRUITMENT : 오픈채팅방",
    "body": "2020/10/27 - 2019 KAKAO BLIND RECRUITMENT : 오픈채팅방: programmers. co. kr 여타 문제가 다들 그렇지만 역시 풀이 과정에서는 문제 해결 방향 설정하는 것이 어렵다. 이번 문제 또한 그러했다. 풀이 과정에서 가장 핵심적인 단서는  닉네임은 유저아이디와 연결이 된다.  닉네임이 바뀌는 순간은 Enter와 Change의 명령어가 있을 경우이다. 이 두 가지인데, 이 단서를 가지고 바뀌는 마지막 닉네임을 map을 이용하여 저장하도록 한 뒤, return 문을 작성하도록 하였다. 12345678910111213141516171819class Solution {  fun solution(record: Array&lt;String&gt;): Array&lt;String&gt; {    var answer = mutableListOf&lt;String&gt;()    var rtnAnswer = mutableMapOf&lt;String, String&gt;()    val recordList = record. map {      it. split(   )    }    recordList. forEach {      if (it. size == 3) rtnAnswer[it[1]] = it[2]    }    recordList. forEach {      if (it[0] ==  Enter ) answer. add( ${rtnAnswer[it[1]]}님이 들어왔습니다.  )      else if (it[0] ==  Leave ) answer. add( ${rtnAnswer[it[1]]}님이 나갔습니다.  )    }    return answer. toTypedArray()  }}"
    }, {
    "id": 108,
    "url": "/study_Kotlin_practice_8/",
    "title": "2017 팁스다운 : 예상 대진표",
    "body": "2020/10/21 - 2017 팁스다운 : 예상 대진표: programmers. co. kr 단순 수식 문제이다. 그러나 개인적으로 처음엔 문제를 자세히 보지 않아서 그런지 헤맸다. 아래의 문제 해결 코드에서 굳이 run을 사용하지 않아도 되지만, 그냥 한번 써봤다. 1234567891011121314class Solution {  fun solution(n: Int, a: Int, b: Int): Int = run {    var count = 0    var tmpA = a    var tmpB = b    while (tmpA != tmpB) {      tmpA = (tmpA + 1) / 2      tmpB = (tmpB + 1) / 2      count++    }    count  }}"
    }, {
    "id": 109,
    "url": "/study_Kotlin_practice_7/",
    "title": "Summer/Winter Coding(~2018) : 소수 만들기",
    "body": "2020/10/21 - Summer/Winter Coding(~2018) : 소수 만들기: programmers. co. kr 배열에서 3개의 조합을 구성하여 조합의 합이 소수인지를 판단하는 문제이다. 조합을 구성하는 것을 단순히 for문으로 구성할 수 있지만, 여기서는 직접 조합 함수를 이용하였다. 12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {  fun solution(nums: IntArray): Int {    var answer = 0    getCombination(nums, 3). forEach {      if(isPrimeNumber(it. sum())) answer++    }    return answer  }  fun getCombination(arr: IntArray, num: Int): Array&lt;IntArray&gt; {    var visited = Array(arr. size) { false }    var set = arrayListOf&lt;IntArray&gt;()    fun addArr(baseArr: IntArray, visited: Array&lt;Boolean&gt;, size: Int) {      var makeComb = arrayListOf&lt;Int&gt;()      for (i in 0 until size) {        if (visited[i]) {          makeComb. add(baseArr[i])        }      }      set. add(makeComb. toIntArray())    }    fun find(baseArr: IntArray, visited: Array&lt;Boolean&gt;, start: Int, size: Int, num: Int) {      if (num == 0) {        addArr(baseArr, visited, size)        return      } else {        for (i in start until baseArr. size) {          visited[i] = true          find(baseArr, visited, i + 1, size, num - 1)          visited[i] = false        }      }    }    find(arr, visited, 0, arr. size, num)    return set. toTypedArray()  }  fun isPrimeNumber(num: Int): Boolean {    return (2. . num / 2). filter { num % it == 0 }. count() == 0  }}"
    }, {
    "id": 110,
    "url": "/study_Kotlin_practice_6/",
    "title": "연습문제 : N개의 최소공배수",
    "body": "2020/10/17 - 연습문제 : N개의 최소공배수: programmers. co. kr 처음에는 전체를 곱한 뒤, 최대공약수로 n-1번 나눠주는 것을 문제 해결 방향으로 잡았다. 그러나 이것은 테스트 케이스에서는 통과 하지만 정확히 맞지 않는 방법이기 때문에 실행 단계에서 전체 다 틀리게 된다. (테스트 케이스에만 국한해서 생각하지 말자. ) 순서대로 최소공배수를 구해가는 것이 정확한 문제 해결방법이다. 123456class Solution {  fun solution(arr: IntArray) = arr. reduce { acc, i -&gt;    acc * i / gcd(acc, i)  }  private fun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)}"
    }, {
    "id": 111,
    "url": "/study_Kotlin_practice_5/",
    "title": "연습문제 : JadenCase 문자열 만들기",
    "body": "2020/10/17 - 연습문제 : JadenCase 문자열 만들기: programmers. co. kr 단순하게 주어진 s를 공백으로 나눈 다음 joinToString으로 다시 합치면서 각각의 문자에 대하여 람다식을 적용하는데, 첫글자를 숫자가 아니면 대문자를 하도록 적용하는 방식으로 문제 해결을 하였다. 그런데 s는 알파벳과 공백문자(“ “)로 이루어져 있기 때문에, 만약 s에서 “a “로 주어질 경우 까지 생각해서 문제해결을 해야 했는데… 123456789101112131415class Solution {  fun solution(s: String) = s. split(   ). joinToString(   ) {    var rtn =       if(it !=   ) {      val first = it. substring(0. . 0)      first. toIntOrNull()?. let { number -&gt;        rtn += number      } ?: run {        rtn += first. toUpperCase()      }      rtn += it. substring(1 until it. length). toLowerCase()    }    rtn  }}코틀린에서는 capitalize를 지원한다. 12345class Solution {  fun solution(s: String) = s. toLowerCase(). split(   ). joinToString(   ) {    it. capitalize()  }}참고로, joinToString은 map의 기능도 같이 할수 있는데 위의 답안을 map을 이용할 경우 아래와 같다 12345class Solution {  fun solution(s: String) = s. toLowerCase(). split(   ). map {      it. capitalize()    }. joinToString(   )}"
    }, {
    "id": 112,
    "url": "/study_Kotlin_practice_4/",
    "title": "연습문제 : 행렬의 곱셈",
    "body": "2020/10/17 - 연습문제 : 행렬의 곱셈: programmers. co. kr 여러가지 방법 중 3 가지를 작성하고자 한다.  Array 선언부의 람다식을 이용한 방법 빈 Array를 선언하여, also와 fold를 이용한 방법 map을 이용하여 매개 arr의 index를 이용한 방법 1번 방법: Array 선언부의 (Int)는 index를 가지고 있으므로 해당 index를 이용해 계산 후 value를 return 하는 방법이다. 1234567891011class Solution {  fun solution(arr1: Array&lt;IntArray&gt;, arr2: Array&lt;IntArray&gt;) = Array&lt;IntArray&gt;(arr1. size) { i -&gt;     Array&lt;Int&gt;(arr2[0]. size) { j -&gt;        var value = 0        for(n in 0 until arr1[i]. size) {          value += (arr1[i][n] * arr2[n][j])        }        value    }. toIntArray()  }}2번 방법: 빈 배열을 선언하고 해당 빈 배열에서 also를 이용하여 배열에 값을 집어 넣은 후 배열 return 12345678class Solution {  fun solution(arr1: Array&lt;IntArray&gt;, arr2: Array&lt;IntArray&gt;) = Array(arr1. size) {    IntArray(arr2. first(). size) }. also {      for (n in arr1. indices)        for (m in arr2. first(). indices)          it[n][m] = arr2. indices. fold(0) { acc, i -&gt; acc + arr1[n][i] * arr2[i][m] }  }}3번 방법: 빈 배열을 생성하기 보다 어차피 return 배열의 크기는 mapIndexed와 fodIndexed에서 이용할 수 있으므로 fold를 이용하여 값을 계산후 return 해준다. 123456789class Solution {  fun solution(arr1: Array&lt;IntArray&gt;, arr2: Array&lt;IntArray&gt;) = arr1. map { row -&gt;      arr2[0]. mapIndexed { index, a -&gt;        row. foldIndexed(0) { idx, acc , i -&gt;          acc + i * arr2[idx][index]        }      }. toIntArray()  }. toTypedArray()}"
    }, {
    "id": 113,
    "url": "/study_Kotlin_design_5/",
    "title": "2020 카카오 인턴십 : 수식 최대화",
    "body": "2020/10/17 - 2020 카카오 인턴십 : 수식 최대화: programmers. co. kr 아마도, 대학 전공 과목에서 계산기 예제를 많이 다루기 때문에 문제 분류가 2 Level로 구분되어 있다고 생각한다. 여러문제 풀이방법이 있겠지만, 여기서는 주어진 문자열을 그대로 숫자와 연산자로 나뉘어 배열로 저장한 뒤연산자 우선순위에 따라 연산을 병렬적으로 진행하도록 하였다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class Solution {  private val order = listOf('+', '-', '*')  val orderList = listOf(listOf('+', '-', '*'), listOf('+', '*', '-'), listOf('-', '+', '*'), listOf('-', '*', '+'), listOf('*', '+', '-'), listOf('*', '-', '+'))  fun solution(expression: String): Long {    var answer: Long = 0    val strList = mutableListOf&lt;String&gt;()    var temp =       expression. forEachIndexed { idx, c -&gt;      if(c. isDigit()) temp+=c      else{        strList. add(temp)        strList. add(c. toString())        temp=        }    }    strList. add(temp)    orderList. forEach {      answer = max(answer, abs(execute(strList,it)))    }    return answer  }  fun operatorDef(a: String, b: String, op: Char): Long {    return when (op) {      '+' -&gt; {        a. toLong() + b. toLong()      }      '-' -&gt; {        a. toLong() - b. toLong()      }      '*' -&gt; {        a. toLong() * b. toLong()      }      else -&gt; return 0L    }  }  fun execute(str: List&lt;String&gt;, opList: List&lt;Char&gt;):Long {    var tmp = str    opList. forEach {      tmp = calc(tmp, it)    }    return tmp. joinToString (  ). toLong()  }  fun calc(s: List&lt;String&gt;, op: Char): List&lt;String&gt; {    val rtn = mutableListOf&lt;String&gt;()    var flag = false    for(i in s. indices) {      if(flag) {        flag = false        continue      }      if(!order. contains(s[i]. first())) {        rtn. add(s[i])      } else {        if(s[i]. first() == op) {          flag = true          val before = rtn. last()          rtn. removeAt(rtn. size-1)          rtn. add(operatorDef(before, s[i+1], op). toString())        }        else {          rtn. add(s[i])        }      }    }    return rtn  }}"
    }, {
    "id": 114,
    "url": "/study_Kotlin_practice_3/",
    "title": "연습문제 : 피보나치 수",
    "body": "2020/10/09 - 연습문제 : 피보나치 수: programmers. co. kr 숫자가 Int 범위보다 클 경우에 대한 이슈를 잘 생각해 놔야 한다. 끝 값에 filter를 하는 것이 아닌 중간 값에 filter를 해야 한다. 12345678class Solution {  fun solution(n: Int): Int {    var ans = Array(n+1) { 0 }    ans[1] = 1    for(i in 2. . n) ans[i] = (ans[i-1] + ans[i-2])%1234567    return ans[n]  }}재귀 풀이 1234class Solution {  fun solution(n: Int): Int = if(n == 1 || n == 2) 1 else fib(n, 1, 1)   tailrec fun fib(n: Int, a: Int, b: Int): Int = if(n == 1) a else fib(n - 1, b % 1234567, (a + b) % 1234567)}"
    }, {
    "id": 115,
    "url": "/study_Kotlin_practice_2/",
    "title": "연습문제 : 최댓값과 최솟값",
    "body": "2020/10/09 - 연습문제 : 최댓값과 최솟값: programmers. co. kr 문자열을 다루는 간단한 문제이지만, 표준함수를 사용하면 더욱 간단해진다. 123456class Solution {  fun solution(s: String): String {    var arr = s. split(   ). map { it. toInt() }    return  ${arr. min()} ${arr. max()}   }}123class Solution {  fun solution(s: String): String = s. split(   ). map { it. toInt() }. let {  ${it. min()} ${it. max()}  }}"
    }, {
    "id": 116,
    "url": "/study_Kotlin_design_5/",
    "title": "설계 : 튜플",
    "body": "2020/10/08 - 2019 카카오 개발자 겨울 인턴십 : 튜플: programmers. co. kr 2가지 방법이 존재한다.  요소를 List로 저장을 한 뒤, 크기 순으로 정렬하여 튜플 출력 요소의 원소를 groubBy하여 List로 저장을 한 뒤, 개수가 많은 순서대로 정렬하여 튜플 출력방법 자체는 간단한데, 이것을 구현하기 위한 과정을 잘 기억해야 한다.  첫번째 방법     요소를 저장하기 위한 기준으로 },{을 잡아 각각의 값 을 저장하되 Int형으로 저장하기 위해 한번더 map처리를 한다.    이 때, 연산속도를 높이기 위해 asSequence를 이용해 병렬적으로 처리를 해준다.    asSequence의 결과값인 TransformingSequence를 . toList()를 통해 List로 바꾼뒤 size로 정렬을 해준다.    튜플은 크기순으로 정렬된 요소들의 합집합이므로 Set의 operation인 union을 이용하여 구해준다.    123456789101112class Solution {  fun solution(s: String): IntArray {    return s. substring(2 until s. length-2)      . split( },{ )      . asSequence()      . map { it. split( , ). map { num -&gt; num. toInt() } }      . toList()      . sortedBy { it. size }      . fold(setOf&lt;Int&gt;()) { acc, list -&gt; acc. union(list) }      . toIntArray()  }} 두번째 방법     숫자 String이 아닌 값을 기준으로 모두 나눈 뒤 groupBy를 이용해 저장한다.    이 떄, 해당 값은 List&lt;Pair&lt;String, List&gt;&gt; 이므로 second의 크기를 기준으로 정렬을 해준다.    위에서 저장한 값은 자연스레 “” 값이 가장 많이 존재한다. 따라서 첫번째 값을 제외하기 위해 takeLast를 사용한다.    그리고 apply를 이용하 arrayListOf의 함수를 사용하고 있으므로, add 값을 저장하여 답을 구해준다.    123456789101112class Solution {  fun solution(s: String): IntArray = arrayListOf&lt;Int&gt;(). apply {    s. split( { ,  } ,  , )      . groupBy { it }      . toList()      . sortedByDescending { it. second. count() }      . also {        it. takeLast(it. size - 1)          . forEach { add(it. first. toInt()) }      }  }. toIntArray()}"
    }, {
    "id": 117,
    "url": "/study_Kotlin_dfs_1/",
    "title": "DFS/BFS : 타겟 넘버",
    "body": "2020/09/28 - DFS/BFS : 타겟 넘버: programmers. co. kr DFS라기 보다는 재귀를 이용한 완전탐색이라고 할수 있겠다. 그렇다는 말은 반복문으로도 풀수 있다는 말이다.  재귀를 이용한 풀이12345678910111213141516171819202122class Solution {  fun solution(numbers: IntArray, target: Int): Int {    return findNum(numbers, target)  }  fun findNum(numbers: IntArray, target: Int):Int {    var num = 0    fun dfs(numbers: IntArray, target: Int, value: Int, idx: Int) {      val len = numbers. size      if (len == idx) {        if (value == target) {          num++        }        return      }      dfs(numbers, target, value + numbers[idx], idx+1)      dfs(numbers, target, value - numbers[idx], idx+1)    }    dfs(numbers, target, 0, 0)    return num  }} 반복문을 이용한 풀이123456789class Solution {  fun solution(numbers: IntArray, target: Int): Int {  return numbers. fold(listOf(0)) { list, i -&gt;      list. run {        map { it + i } + map { it - i }      }    }. count { it == target }  }}"
    }, {
    "id": 118,
    "url": "/study_Kotlin_bf_1/",
    "title": "완전탐색 : 카펫",
    "body": "2020/09/28 - 완전탐색 : 카펫: programmers. co. kr 우선 yellow의 약수를 x, y라고 하자. 제한조건에서 brown이 정확하게 들어온다고 가정할 시, brwon은 2(x+y)+4가 될 것이다. 이때 주어진 brown과 값이 같다면 끝. 주의해야 할 것은 yellow를 기준으로 값을 찾을 때, 찾는 범주이다. 123456789101112131415161718class Solution {  fun solution(brown: Int, yellow: Int): IntArray {    var answer = intArrayOf(0, 0)    var x:Int = 0    var y:Int = 0    for( i in 1 . . yellow) {      if(yellow%i==0) {        x = i        y = yellow/i        var brownNum = 2*(x+y)+4        if(brownNum == brown) break      }    }    answer[0] = y+2    answer[1] = x+2    return answer  }}위의 풀이를 아래와 같이 더욱 간단하게 풀 수 있다. 1234567class Solution {  fun solution(brown: Int, yellow: Int): IntArray {    return (1. . yellow). filter { yellow % it == 0 }        . find{ brown == (yellow / it * 2) + (it * 2) + 4}!!        . let { intArrayOf(yellow / it + 2, it + 2)}  }}이때 find의 return형은 Int?이므로 return이 IntArray?로 만들어 진다. 그러나 문제에서는 return이 IntArray여야 하므로, 해당 조건이 들어오도록 설정을 해야 한다. 똑같은 해결 방법이지만 first를 사용하면 first의 람다식에서 null이 발생되면 Error가 되어 버리는 위와 똑같이 동작을 한다. 12345678class Solution {  fun solution(brown: Int, yellow: Int): IntArray {    return (1. . yellow)        . filter { yellow % it == 0 }        . first { brown == (yellow / it * 2) + (it * 2) + 4}        . let { intArrayOf(yellow / it + 2, it + 2)}  }}"
    }, {
    "id": 119,
    "url": "/study_Android_shortCut/",
    "title": "Android Studio 단축키",
    "body": "2020/09/28 - 아마도 IntelliJ와 비슷한 단축키 구성을 하고 있을 것으로 생각된ㄷ. 우클릭 + Generate: Override Methods 표시 Edit + Find in Path: 파일의 내용 검색 Shift + F10: Run ‘app’ Alt + Insert: Package 및 프로젝트 파일을 추가 할 떄 사용한다. Alt + Enter: Show Intention Actions - 코드 어시스트! (Ex Import) Alt + Shift + ↕: 블록 처리된 구간의 순서를 위아래로 움직인다. Ctrl + B: 해당 키워드의 선언부로 이동한다. 해당 키워드가 Resource일 경우 해당 리소스로 이동한다. (v를 잘못 누르지 말자. ) Ctrl + D: 한 문장을 복사하여 바로 밑에 붙여넣어 준다. Ctrl + /: 해당 블록 전체 주석처리 Ctrl + f: Find Ctrl + Q: 함수나 클래스의 정보를 알려준다. Ctrl + P: 후보 클래스와 파라미터의 자동 표시 Ctrl + y: 한 줄 지우기블록 처리 시 해당 블록 줄 전체 지우기 Ctrl + e: recent files - 최근 파일 리스트를 보여준다. Ctrl + k: commit Ctrl + Shift + F10: 처음 컴파일을 진행하게 될 때 사용한다. Ctrl + Shift + p: 추론된 타입을 보여준다. Ctrl + Shift + (Right or Left): 해당 포인터 기준 단어절까지 블록 처리(오른쪽, 왼쪽) Ctrl + Shift +A: find Action Ctrl + Alt + (Right or Left): Navigate -&gt; Forward or Navigate -&gt; Back Ctrl + Alt + l(L): reformat Code Ctrl + Space: Completion -&gt; Basic "
    }, {
    "id": 120,
    "url": "/study_Kotlin_hash_2/",
    "title": "해시 : 호텔 방 배정",
    "body": "2020/09/26 - 해시 : 호텔 방 배정: programmers. co. kr 해시 충돌 문제 처리를 얼마나 효율적으로 할 수 있도록 만드는 문제이다. 문제가 BFS나 이분탐색과 같은 전형적인 문제가 아니었기 때문에 생각보다 많이 어려웠다. 그래서 우선적으로 완전 탐색으로 문제를 풀고, 해당 풀이를 뼈대로 더 효율적으로 할 수 있는 방법을 찾아보았다.  완전 탐색 방법  당연히 정확성은 100%, 효율성은 14%(7개중 1개 통과)12345678910111213141516171819class Solution {  fun solution(k: Long, room_number: LongArray): LongArray {    var answer = arrayListOf&lt;Long&gt;()    val used = Array(k. toInt()+1) { false }    fun findRoom(idx: Long) {      var intIdx = idx. toInt()      if(intIdx === used. size) return      if(!used[intIdx]) {        used[intIdx] = true        answer. add(idx)      }      else findRoom(idx+1)    }    room_number. forEach {      findRoom(it)    }    return answer. toLongArray()  }}효율적으로 하기 위한 방법은  원하는 방이 이미 차있다면 다음 비어있는 번호에 대한 정보를 가지고 있어야한다.  해당 방에 대한 정보를 가지는 방법은 해시를 이용항 방법과 재귀를 이용한 방법이 있다.  재귀를 이용한 방법1234567891011121314151617class Solution {  fun solution(k: Long, room_number: LongArray): LongArray {    val used = mutableMapOf&lt;Long, Long&gt;()    return room_number. map { findRoom(it, used) }. toLongArray()  }  fun findRoom(room: Long, used: MutableMap&lt;Long, Long&gt;): Long {    used[room]?. let {      var next = findRoom(it, used)      used[room] = next + 1      return next    } ?: run {      used[room] = room + 1      return room    }  }} 해시를 이용한 방법null처리를 명확히 해줘야 해서, 조금 복잡하게 코딩처리가 되었다. 12345678910111213141516171819202122232425262728293031323334353637class Solution {  fun solution(k: Long, room_number: LongArray): LongArray {    var answer = arrayListOf&lt;Long&gt;()    val used = mutableMapOf&lt;Long, Long&gt;()    fun findRoom(idx: Long) {      used[idx]?. let {        var item = it        while(item &lt;= k) {          used[item]?. let { target -&gt;            used[target]?. let { nextTarget -&gt;              used[target] = nextTarget+1              item = nextTarget            } ?: run {              used[target] = target+1              used[idx] = target+1              answer. add(target)              return            }          } ?: run {            used[item] = item+1            used[idx] = item+1            answer. add(item)            return          }        }      } ?: run {        used[idx] = idx+1        answer. add(idx)      }    }    room_number. forEach {      findRoom(it)    }    return answer. toLongArray()  }}"
    }, {
    "id": 121,
    "url": "/study_Kotlin_sort_2/",
    "title": "정렬 : H-Index",
    "body": "2020/09/25 - 정렬 : H-Index: programmers. co. kr 문제 설명에 따르면 논문 n편 중, h편 이상 인용된 논문이 h편 이상인 h의 최대값이므로h값은 0 부터 n 사이에 존재한다. 따라서 0편 부터 n편까지 순서대로 올라가면서 해당 조건에 맞는 값을 찾으면 된다. 여기선 정확도만을 측정해서 굳이 이분탐색으로 해결하지는 않았다. 123456789101112class Solution {  fun solution(citations: IntArray): Int {    var answer = 0    for( i in 0 until citations. size+1) {      if(i &gt; citations. filter { it &gt;= i }. count() ) {        break      }      answer = i    }    return answer  }}"
    }, {
    "id": 122,
    "url": "/study_Kotlin_hash_1/",
    "title": "해시 : 위장",
    "body": "2020/09/25 - 해시 : 위장: programmers. co. kr 독립된 2개의 집합간 조합의 수를 나타낸다. 이 때, 해다 집합의 경우에서 하나를 추가해줘야 하는데 그것은 바로 안 입는 경우이다. 또한 모두 안 입는 경우는 제외하므로 결과값에서 1을 빼줘야 한다. 따라서 경우의 수를 단순히 숫자로서 계산을 하면 (집합의 원소 개수 + 1) * (집합의 원소 개수 + 1) - 1 이 된다. 12345678910111213141516171819class Solution {  fun solution(clothes: Array&lt;Array&lt;String&gt;&gt;): Int {    var clothesMap = mutableMapOf&lt;String, Int&gt;()    clothes. forEach {      if(!clothesMap. contains(it[1])) clothesMap[it[1]] = 1      else {        clothesMap[it[1]]?. let { value -&gt;          clothesMap[it[1]] = value + 1           // 굳이 이것을 하지 않고 size로 확인이 가능하다.         }      }    }    var answer = 0    answer = clothesMap. values. fold(1) { total, next -&gt;      total * (next + 1)    }    return answer-1  }}코틀린은 groupBy를 지원하는데 이를 사용하면 위의 풀이를 단 한줄에 해결할 수 있다. 12345lass Solution {  fun solution(clothes: Array&lt;Array&lt;String&gt;&gt;): Int {    return clothes. groupBy { it[1] }. values. fold(1) { acc, v -&gt; acc * (v. size + 1) } - 1  }}"
    }, {
    "id": 123,
    "url": "/study_Kotlin_dp_1/",
    "title": "동적 계획법 : N으로표현",
    "body": "2020/09/25 - 동적 계획법 : N으로표현: programmers. co. kr "
    }, {
    "id": 124,
    "url": "/study_Programming_powerset/",
    "title": "멱집합",
    "body": "2020/09/25 - 멱집합: 탐색 문제에서 멱집합을 이용해야 하는 경우가 종종 있다. 이해하고 사용하자. 부분집합: 부분집합을 구성하는 방법은 2가지가 있다.  재귀 :우선 원소를 사용여부(O/X)로 구분된다. 이는 이진트리로 구현할수 있는데. 단계를 구성하고 각 이진트리에 들어갈때마다 flag에 O,X를 기록한다. 마지막 단계에 들어가게 되면 해당 flag를 바탕으로 해당하는 set을 Array에서 찾고 powerSet에 push한다.  입력 String 출력 Array1234567891011121314151617181920212223242526272829303132333435fun main() {  var arrString =  ABCD   println(getPowerSet(arrString). contentToString())}fun getPowerSet(arrString: String): Array&lt;String&gt; {  val arr = Array(arrString. length) { it }  var visited = Array(arrString. length) { false }  var set = arrayListOf&lt;String&gt;()  fun addArr(baseArr: Array&lt;Int&gt;, visited: Array&lt;Boolean&gt;, size: Int) {    var makeComb =       for(i in 0 until size) {      if(visited[i]) {        makeComb += arrString[baseArr[i]]      }    }    set. add(makeComb)  }  fun find(baseArr: Array&lt;Int&gt;, visited: Array&lt;Boolean&gt;, size:Int, idx: Int) {    if (idx == size) {      addArr(baseArr, visited, size)      return    }    visited[idx] = true    find(baseArr, visited, size, idx + 1)    visited[idx] = false    find(baseArr, visited, size, idx + 1)  }  find(arr, visited, arrString. length, 0)  return set. toTypedArray()}12345[   ABCD, ABC, ABD, AB,   ACD, AC, AD, A, BCD,   BC, BD, B, CD, C, D, ] 입력 : IntArray, 출력 : String12345678910111213141516171819202122232425262728293031323334fun main() {  var arr = intArrayOf(1, 2, 3, 4)  println(getPowerSet(arr). contentToString())}fun getPowerSet(arr: IntArray): Array&lt;String&gt; {  var visited = Array(arr. size) { false }  var set = arrayListOf&lt;String&gt;()  fun addArr(baseArr: IntArray, visited: Array&lt;Boolean&gt;, size: Int) {    var makeComb =       for(i in 0 until size) {      if(visited[i]) {        makeComb += baseArr[i]      }    }    set. add(makeComb)  }  fun find(baseArr: IntArray, visited: Array&lt;Boolean&gt;, size:Int, idx: Int) {    if (idx == size) {      addArr(baseArr, visited, size)      return    }    visited[idx] = true    find(baseArr, visited, size, idx + 1)    visited[idx] = false    find(baseArr, visited, size, idx + 1)  }  find(arr, visited, arr. size, 0)  return set. toTypedArray()}12345[  1234, 123, 124, 12,   134, 13, 14, 1, 234,   23, 24, 2, 34, 3, 4, ] 입력 : IntArray, 출력 : Array12345678910111213141516171819202122232425262728293031323334fun main() {  var arr = intArrayOf(1, 2, 3, 4)  println(getPowerSet(arr). contentDeepToString())}fun getPowerSet(arr: IntArray): Array&lt;IntArray&gt; {  var visited = Array(arr. size) { false }  var set = arrayListOf&lt;IntArray&gt;()  fun addArr(baseArr: IntArray, visited: Array&lt;Boolean&gt;, size: Int) {    var makeComb = arrayListOf&lt;Int&gt;()    for(i in 0 until size) {      if(visited[i]) {        makeComb. add(baseArr[i])      }    }    set. add(makeComb. toIntArray())  }  fun find(baseArr: IntArray, visited: Array&lt;Boolean&gt;, size:Int, idx: Int) {    if (idx == size) {      addArr(baseArr, visited, size)      return    }    visited[idx] = true    find(baseArr, visited, size, idx + 1)    visited[idx] = false    find(baseArr, visited, size, idx + 1)  }  find(arr, visited, arr. size, 0)  return set. toTypedArray()}12345[  [1, 2, 3, 4], [1, 2, 3], [1, 2, 4], [1, 2],   [1, 3, 4], [1, 3], [1, 4], [1], [2, 3, 4],   [2, 3], [2, 4], [2], [3, 4], [3], [4], []] bit 연산 :1을 shl하여 1, 10, 100, 1000 … 과 같은 값을 구성하여 and 하면 해당 위치에 맞는 값이 나오는지를 확인이 가능하다 이를 O/X로 판단하여 값을 구성할 수 있다. 이때 공집합은 빠진다.  입력 String 출력 Array12345678910111213141516171819202122fun main() {  var arrString =  ABCD   println(getPowerSet(arrString). contentToString())}fun getPowerSet(arr: String): Array&lt;String&gt; {  var set = arrayListOf&lt;String&gt;()  val pivot = arr. length  val powerSet = 1 shl pivot  for (i in 1 until powerSet) {    var oneSet =       for(item in 0 until pivot) {      if ((i and (1 shl item)) &gt; 0) {        oneSet += arr[item]      }    }    set. add(oneSet)  }  return set. toTypedArray()}123456[  A, B, AB, C,   AC, BC, ABC, D,   AD, BD, ABD, CD,   ACD, BCD, ABCD] 입력 : IntArray, 출력 : String12345678910111213141516171819202122fun main() {  var arr = intArrayOf(1, 2, 3, 4)  println(getPowerSet(arr). contentToString())}fun getPowerSet(arr: IntArray): Array&lt;String&gt; {  var set = arrayListOf&lt;String&gt;()  val pivot = arr. size  val powerSet = 1 shl pivot  for (i in 1 until powerSet) {    var oneSet =       for(item in 0 until pivot) {      if ((i and (1 shl item)) &gt; 0) {        oneSet += arr[item]      }    }    set. add(oneSet)  }  return set. toTypedArray()}123456[  1, 2, 12, 3,   13, 23, 123, 4,   14, 24, 124, 34,   134, 234, 1234] 입력 : IntArray, 출력 : Array12345678910111213141516171819202122fun main() {  var arr = intArrayOf(1, 2, 3, 4)  println(getPowerSet(arr). contentDeepToString())}fun getPowerSet(arr: IntArray): Array&lt;IntArray&gt; {  var set = arrayListOf&lt;IntArray&gt;()  val pivot = arr. size  val powerSet = 1 shl pivot  for (i in 1 until powerSet) {    var oneSet =       for(item in 0 until pivot) {      if ((i and (1 shl item)) &gt; 0) {        oneSet += arr[item]      }    }    set. add(oneSet)  }  return set. toTypedArray()}123456[  [1], [2], [1, 2], [3], [1, 3],   [2, 3], [1, 2, 3], [4], [1, 4],  [2, 4], [1, 2, 4], [3, 4],   [1, 3, 4], [2, 3, 4], [1, 2, 3, 4]]"
    }, {
    "id": 125,
    "url": "/study_Programming_permutation/",
    "title": "순열",
    "body": "2020/09/24 - 순열과 조합: 순열과 조합은 여러 군데에서 쓰인다. 쓰이는 방법도 다양한데  각각의 배열의 값으로써 조합된 원소의 값들로써하지만 설계하는 것이 즉석에서 곧바로 할 수 있는 일이 아니기 때문에, 미리 이해하는 차원에서 만들어 놓고자 한다. 결과값 구하기: nPr -&gt; n개의 경우를 r 번 사용할 경우  nPr12345678fun permutaion(n: Int, r: Int): Int {  var value = 1    for(i in 0 until r) {    value *= n-i  }  return top/bottom}nPr 원소 구하기: 여러 방법을 제시하고자 한다.  입력 String 출력 Array12345678910111213141516171819202122232425262728293031323334353637fun main() {  var arrString =  ABCD   println(getPermutation(arrString, 3). contentToString())}fun getPermutation(arrString: String, num: Int): Array&lt;String&gt; {  var arr = IntArray(arrString. length) { it }  var visited = Array(arr. size) { false }  var picked = IntArray(arr. size-1) {0}  var set = arrayListOf&lt;String&gt;()  fun addArr(picked: IntArray) {    var makeComb =       for (i in picked) {      makeComb += arrString[i]    }    set. add(makeComb)  }  fun find(baseArr: IntArray, picked: IntArray, visited: Array&lt;Boolean&gt;, depth: Int, size: Int, num: Int) {    if (depth == num) {      addArr(picked)      return    } else {      for (i in 0 until size) {        if(!visited[i]) {          visited[i] = true          picked[depth] = baseArr[i]          find(baseArr, picked, visited, depth + 1, size, num)          visited[i] = false        }      }    }  }  find(arr, picked, visited, 0, arr. size, num)  return set. toTypedArray()}12345678[  ABC, ABD, ACB, ACD,   ADB, ADC, BAC, BAD,   BCA, BCD, BDA, BDC,   CAB, CAD, CBA, CBD,   CDA, CDB, DAB, DAC,   DBA, DBC, DCA, DCB] 입력 : IntArray, 출력 : String123456789101112131415161718192021222324252627282930313233343536fun main() {  var arr = intArrayOf(1, 2, 3, 4)  println(getPermutation(arr, 3). contentToString())}fun getPermutation(arr: IntArray, num: Int): Array&lt;String&gt; {  var visited = Array(arr. size) { false }  var picked = IntArray(arr. size-1) {0}  var set = arrayListOf&lt;String&gt;()  fun addArr(picked: IntArray) {    var makeComb =       for (i in picked) {      makeComb += i    }    set. add(makeComb)  }  fun find(baseArr: IntArray, picked: IntArray, visited: Array&lt;Boolean&gt;, depth: Int, size: Int, num: Int) {    if (depth == num) {      addArr(picked)      return    } else {      for (i in 0 until size) {        if(!visited[i]) {          visited[i] = true          picked[depth] = baseArr[i]          find(baseArr, picked, visited, depth + 1, size, num)          visited[i] = false        }      }    }  }  find(arr, picked, visited, 0, arr. size, num)  return set. toTypedArray()}12345678[  123, 124, 132, 134,   142, 143, 213, 214,  231, 234, 241, 243,   312, 314, 321, 324,   341, 342, 412, 413,   421, 423, 431, 432] 입력 : IntArray, 출력 : Array123456789101112131415161718192021222324252627282930313233343536fun main() {  var arr = intArrayOf(1, 2, 3, 4)  println(getPermutation(arr, 3). contentDeepToString())}fun getPermutation(arr: IntArray, num: Int): Array&lt;IntArray&gt; {  var visited = Array(arr. size) { false }  var picked = IntArray(arr. size-1) {0}  var set = arrayListOf&lt;IntArray&gt;()  fun addArr(picked: IntArray) {    var makeComb = arrayListOf&lt;Int&gt;()    for (i in picked) {      makeComb. add(i)    }    set. add(makeComb. toIntArray())  }  fun find(baseArr: IntArray, picked: IntArray, visited: Array&lt;Boolean&gt;, depth: Int, size: Int, num: Int) {    if (depth == num) {      addArr(picked)      return    } else {      for (i in 0 until size) {        if(!visited[i]) {          visited[i] = true          picked[depth] = baseArr[i]          find(baseArr, picked, visited, depth + 1, size, num)          visited[i] = false        }      }    }  }  find(arr, picked, visited, 0, arr. size, num)  return set. toTypedArray()}12345678[  [1, 2, 3], [1, 2, 4], [1, 3, 2], [1, 3, 4],   [1, 4, 2], [1, 4, 3], [2, 1, 3], [2, 1, 4],   [2, 3, 1], [2, 3, 4], [2, 4, 1], [2, 4, 3],   [3, 1, 2], [3, 1, 4], [3, 2, 1], [3, 2, 4],   [3, 4, 1], [3, 4, 2], [4, 1, 2], [4, 1, 3],   [4, 2, 1], [4, 2, 3], [4, 3, 1], [4, 3, 2]]"
    }, {
    "id": 126,
    "url": "/study_Programming_combination/",
    "title": "조합",
    "body": "2020/09/24 - 순열과 조합: 순열과 조합은 여러 군데에서 쓰인다. 쓰이는 방법도 다양한데  각각의 배열의 값으로써 조합된 원소의 값들로써하지만 설계하는 것이 즉석에서 곧바로 할 수 있는 일이 아니기 때문에, 미리 이해하는 차원에서 만들어 놓고자 한다. 결과값 구하기: nCr -&gt; nPr에서 중복 원소를 제외한 개수  nCr12345678910fun combination(n: Int, r: Int): Int {  var top = 1  var bottom = 1  for(i in 0 until r) {    top *= n-i    bottom *= r-i  }  return top/bottom}nCr 원소 구하기: 여러 방법을 제시하고자 한다.  입력 String 출력 Array1234567891011121314151617181920212223242526272829303132333435fun main() {  var arrString =  ABCD   println(getCombination(arrString, 2). contentToString())}fun getCombination(arrString: String, num: Int): Array&lt;String&gt; {  val arr = Array(arrString. length) { it }  var visited = Array(arrString. length) { false }  var set = arrayListOf&lt;String&gt;()  fun addArr(baseArr: Array&lt;Int&gt;, visited: Array&lt;Boolean&gt;, size: Int) {    var makeComb =       for(i in 0 until size) {      if(visited[i]) {        makeComb += arrString[baseArr[i]]      }    }    set. add(makeComb)  }  fun find(baseArr: Array&lt;Int&gt;, visited: Array&lt;Boolean&gt;, start: Int, size:Int, num: Int) {    if (num == 0) {      addArr(baseArr, visited, size)      return    } else {      for(i in start until baseArr. size){        visited[i] = true        find(baseArr, visited, i+1, size, num-1)        visited[i] = false      }    }  }  find(arr, visited, 0, arrString. length, num)  return set. toTypedArray()}1[AB, AC, AD, BC, BD, CD] 입력 : IntArray, 출력 : String12345678910111213141516171819202122232425262728293031323334fun main() {  var arr = intArrayOf(1, 2, 3, 4)  println(getCombination(arr, 2). contentToString())}fun getCombination(arr: IntArray, num: Int): Array&lt;String&gt; {  var visited = Array(arr. size) { false }  var set = arrayListOf&lt;String&gt;()  fun addArr(baseArr: IntArray, visited: Array&lt;Boolean&gt;, size: Int) {    var makeComb =       for(i in 0 until size) {      if(visited[i]) {        makeComb += baseArr[i]      }    }    set. add(makeComb)  }  fun find(baseArr: IntArray, visited: Array&lt;Boolean&gt;, start: Int, size:Int, num: Int) {    if (num == 0) {      addArr(baseArr, visited, size)      return    } else {      for(i in start until baseArr. size){        visited[i] = true        find(baseArr, visited, i+1, size, num-1)        visited[i] = false      }    }  }  find(arr, visited, 0, arr. size, num)  return set. toTypedArray()}1[12, 13, 14, 23, 24, 34] 입력 : IntArray, 출력 : Array12345678910111213141516171819202122232425262728293031323334fun main() {  var arr = intArrayOf(1, 2, 3, 4)  println(getCombination(arr, 2). contentDeepToString())}fun getCombination(arr: IntArray, num: Int): Array&lt;IntArray&gt; {  var visited = Array(arr. size) { false }  var set = arrayListOf&lt;IntArray&gt;()  fun addArr(baseArr: IntArray, visited: Array&lt;Boolean&gt;, size: Int) {    var makeComb = arrayListOf&lt;Int&gt;()    for (i in 0 until size) {      if (visited[i]) {        makeComb. add(baseArr[i])      }    }    set. add(makeComb. toIntArray())  }  fun find(baseArr: IntArray, visited: Array&lt;Boolean&gt;, start: Int, size: Int, num: Int) {    if (num == 0) {      addArr(baseArr, visited, size)      return    } else {      for (i in start until baseArr. size) {        visited[i] = true        find(baseArr, visited, i + 1, size, num - 1)        visited[i] = false      }    }  }  find(arr, visited, 0, arr. size, num)  return set. toTypedArray()}1[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]"
    }, {
    "id": 127,
    "url": "/study_Kotlin_sort_1/",
    "title": "정렬 : 가장 큰 수",
    "body": "2020/09/16 - 정렬 : 가장 큰 수: programmers. co. kr 문제의 컨셉을 잘 이해하고 해결 방향을 잡아야 문제 풀이가 쉬워진다. 처음 문제 해결 방향을 자리수가 달라질 때, 큰 값을 구하려고 생각을 한다면 문제가 복잡해 진다. 이럴땐 단순히 내림차순으로 정렬을 하는데, 해당 정렬의 기준을 어떻게 하면 문제에 맞게 될 것인지를 생각하도록 해야한다. 문제 해결을 위한 사고력이 가장 중요했던 문제. 그런데 문제 풀이 자체는 쉬웠지만 런타임 오류를 해결하지 못해서 시간이 많이 걸렸다. 오류는 Comparator의 동작원리를 숙지하지 못해서 일어났다. Comparator 인터페이스에 존재하는 compare를 kotlin은 아래와 같이 설명한다. 1abstract fun compare(a: T, b: T): IntCompares its two arguments for order. Returns zero if the arguments are equal, a negative number if the first argument is less than the second, or a positive number if the first argument is greater than the second. 같으면 0을 return 한다. 단순히 0 또는 -1이면 sort가 되지 않으므로 같아도 -1로 인식하도록 했더니, 런타임 오류가 발생하였다. 이를 방지하기 위해 0을 입력을 해주던가, 사실 그냥 compareTo를 사용하면 한줄에 해결이 가능하다.  런타임 오류 풀이123456789101112class Solution {  fun solution(numbers: IntArray): String {    var answer =       numbers. sortedWith(Comparator { a: Int, b: Int -&gt;      when {         $b$a  &gt;  $a$b  -&gt; 1        else -&gt; -1      }    }). forEach{ answer += it }    return if(answer[0] == '0')  0  else answer  }} 문제 풀이12345678910111213class Solution {  fun solution(numbers: IntArray): String {    var answer =       numbers. sortedWith(Comparator { a: Int, b: Int -&gt;      when {         $b$a  &gt;  $a$b  -&gt; 1         $b$a  ==  $a$b  -&gt; 0        else -&gt; -1      }    }). forEach{ answer += it }    return if(answer[0] == '0')  0  else answer  }} compareTo 이용123456789class Solution {  fun solution(numbers: IntArray): String {    var answer =       numbers. sortedWith(Comparator { a: Int, b: Int -&gt;       $b$a . compareTo( $a$b )    }). forEach{ answer += it }    return if(answer[0] == '0')  0  else answer  }}"
    }, {
    "id": 128,
    "url": "/study_Kotlin_greedy_2/",
    "title": "탐욕법 : 조이스틱",
    "body": "2020/09/15 - 탐욕법(Greedy) : 조이스틱: programmers. co. kr 이번 문제를 풀어보고 난 후, Greedy 문제는 코딩테스트에서 쉽게 문제로 제출되기 어렵다는 결론을 내게 되었다. 이 경우에서 해당 알고리즘이 최적해를 보장하지 않기 떄문인데, 어디까지를 정답으로 할지 애매하다. 우선 조이스틱의 위 아래에 소요되는 결과값은 동일한데, 특정 조건에서 죄로 움직일지, 우로 움직일지 구분하고자 할때이 문제의 정답은 default로 오른쪽으로 이동하면서 ‘A’란 문자가 등장하면 다음 ‘A’ 나올때 까지의 거리를 잰후 해당 거리가 왼쪽으로 이동할 떄 소요되는 거리와 비교하여 나오는 값중 가장 작은 거리를 추가해 주면 된다. (어째서 이게 정답인지는 잘 모르겠지만 일단 정답은 그러하다. )그래서 해당 답안에 아래와 같은 사례를 대입해보면 최적해가 아니라는 것은 금방 알 수 있다. 12345678910111213141516171819202122232425262728class Solution {  fun solution(name: String): Int {    var answer = 0    val updownDiff = intArrayOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)    name. forEach {      answer += updownDiff[it - 'A']    }    return answer + findMinPoint(name)  }  fun findMinPoint(name: String): Int {    var rowPoint = name. length-1    for(i in name. indices) {      if(name[i] == 'A') {        var nextIdx = i+1        var countA = 0        while(nextIdx &lt; name. length &amp;&amp; name[nextIdx] =='A') {          nextIdx++          countA++        }        val left = (i -1) * 2 + (name. length -1 -i -countA)        rowPoint. coerceAtMost(left)      }    }    return rowPoint  }}아닌 사례 123456BBABA → 6BBBAAB → 8BBAABAA → 7BBAABBB → 10BBAABAAAA → 7BBAABAAAAB → 10"
    }, {
    "id": 129,
    "url": "/study_Kotlin_greedy_1/",
    "title": "탐욕법 : 큰 수 만들기",
    "body": "2020/09/15 - 탐욕법(Greedy) : 큰 수 만들기: programmers. co. kr Greedy 알고리즘 문제는 얼마나 효과적인 제한 조건을 설정하고, 해당 조건을 구현할수 있는 지를 판단하는 것 같다. 이 문제 또한 그러한데, 자릿 수가 정해져 있기 때문에 빼고자 하는 숫자의 자리의 범주를 정할수 있고, 그 숫자를 빼면서 진행해 가면된다. 여기서 문제 해결을 위한 두가지 방법이 있다.  정해지는 자리의 범주를 지정하고 그 범주 내의 max값의 index를 구하는 방법. 이것은 다시 두가지 갈래로 방법이 나뉜다.      큰 수로 만들어지도록 숫자를 제거하면서 진행   큰 수로 만들어지는 숫자를 뽑으면서 진행    스택을 사용.  자릿 수에 의해 자리의 범주가 정해지는데, 스택을 사용한다면 낮은 자리 부터 검사가 진행되도록 강제할수 있게 된다. 1번 에서 큰 수로 만들어지도록 숫자를 제거하면서 진행을 하게 되면 치명적인 문제점이 존재하는데, 대상 문자의 길이와 제거하고자 하는 글자 수의 차이가 결국 같아져서 drop(-1)을 입력하게 된다. 이 경우를 추가적으로 제외해 줘야 한다. 만약 문제로 나와서 해결하다보면 문제점을 결국에는 찾지 못하리라고 생각이 드는 지점. 1. 자리의 범주를 지정 숫자를 제거하면서 진행12345678910111213141516171819202122232425262728class Solution {  fun solution(number: String, k: Int): String {    return makeBigNum(number, k)  }  private fun makeBigNum(number: String, k: Int, fixedStr: String =    ): String {    if(k == 0) return fixedStr + number    if(number. length-1 == k) return fixedStr + number. maxBy { it. toInt()}. toString()     // 추가 조건    var choiceStr = number. dropLast(number. length - k-1)    val dropIdx: Int = findIndex(choiceStr)    return if (dropIdx == 0) makeBigNum(number. drop(1), k, fixedStr + number. first())        else makeBigNum(number. drop(dropIdx), k-dropIdx, fixedStr)  }  private fun findIndex(choiceStr: String): Int {    // 추가 함수    var max = 0    var idx = 0    for(i in choiceStr. indices) {      var value = choiceStr[i]. toInt()      if(max &lt; value ) {        max = value        idx = i      }    }    return idx  }} 숫자를 뽑으면서 진행여기서 생각해 볼만한 지점은 아래와 같다.  재귀로 풀게되면 수행 시간이 늘어가는 것으로 판단이 된다. 아래의 코드에 findIndex는 단순히 max index를 찾는 함수인데, 이를 indexOf와 maxBy로 해결하게 되면 시간 초과가 나오게 된다. 반복문으로 하게 되면 비슷한 매커니즘으로 동작하는 문제이면서, indexOf와 max를 사용했음에도 절반의 속도의 향상이 있었다.  어떤 결과값이 null일 수도 있는 경우 kotlin에서는 해당 null 처리를 꼭 하도록 요구를 하는데, 이를 let으로 쉽게 처리가 가능하다. 잘 숙지해두자. 123456789101112131415161718class Solution {  fun solution(number: String, k: Int): String {    var answer =       var stringSize = number. length - k    var index = 0    val list = mutableListOf&lt;Char&gt;()    while (stringSize &gt; 0) {      val string = number. substring(index, number. length - (stringSize - 1))      string. max()?. let {max -&gt;        index += string. indexOf(max) + 1        list. add(max)      }      stringSize -= 1    }    answer = list. joinToString(  )    return answer  }}array로 만들어서 with를 사용해 풀수도 있다. 123456789101112131415161718192021222324252627class Solution {  fun solution(number: String, k: Int): String {    val answerBuilder = StringBuilder()    with(number. toCharArray()) {      var remainLetterCount = number. length - k      var left = 0      while(remainLetterCount != 0) {        if(remainLetterCount == size - left) {          for(eachIndex in left . . size - 1) answerBuilder. append(this[eachIndex])          return answerBuilder. toString()        }        var frontSubMaxValue = '/'        var frontSubMaxIndex = -1        for(eachIndex in left . . size - remainLetterCount) {          if(frontSubMaxValue &lt; this[eachIndex]) {            frontSubMaxValue = this[eachIndex]            frontSubMaxIndex = eachIndex          }        }        answerBuilder. append(frontSubMaxValue)        remainLetterCount--        left = frontSubMaxIndex + 1      }    }    return answerBuilder. toString()  }}2. 스택을 사용stack에서도 joinToString()을 사용할 수 있다. 만약 자릿수에 따라 크기가 결정이 되었는데도, 빼야할 숫자가 여전히 남아 있다면이미 정렬이 되어 있으므로 뒤에서 부터 빼면 된다. 즉 그냥 앞에서 부터 substring 하면 된다. 123456789101112131415161718192021class Solution {  fun solution(number: String, k: Int): String{    var stack = Stack&lt;Char&gt;()    var count = 0    for( i in number. indices) {      if(stack. isEmpty()) {        stack. push(number[i])        continue      }      while(stack. peek() &lt; number[i]) {        stack. pop()        count++        if(count == k) return stack. joinToString(  ) + number. substring(i, number. length)        if(stack. isEmpty()) break      }      stack. push(number[i])    }    return stack. joinToString(  ). substring(0, number. length-k)  }}"
    }, {
    "id": 130,
    "url": "/study_Kotlin_design_4/",
    "title": "설계 : 괄호변환",
    "body": "2020/09/14 - 2020 KAKAO BLIND RECRUITMENT : 괄호 변환: programmers. co. kr 주어진 조건을 가지고 설계를 해낼수 있는지 파악하기 위함이 목적이라고 생각이 된다. 여기서 시간을 많이 잡아먹지 않도록 해야 하는데, 그러기 위한 방법은 하나 뿐이라고 생각한다. 정말 여러문제를 많이 풀어봐야 한다. 빠른 시간내에 해결하려면 문자열, 배열, List, map 등 을 다룰때 조건에 맞게 사용할 수 있는 각종 함수와 언어의 제약 조건을 잘 파악해야 하는데,이것은 단순한 암기가 아닌 여러 문제를 풀면서 나오는 노하우라고 할수 있기 때문이다. 풀이 과정은 특별할 것 없이 지문에 맞는 기능을 구현 했는지 확인하면서 설계해 나가면 된다. 이때 주의할 점은 지문의 요구를 정확하게 파악하고 있어야 한다. 아래의 답안에서 reverseStr을 reversed()를 사용하지 않고 map을 사용한 이유는 지문에서의 요구가 역순으로 정렬하는 것이 아닌해당 값을 뒤집는 것이기 때문이다. 여기서 틀린 사람들이 많을 것으로 예상 된다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556class Solution {  fun solution(p: String): String {    return if(checkCollect(p)) p else makeCollect(p)  }  private fun makeCollect(p: String): String {    val balanceIdx = checkBalance(p)    return if(balanceIdx &gt;= 0) {      var subStr = p. substring(0 until balanceIdx)      if (checkCollect(subStr)) subStr + makeCollect(p. drop(balanceIdx))      else  (  + makeCollect(p. drop(balanceIdx)) +  )  + reverseStr(subStr)    } else     }  private fun reverseStr(subStr: String): String {    return if(subStr. length &lt;= 2)    else subStr. drop(1). dropLast(1). map { if(it == '(') ')' else '(' }. joinToString()  }  private fun checkCollect(subStr: String): Boolean {    val stack = Stack&lt;Char&gt;()    val first = subStr. first()    if(first == ')') return false    stack. push(first)    var flag = true    for(i in 1 until subStr. length) {      when {        stack. isEmpty() -&gt; {          if(subStr[i] == ')')return false else stack. push(subStr[i])        }        stack. peek() == subStr[i] -&gt; {          stack. push(subStr[i])        }        else -&gt; stack. pop()      }    }    return stack. isEmpty()  }  private fun checkBalance(p: String): Int {    if( p ==   ) return -1    val stack = Stack&lt;Char&gt;()    stack. push(p. first())    var count = 1    for(i in 1 until p. length) {      if(stack. isEmpty()) return count      var compare = stack. peek()      if( compare == p[i] ) stack. push(p[i])      else stack. pop()      count++    }    return count  }}"
    }, {
    "id": 131,
    "url": "/study_Kotlin_bruteforce_1/",
    "title": "완전탐색 : 문자열 압축",
    "body": "2020/09/12 - 2020 KAKAO BLIND RECRUITMENT : 문자열 압축: programmers. co. kr 문제를 잘 살펴보면 조건이 매우 제한적이며, (abcdab 압축 시 abcdab가 되는 것이지 2abcd가 되는 것이 아니다. ) 직접 해보는 방법 밖에 풀이 방법이 생각나지 않는다. 이럴 땐 정말 직접 해봐야 된다. (이래서 이분 탐색과 완전 탐색을 파악하기 어렵게 다가온다. ) 쉽게 생각하면 효율성을 체크하지 않는 이상 오히려 완전 탐색을 하는 것이 정확할 때가 많으니 염두해 두자. 따라서 직접 구현을 해야 하는 것인데, 이는 다시 돌아와 문자열을 잘 다룰수 있는지 판단하기 위해서 나온 문제가 되는 것이다. 여러가지 방법이 있다. 그 중에서 2가지를 제시하고자 하는데 사실, 어쨋든 문자열을 어떻게 다루는 지를 보게 되므로 풀이 방식은 상관이 없다.  직접 압축된 단어를 만드는 방법 압축된 단어와 해당 개수를 가진 Data 클래스를 만들어 배열로 저장하는 방법직접 압축된 단어를 만드는 방법 min 값을 얻기 위해 초기화를 시킬땐 Int. MAX_VALUE가 있다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution {  fun solution(s: String): Int {    var answer = 99999    val len = s. length    var str = s. drop(0)    var present: String    var count: Int    var makeStr:String    if(len == 1) return 1    for(i in 1. . len/2){      present =         makeStr =         count = 0      var str = s. drop(0)      while(!(str. isNullOrEmpty())) {        var now = str. let {          if (it. length &lt; i + 1) it else it. slice(0 until i)        }        str = str. drop(i)        if(present != now) {          var countString = if(count &lt; 2)    else count. toString()          makeStr += countString + present          present = now          count = 1        } else {          count++        }        if(str. isEmpty()) {          makeStr += if(present != now) {            var countString = if(count &lt; 2)    else count. toString()            countString + present + now          } else {            var countString = if(count &lt; 2)    else count. toString()            countString + present          }        }      }      answer = answer. coerceAtMost(makeStr. length)    }    return answer  }}Data 클래스를 이용하는 방법 1234567891011121314151617181920212223242526272829303132333435class Solution {  data class Word(    val word : String,    var count : Int = 1  )  fun solution(s: String): Int {    var answer = Int. MAX_VALUE    for(space in 1. . s. length) {      val compressedWordList = LinkedList&lt;Word&gt;()      var startIndex = 0      var endIndex = 0      while(endIndex != s. length) {        endIndex = (startIndex + space). let {          if(it &gt; s. length) s. length          else it        }        val currentWord = s. substring(startIndex, endIndex)        if(compressedWordList. isEmpty() ||          compressedWordList. peekLast(). word != currentWord) {           compressedWordList. add(Word(currentWord))        }        else compressedWordList. peekLast(). count++        startIndex = endIndex      }      val length = compressedWordList. fold(0) {        acc, word -&gt;        acc + word. word. length + if(word. count == 1) 0 else {          word. count. toString(). length        }      }      if(length &lt; answer) answer = length    }    return answer  }}"
    }, {
    "id": 132,
    "url": "/study_Kotlin_stack&queue_3/",
    "title": "스택/큐 : 다리를 지나는 트럭",
    "body": "2020/09/11 - 스택/큐 : 다리를 지나는 트럭: programmers. co. kr 스택/큐로 구분지어져 있으나, 나는 이것을 배열로 풀었다. 큐를 사용했더라면 더욱 쉽게 풀었을 것이다. 문제 해결을 위해 고민했던 지점은 다음과 같다.  대기 트럭에서 다리를 건너는 트럭 배열로 옮길 때, 시간당 소요되는 다리 길이 처리 방법     Pair에 트력 무게와, 다리 길이를 함께 저장하고, 저장된 다리 길이는 타이밍마다 1씩 줄어들도록 했다.     대기 트럭 -&gt; 다리를 건너는 트럭, 다리를 건너는 트럭 -&gt; 다리를 지난 트럭 으로 옮길때. 순서대로 처리 하는 방법     순서를 맞추면서 Bound에서 벗어난 exception를 isNotEmpty로 막고자 하였다.    123456789101112131415161718192021222324252627282930class Solution {  fun solution(bridge_length: Int, weight: Int, truck_weights: IntArray): Int {    var answer = 0    var waitingTruck = truck_weights. toMutableList()    var leftedTruck = arrayListOf&lt;Int&gt;()    var movingTruck : MutableList&lt;Pair&lt;Int,Int&gt;&gt; = arrayListOf()    val size = truck_weights. size    var currentWeight = 0    var truckIndex = 0    while(leftedTruck. size &lt; size) {      movingTruck = movingTruck. map { Pair(it. first, it. second-1)}. toMutableList()      if(movingTruck. isNotEmpty()) {        if(movingTruck. first(). second == 0) {          leftedTruck. add(movingTruck. first(). first)          movingTruck = movingTruck. drop(1). toMutableList()        }      }      if(waitingTruck. isNotEmpty()) {        if(movingTruck. sumBy { it. first } + waitingTruck. first() &lt;= weight) {          movingTruck. add(Pair(truck_weights[truckIndex++], bridge_length))          waitingTruck = waitingTruck. drop(1). toMutableList()        }      }      answer++    }    return answer  }}더 나은 풀이: 이 문제를 쉽게 해결하기 어렵게 하는 부분은 다리를 건너는 동안 경과 시간이 지나야 하며 다리를 건너는 동작과 다리를 지나는 동작은 먼저 다리를 건너고, 대기 트럭에서 다리를 건너러 와야하는 순서가 존재한다는 점이다. 그래서 기존 풀이에서는 새로 배열을 만들어 다리를 건너는 경과 정보를 지니게 했지만 그것은 로직을 더욱 복잡하게 한다. 여기서는 그것보다 하나의 큐를 다리를 건너는 트럭의 정보를 가지게 하며, 조건 상 다리에 들어오지 못할 경우 해당 경과를 간직하게 하기 위해 무의미한 동작을 하나 추가해 주는 방법으로 해결하였다. 무의미한 동작을 0으로 하는 이유는 다리 내의 무게를 파악하고자 할 때, 영향을 주지 않게 하기 위함이다. 1234567891011121314151617181920212223242526class Solution {  fun solution(bridge_length: Int, weight: Int, truck_weights: IntArray): Int {    var answer = 0    val q : Queue&lt;Int&gt; = LinkedList()    var present = 0    var last = 0    var passed = truck_weights. size    if(bridge_length == 1)      return truck_weights. size    for(i in 0. . bridge_length-1){      q. add(0)    }    while(last &lt; truck_weights. size){      answer++      present -= q. remove()      if(present + truck_weights[last] &lt;= weight){        q. add(truck_weights[last])        present += truck_weights[last]        last++      }      else        q. add(0)    }    return answer+bridge_length;  }}해당 대기 트럭 또한 Queue로 만들어 다루게 되면 truck_weights의 빈 배열 인덱스의 위험을 줄일 수 있다. 또한 해당 queue 배열 내의 sum() 함수를 사용하면 불 필요한 변수를 추가하지 않아도 되게 된다. 123456789101112131415161718192021class Solution {  fun solution(bridge_length: Int, weight: Int, truck_weights: IntArray): Int {    var answer = 0    val bridgeQueue: Queue&lt;Int&gt; = LinkedList(List(bridge_length){0})    val waitingQueue: Queue&lt;Int&gt; = LinkedList(truck_weights. toList())    while (bridgeQueue. isNotEmpty()) {      answer++      bridgeQueue. poll()      if (waitingQueue. isNotEmpty()) {        if (bridgeQueue. sum() + waitingQueue. peek() &lt;= weight) {          bridgeQueue. add(waitingQueue. poll())        } else {          bridgeQueue. add(0)        }      }    }    return answer  }}"
    }, {
    "id": 133,
    "url": "/study_Kotlin_stack&queue_2/",
    "title": "스택/큐 : 기능개발",
    "body": "2020/09/11 - 스택/큐 : 기능개발: programmers. co. kr 스택/큐로 구분지어져 있으나, 정확히는 FIFO의 컨셉만 가지고 있는 배열을 다루는 문제라고 생각한다. 그렇게 어렵지 않는 풀이라 문제와 풀이를 읽어보면 바로 이해가 될 것이다. 그것 보다도 해당 문제를 풀어가면서 kotlin에서 배열을 다룰 때, 자바스크립트와 비교해 차이점에 대해 알아보고자 한다.    배열에서 해당 배열의 size를 넘어갈때, 자바스크립트는 undefined를 return 하지만 코틀린은 범위가 넘어간 exception을 발생한다. 따라서 코틀린에서 배열을 while문에서 다룰 때, exception이 넘어가지 않도록 주의를 해야 한다.     자바스크립트의 splice는 코틀린에서 drop으로 기능을 대체할수 있을것 같다. 그러나 drop은 List를 return 하므로 자료형 변환에 주의해야 한다. (물론 단순히 toIntArray()와 같은 함수만 추가해 주면 되는 것이지만)     toMutableList()로 mutable한 list로 변환이 가능하다.  123456789101112131415161718192021222324252627class Solution {  fun solution(progresses: IntArray, speeds: IntArray): IntArray {    var answer = arrayListOf&lt;Int&gt;()    var nextStep = progresses. toMutableList()    var speedsList = speeds. toList()    while(nextStep. isNotEmpty()) {      speedsList. forEachIndexed { index, i -&gt;        nextStep[index] += i      }      if(nextStep. first() &gt;= 100) {        var count = 0        for(i in nextStep) {          if(i&lt;100) break          count++        }        answer. add(count)        nextStep = nextStep. drop(count). toMutableList()        speedsList = speedsList. drop(count)      }    }    return answer. toIntArray()  }}다른 풀이: 진척 속도를 완성되는데 소요되는 날짜를 계산하여 배열로 다시 만든 후 해당 배열의 첫번째 값을 max로 하여 연속적인 다음 값이 max값보다 큰 개수를 구하며 해당 값을 answer에 넣는다. 123456789101112131415161718192021222324252627class Solution {  fun solution(progresses: IntArray, speeds: IntArray): IntArray {    val answer : MutableList&lt;Int&gt; = arrayListOf()    val days = progresses    for(i in 0 until progresses. size){      days[i] = ((100 - progresses[i])/speeds[i])    }    var max = days[0]    var releaseCount = 1    for(i in 1 until days. size){      if(max &lt; days[i]){        answer. add(releaseCount)        releaseCount = 1        max = days[i]      }else{        releaseCount ++      }    }    answer. add(releaseCount)    return answer. toIntArray()  }}"
    }, {
    "id": 134,
    "url": "/study_Kotlin_practice_1/",
    "title": "연습 문제 : 멀쩡한 사각형",
    "body": "2020/09/10 - Summer/Winter Coding(2019) : 멀쩡한 사각형: programmers. co. kr 우선 서로소인 사각형의 대각선을 생각해 보자. 서로소인 관계를 설정하는 이유는, 그렇지 않을 때 대각선은 나뉘어지는 부분이 있기 때문이다. 예를들어 5X4인 사각형(서로소인 관계의 사각형)의 대각선이 칠해진 개수는 □□□■■□□■■□□■■□□■■□□□ □□□□■□□□■■□□■■□■■■□□ □□□□■□□□□■□□□■■■■■■□ □□□□■□□□□■□□□□■■■■■■ 5+4-1 = 8개 가로 + 세로 -1 이 대각선에 의해 칠해진 개수가 된다. 그렇다면 m × n 사각형에서 m과 n의 최대공약수가 a라고 할 떄, m = ab, n = ac 라고 할 수 있다. (b와 c는 서로소) 그렇게 되면 m × n의 사각형의 넓이는 a² × bc 이며 이는 b × c의 사각형이 a²개가 있다고 생각할 수 있다. 이 때, b × c의 사각형을 1 × 1 의 사각형으로 치환을 한다면, a × a 의 정사각형이 있다고 할수 있으며, a × a 정사각형의 대각선이 지나가는 사각형의 개수는 a개가 된다. 따라서 b × c의 사각형에서 대각선에 의해 칠해진 사각형 개수는 b+c-1 이며이는 다시 m × n의 사각형의 경우 a(b+c-1)가 된다. a(b+c-1) = ab+ac-a 이므로 [가로 + 세로 - 가로와 세로의 최대공약수]가 대각선이 칠해진 사각형의 개수이다. 12345678910111213class Solution {  fun solution(w: Int, h: Int): Long {    var gcd: Int = 1    for(i in Math. min(w, h) downTo 2) {      if(w % i == 0 &amp;&amp; h % i == 0) {        gcd = i        break      }    }       return w. toLong()*h. toLong()-w. toLong()-h. toLong()+gcd. toLong()    //숫자는 모르니 한번에 바꾸기 보다 부분별로 다루도록 하자.   }}수학적 사고력을 요하는 문제. "
    }, {
    "id": 135,
    "url": "/study_Programming_BFS&DFS/",
    "title": "Graph - DFS/BFS",
    "body": "2020/09/10 - BFS와 DFS: 그래프를 가지고 BFS와 DFS를 통해 전체 노드를 순환해보자. 편의상 그래프 중 무방향 그래프를 대상으로 하고자 한다.       Vertex   Edge         8   [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [5, 8], [6, 8], [7, 8]]   배열과 리스트 둘다 가능하다. 그래서 두개의 사례 모두 작성해 놓겠지만, 아마도 리스트를 주로 쓸것 같다. DFS:  노드를 설정한 방향대로 끝까지 간 뒤 가장 최근으로 backtacking을 진행하여 해당 방향 끝까지 보내며 전체 탐색을 하는 방법 재귀 호출 방법과 스택을 사용한 방법이 있다. 1→2→4→8→5→(8)→6→3→(6)→(8)→7→(8)→(4)→(2)→(1)배열 재귀12345678910111213141516fun dfsSearch(arr: Array&lt;Array&lt;Int&gt;&gt;, start: Int) {  val visited = Array(arr. size) { false }  fun recDfs(index: Int) {    visited[index] = true    print( $index  )    arr[index]. forEachIndexed {index, item -&gt;      if(item == 1) {        if(!visited[index]) recDfs(index)      }    }    return  }  return recDfs(start)}dfsSearch(arr, 1)11 2 4 8 5 6 3 7  스택123456789101112131415161718192021222324252627282930313233fun dfsSearch(arr: Array&lt;Array&lt;Int&gt;&gt;, start: Int) {  val visited = Array(arr. size) { false }  val stack = Stack&lt;Int&gt;()  fun stackDfs(index: Int) {    stack. push(index)    var flag: Boolean    visited[index] = true    print( $index  )    var value:Int    while(stack. isNotEmpty()) {      value = stack. peek()      flag = false      run loop@ {        arr[value]. forEachIndexed{ index, item -&gt;          if(item == 1) {            if(!visited[index]) {              stack. push(index)              print( $index  )              visited[index] = true              flag = true              return@loop            }          }        }      }      if(!flag) stack. pop()    }    return  }  return stackDfs(start)}dfsSearch(arr, 1)11 2 4 8 5 6 3 7 리스트 재귀1234567891011121314fun dfsSearch(list: List&lt;ArrayList&lt;Int&gt;&gt;, start: Int) {  val visited = Array(list. size) { false }  fun recDfs(index: Int) {    visited[index] = true    print( $index  )    list[index]. forEach{      if(!visited[it]) recDfs(it)    }    return  }  return recDfs(start)}dfsSearch(list, 1)11 2 4 8 5 6 3 7  스택12345678910111213141516171819202122232425262728293031fun dfsSearch(list: List&lt;ArrayList&lt;Int&gt;&gt;, start: Int) {  val visited = Array(list. size) { false }  val stack = Stack&lt;Int&gt;()  fun stackDfs(index: Int) {    stack. push(index)    var flag: Boolean    visited[index] = true    print( $index  )    var value: Int    while(stack. isNotEmpty()) {      value = stack. peek()      flag = false      run loop@{        list[value]. forEach {          if (!visited[it]) {            stack. push(it)            print( $it  )            visited[it] = true            flag = true            return@loop          }        }      }      if(!flag) stack. pop()    }    return  }  return stackDfs(start)}dfsSearch(list, 1)11 2 4 8 5 6 3 7 BFS:  한 노드에 연결된 노드를 전체 탐색한 뒤 설정한 방향대로 차례로 진행하며 전체를 탐색 하는 방법 큐를 사용한다. 1→(1)→2→3→(2)→4→5→(3)→6→7→(4)→8→(5)→(6)→(7)→(8)배열12345678910111213141516171819202122232425262728293031323334fun bfsSearch(arr: Array&lt;Array&lt;Int&gt;&gt;, start: Int) {  val visited = Array(arr. size) { false }  val queue: Queue&lt;Int&gt; = LinkedList&lt;Int&gt;()  fun bfs(index: Int) {    queue. add(index)    var flag: Boolean    visited[index] = true    print( $index  )    var value: Int    while(queue. isNotEmpty()) {      value = queue. peek()      flag = false      run loop@{        arr[value]. forEachIndexed { index, item -&gt;          if(item == 1) {            if (!visited[index]) {              queue. add(index)              print( $index  )              visited[index] = true              flag = true              return@loop            }          }        }      }      if(!flag) queue. poll()    }    return  }  return bfs(start)}bfsSearch(arr, 1)11 2 3 4 5 6 7 8 리스트1234567891011121314151617181920212223242526272829303132fun bfsSearch(list: List&lt;ArrayList&lt;Int&gt;&gt;, start: Int) {  val visited = Array(list. size) { false }  val queue: Queue&lt;Int&gt; = LinkedList&lt;Int&gt;()  fun bfs(index: Int) {    queue. add(index)    var flag: Boolean    visited[index] = true    print( $index  )    var value: Int    while(queue. isNotEmpty()) {      value = queue. peek()      flag = false      run loop@{        list[value]. forEach {          if (!visited[it]) {            queue. add(it)            print( $it  )            visited[it] = true            flag = true            return@loop          }        }      }      if(!flag) queue. poll()    }    return  }  return bfs(start)}bfsSearch(list, 1)11 2 3 4 5 6 7 8 "
    }, {
    "id": 136,
    "url": "/study_Programming_Graph/",
    "title": "Graph",
    "body": "2020/09/08 - Graph: 그래프를 다뤄보자.  정점 (Vertex / Node)  그래프에서 위치를 나타냅니다.  간선 (Edge / Link / Branch)  그래프에서 위치간의 관계를 나타냅니다. 즉, 각 정점(노드)를 연결하는 선을 의미합니다.  인접 정점 (Adjacent Vertex)  간선(Edge)에 의해 직접 연결된 정점을 의미합니다.  G(V, E)  그래프는 정점과 간선의 집합이므로 G(V, E)는 그래프 자체를 의미합니다. 무방향 그래프(undirected graph):       Vertex   Edge         8   [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [5, 8], [6, 8], [7, 8]]   1234val edge = arrayOf(intArrayOf(1, 2), intArrayOf(1, 3), intArrayOf(2, 4),      intArrayOf(2, 5), intArrayOf(3, 6), intArrayOf(3, 7),      intArrayOf(4, 8), intArrayOf(5, 8), intArrayOf(6, 8),       intArrayOf(7, 8)) 행렬123456789val arr = Array(9) { Array(9) { 0 } }// 무뱡향edge. forEach {    arr[it[0]][it[1]] = 1     arr[it[1]][it[0]] = 1  }arr. forEach {    println(Arrays. toString(it))  }123456789[0, 0, 0, 0, 0, 0, 0, 0, 0][0, 0, 1, 1, 0, 0, 0, 0, 0][0, 1, 0, 0, 1, 1, 0, 0, 0][0, 1, 0, 0, 0, 0, 1, 1, 0][0, 0, 1, 0, 0, 0, 0, 0, 1][0, 0, 1, 0, 0, 0, 0, 0, 1][0, 0, 0, 1, 0, 0, 0, 0, 1][0, 0, 0, 1, 0, 0, 0, 0, 1][0, 0, 0, 0, 1, 1, 1, 1, 0] 리스트vertex 할당 123456789val list = List(9) { ArrayList&lt;Int&gt;() }// 무뱡향edge. forEach {    list[it[0]]. add(it[1])    list[it[1]]. add(it[0])  }list. forEach {    println(it. toString())  }123456789[][2, 3][1, 4, 5][1, 6, 7][2, 8][2, 8][3, 8][3, 8][4, 5, 6, 7]방향 그래프(digraph, directed graph), 가중치 그래프(weighted graph):       Vertex   Edge [vertex1, vertex2, weight]         5   [[1, 2, 12], [1, 3, 6], [1, 4, 10], [2, 3, 10], [2, 5, 2], [3, 4, 3], [4, 2, 2], [4, 5, 5]]   123val edge = arrayOf(intArrayOf(1, 2, 12), intArrayOf(1, 3, 6),       intArrayOf(1, 4, 10), intArrayOf(2, 3, 10), intArrayOf(2, 5, 2),      intArrayOf(3, 4, 3), intArrayOf(4, 2, 2), intArrayOf(4, 5, 5)) 행렬12345678910val infinite = 99999999val arr = Array(6) { Array(6) { infinite } } // 1 ~ 5 의 vertex를 가진다. weight 초기값은 무한// 단방향edge. forEach {    arr[it[0]][it[1]] = it[3]  }arr. forEach {    println(Arrays. toString(it))  }123456[∞, ∞, ∞, ∞, ∞, ∞][∞, ∞, 12, 6, 10, ∞][∞, ∞, ∞, 10, ∞, 2][∞, ∞, ∞, ∞, 3, ∞][∞, ∞, 2, ∞, ∞, 5][∞, ∞, ∞, ∞, ∞, ∞] 리스트123456789101112val list = List(6) { ArrayList&lt;Pair&lt;Int, Int&gt;&gt;() } // 1 ~ 5 의 vertex를 가진다. // vertex의 개수는 추가해주는 것보다 초기부터 설정해놓고 // 안쓰는 것은 빈공간으로 두는 것도 하나의 방법이다// 단방향edge. forEach {    list[it[0]]. add(Pair(it[1], it[2]))    // Pair(edge, weigth)  }  list. forEach {    println(it. toString())  }123456[][(2, 12), (3, 6), (4, 10)][(3, 10), (5, 2)][(4, 3)][(2, 2), (5, 5)][]vertex가 좌표이며 동적으로 주어지는 경우: "
    }, {
    "id": 137,
    "url": "/study_Kotlin_string_1/",
    "title": "문자열 활용 예제",
    "body": "2020/09/07 - 문자열: 연습문제 : 수박수박수박수박수박수?: programmers. co. kr 코틀린에서 문자열연산 operator를 지원한다즉, “연산” + “연산” =&gt; “연산연산” 따라서 다음과 같이 해결할 수 있다. 1234567891011121314class Solution {  fun solution(n: Int): String {    var pattern =  수박     var answer =           var isOdd = n % 2        for ( x in 1. . n/2) {      answer += pattern    }        if(isOdd==1) answer += pattern[0]     return answer  }} kotlin에서는 자료형의 구분이 명확하다. 즉, Int의 0, 1은 Boolean의 false, true와 다르다. 또한 문자열에서 함수를 이용해 해결이 가능하다. 12345class Solution {  fun solution(n: Int): String {    return  수박 . repeat(n / 2) + if (n % 2 != 0)  수  else     }}CharArray을 이용해 해결이 가능하다. 123456789&lt;init&gt;Creates a new array of the specified size, where each element is calculated by calling the specified init function. &lt;init&gt;(size: Int, init: (Int) -&gt; Char)Creates a new array of the specified size, with all elements initialized to null char (`\u0000'). &lt;init&gt;(size: Int)12CharArray(5) // 5개 크기의 CharArray 생성CharArray(5){ '가' } // ['가', '가', '가', '가', '가']1234class Solution {  // fun solution(n: Int): String = String(CharArray(n, {i-&gt; if(i%2==0) '수' else '박'}))  fun solution(n: Int): String = String(CharArray(n){i-&gt; if(i%2==0) '수' else '박'})}연습문제 : 이상한 문자 만들기: programmers. co. kr 전형적인 문제풀이 123456789101112131415161718192021class Solution {  fun solution(s: String): String {    var answer =       var idxInWord = 0    for (c in s) {      if (c==' ') {        answer +=            idxInWord = 0      } else {        idxInWord++        if (idxInWord%2 != 0) {          answer += c. toUpperCase()        } else {          answer += c. toLowerCase()        }      }    }    return answer  }}mapIndexed 와 joinToString의 transform을 이용하면 문장을 확연히 줄일 수 있다. 1234567class Solution {  fun solution(s: String): String = s. split(   ). joinToString(   ) {    it. mapIndexed { index, value -&gt;      if(index%2 == 0) value. toUpperCase() else value. toLowerCase()    }. joinToString(  )  }}joinToString의 Transform을 사용하여 각각의 항목에 대하여 mapIndexed를 적용할 수 있게 해준다. 연습문제 : 핸드폰 번호 가리기: programmers. co. kr 바꿀 글자 길이를 가져와서 “*“를 만든다음 substring으로 합치는 방법을 사용하였다. 12345678class Solution {  fun solution(phone_number: String): String {    var answer =       val len = phone_number. length    for(i in 0. . len-5) answer +=  *     return answer + phone_number. substring(len-4. . len-1)  }}slice를 사용할 수 도 있다. 123456789class Solution {  fun solution(phone_number: String): String {    var answer =       val last = phone_number. lastIndex    for (i in 0. . last - 4) answer +=  *     return answer + phone_number. slice(last - 3. . last)  }}문자열 -&gt; 정수: 연습문제 : 문자열을 정수로 바꾸기: programmers. co. kr toInt()는 “-1234” 또한 부호화 해서 -1234로 바꿔준다. 123class Solution {  fun solution(s: String) = return s. toInt()}연습문제 : 자릿수 더하기: programmers. co. kr 나는 문제를 보자마자 String로 변환해서 더한다음 Int로 변환해주는 것으로 설계하였다. 그러나, 사실 10으로 mod 해주면서 나머지 값을 더해주는 것도 한 방법이다. (Int가 주어지기 때문에 굳이 자릿수에 대한 생각하지 않아도 된다. ) 123456789101112class Solution {  fun solution(n: Int): Int {    var input = n    var answer = 0    while (input != 0) {      answer += input % 10      input /= 10    }    return answer  }}아래는 String을 이용해 문제를 해결하는 방법이다. String. forEach가 각각의 String으로 변환해 주는 것을 기억하자. 1234567class Solution {  fun solution(n: Int): Int {    var res = 0    n. toString(). forEach { res += it. toInt() - '0'. toInt() }    return res  }}나는 위와 같이 String. forEach를 알지 못해 굳이 Char로 바꿔서 해결하였다. Char을 사용하려니 toInt() 사용하지 못하였고, getNumericValue() 를 알게 되었다. 123456789class Solution {  fun solution(n: Int): Int {    var answer = 0    n. toString(). toCharArray(). forEach{      answer += Character. getNumericValue(it)    }    return answer  }}연습문제 : 자연수 뒤집어 배열로 만들기: programmers. co. kr 자연수를 문자열로 만들어 reversed 한다음 다시 intArray로 만들어야 한다. 순서대로 n을 n. toString()으로 문자열을 만든다.  이때 해당 문자열을 split(““)로 array을 만들게되면맨 앞과 맨 뒤에 공백칸이 존재하게 된다. 예를들어 1234라면 [  ,  1 ,  2 ,  3 ,  4 ,   ]해당 값들은 string이기 때문에 toInt를 하면 바로 숫자로 바뀌게 되나,공백을 제거해 줘야 한다. 12345678910class Solution {  fun solution(n: Long): IntArray {    return n. toString()      . reversed()      . split(  )      . filter { it !=    }      . map { it. toInt() }      . toIntArray()  }} 그렇다면 공백을 사용하지 않도록 map을 이용하려다 보니, 이때 다루는 값은 String의 원소(String[0]) Char 값이다. 이것을 toInt() 이용하면 ascii값이 나온다. 따라서 기존점을 이용하여 숫자를 만들어 준다. 12345678class Solution {  fun solution(n: Long): IntArray {    return answer = n. toString()      . reversed()      . map{it. toInt() - '0'. toInt()}      . toIntArray()  }}연습문제 : 정수 내림차순으로 배치하기: programmers. co. kr Long을 배열로 바꾼 뒤 정렬을 하고 다시 Long으로 return 해야 하는 문제. map으로 list로 바꿔준뒤, 정렬을 하고 다시 joinToString으로 String 변환 후 Long return 1234567class Solution {  fun solution(n: Long): Long = n. toString()     . map{it. toInt() - '0'. toInt()}     . sortedDescending()     . joinToString(  )     . toLong()}그런데 map을 쓰려는 이유가 sorted를 사용하려 했던건데, sortedArray()를 사용해서 해결도 가능하다. sortedArray를 사용하려면 array에서만 동작하므로 toCharArray() 12345class Solution {  fun solution(n: Long): Long =     String(n. toString(). toCharArray(). sortedArrayDescending())      . toLong()}CharArray or Array: 연습문제 : 문자열 내림차순으로 배치하기: programmers. co. kr 단순히 문자열을 분리한 다음 내림차순 정렬 후 다시 합치면 된다. 이때, 문자열을 분리하여 저장하는 것이 CharArray와 Array 두가지로 나뉠 수 있다.  CharArrayarray를 사용하게 되면 sortedArray를 사용할수 있다. array를 받아 array를 return char또한 charArray는 String으로 감싸 String으로 return 할수 있다. (charArray, byteArray 사용 가능)1234class Solution {  fun solution(s: String): String =     String(s. toCharArray(). sortedArrayDescending())} Arrayarray. map은 List를 retrun하는데, 그렇게 되면 sort를 사용할수 있다. 그리고 다싯 String으로 바꾸기 위해선joinToString을 사용해야 한다. 1234567class Solution {  fun solution(s: String): String {    var answer = s. map {it. toString()}. toTypedArray()    answer. sortByDescending {it}    return answer. joinToString(  )  }}"
    }, {
    "id": 138,
    "url": "/study_Kotlin_standardfunction_1/",
    "title": "표준 함수 활용 예제",
    "body": "2020/09/07 - 연습문제 : 가운데 글자 가져오기: programmers. co. kr 123456789101112class Solution {  fun solution(s: String): String {    var answer =       var middle = 0    val size = s. length        var isOdd = size % 2    var point:Int = size/2    answer = if(isOdd == 1) s. substring(point. . point) else s. substring(point-1. . point)    return answer  }} Int형이 아닌 수를 받으면 toInt하지 않아도 소수점 아래는 버려진다.  함수의 return은 String형이다. 따라서 s[1]같은 경우는 char형이기 때문에 컴파일 오류1234class Solution { fun solution(s: String) =  with(s) { substring(length / 2 - 1 + (length % 2) . . length / 2) }} 나의 풀이방식으로 하는 표준함수를 이용하였다. 앞서 정리해둔 표준 함수 활용1과 표준 함수 활용2에서 자세히 다루고 있다. 사실, with와 run의 기능이 유사하기 때문에 이를 run을 이용할 수도 있다. 1234567class Solution {  fun solution(s: String): String {      return s. run {        substring(length / 2 - 1 + (length % 2) . . length / 2)      }  }}그런데 엄밀히 따지자면 with의 사용조건은 수신 객체가 Non-nullable이면서, 결과가 필요하지 않은 경우에 해당한다. run은 어떤 값을 계산할 필요가 있거나 여러개의 지역 변수의 범위를 제한하기 위해 사용한다. 연습문제 : 서울에서 김서방 찾기: programmers. co. kr array에서 “Kim”을 찾아 해당 Idx를 출력해주는 문제. 나는 코틀린에 익숙하지 않아, 직접 idx를 구하고, 문자열도 합쳐주었다. 그러나 코틀린에서는 더 나은 기능을 제공한다. 1234class Solution {  fun solution(seoul: Array&lt;String&gt;): String =      김서방은 ${seoul. indexOf( Kim )}에 있다 }아래는 자바스크립트와는 다르게 콜백함수에서도 break 하여 idx를 가져오는 방법이다. 123456789101112131415class Solution {  fun solution(seoul: Array&lt;String&gt;): String {    var answer = 0    run loop@{      seoul. forEachIndexed{ index, value -&gt;        if(value. contains( Kim )) {          answer = index          return@loop        }      }    }    return  김서방은 ${answer}에 있다   }}연습문제 : 시저 암호: programmers. co. kr ASCII 값을 이용해 문제를 푸는 방식이 가장 간단하다. kotlin은 범위 연산자와 when을 지원하므로 이것을 통해 해결했다. 추가로 확장 함수를 사용한다면 더 깔끔해진다. 123456789101112class Solution {  fun solution(s: String, n: Int): String =    s. map {      when (it) {        in 'A'. . 'Z' -&gt; it. calAscii(n, 'A', 'Z')        in 'a'. . 'z' -&gt; it. calAscii(n, 'a', 'z')        else -&gt; it      }    }. joinToString(  )  fun Char. calAscii(c: Int, n: Char, m: Char): Char =    (n. toInt() + (toInt() - n. toInt() + c) % (m - n + 1)). toChar()}그런데 kotlin 제공 함수만을 이용해서 해결할 수 있다. 12345678910111213141516class Solution {  fun solution(s: String, n: Int): String {    return String(s. toCharArray(). also {      charArray -&gt;      charArray. forEachIndexed {        index, eachCharacter -&gt;        if(!eachCharacter. isWhitespace()) {          charArray[index] = eachCharacter. plus(n). run {            if(isLetter() &amp;&amp; (!eachCharacter. isUpperCase() || isUpperCase())) this            else minus(26)          }        }      }    })  }}여기서 기억해야할 지점은 also의 활용인데, 위의 코딩에서 보면 String을 charArray로 변환하여 이 객체를 인자로 받아서 계산하고자 할때 가능한 방법이 let 과 also이다. 이 때 인자가 Array이기 때문에 값이 변경이 이뤄지기 때문에 해당 값을 그대로 결과값으로 return 해도 된다. 따라서 굳이 block(this)를 리턴하기 보다 this를 return 하여 block 내에서 굳이 어떤 값을 return 하도록 설계 하지 않아도 된다. char. plus()는 char의 값을 바꾸지 않고 return한다. 연습문제 : 문자열 내 마음대로 정렬하기: programmers. co. kr 커스텀 기준점으로 정렬을 하면 되는 문제이다. 기준점은 2단계로 나뉘어 있는데,  특정 순번의 Char 값을 기준으로 정렬 해당 Char 값이 같을 경우, 전체 값을 기준으로 정렬위와 같은 기준점을 해결하기 위해 방법으로는 3가지가 존재한다.  Comparator 이용 : 가장 처음으로 떠올린 방법으로 람다식을 이용해 기준점을 설정한다. 기본적으로 람다식의 결과값이 양수면 swap, 0 또는 음수면 remain 하게 된다. 같은 값을 찾아 내야 할 필요가 없으므로, 단순히 음수로 표현하여 만들었다. 1234567891011121314151617class Solution {  fun solution(strings: Array&lt;String&gt;, n: Int): Array&lt;String&gt; {    strings. sortWith(Comparator&lt;String&gt; { a, b -&gt;      when {        a[n] &gt; b[n] -&gt; 1        a[n] == b[n] -&gt; {          when {            a &gt; b -&gt; 1            else -&gt; -1          }        }        else -&gt; -1      }    })    return strings  }} compareBy 이용 : comparator의 동작을 하나 단순하게 사용하게 도와주는 함수이다. 기준점이 한단계만 존재 할 경우, 단순히 { it. length } 와 같이 사용할 수 있다. 그러나 위 문제에선 기준점이 두단계가 존재하며, 그것은 아래와 같이 해결한다. 1234567891011class Solution {  fun solution(strings: Array&lt;String&gt;, n: Int): Array&lt;String&gt; {    var answer = strings    var list = answer. sortedWith(compareBy({ it[n] }, { it }))    /*     순서가 매우 중요한데, {it[n]} 이 같게 되면 {it} 으로     정렬을 해주는 것으로 이해하고있다.     */    return list. toTypedArray()  }}그런데 사실 위 문제는 정렬 과정의 기준점을 단계적으로 설정하는 것과는 다르게 전체값 기준 정렬을 한 후, 특정 Char값으로 정렬을 해서 풀수 있다. 12345678class Solution {  fun solution(strings: Array&lt;String&gt;, n: Int): Array&lt;String&gt; {    var answer = strings    var list = answer. sorted()    var result = list. sortedWith(compareBy({ it[n] }))    return result. toTypedArray()  }}객체의 값을 변경해도 될 경우 also와 sort()를 사용하여 해결 할 수 있다. 12345678class Solution {  fun solution(strings: Array&lt;String&gt;, n: Int): Array&lt;String&gt; {    return strings. also {      it. sort()      it. sortBy { it[n] }    }  }}연습문제 : 문자열 다루기 기본: programmers. co. kr 문자열을 Int로 바꿔주며, 만일 바꾸지 못할시 Null처리를 해주는 함수를 이용하여 Null시 let을 이용해 처리를 해주는 방법으로 해결하였다. 123456789101112class Solution {  fun solution(s: String): Boolean {    val len = s. length    if(len == 4 || len == 6) {      var isInt = s. toIntOrNull()      isInt?. let {        return true      }    }    return false   }}Java에서와 같이 isDigit을 이용해 풀수 있기도 하다. 12345678910111213class Solution {  fun solution(s: String): Boolean {    if (s. length != 4 &amp;&amp; s. length != 6){      return false    }    for (c in s. toCharArray()){      if (!c. isDigit()){        return false      }    }    return true  }}"
    }, {
    "id": 139,
    "url": "/study_Kotlin_recursive_1/",
    "title": "Recursive 활용 예제",
    "body": "2020/09/07 - 재귀: 연습문제 : 콜라츠 추측: programmers. co. kr 피보나치 수열과도 같은 문제. 반복문을 이용한 방법과 재귀를 이용한 방법이 있다. 반복문 : value값을 바꿔야 하기 때문에, 새로 설정을 해주고 그것을 기준으로 반복 123456789101112131415class Solution {  fun solution(num: Int): Int {    var answer = 0    var value:Long = num. toLong()    while(value != 1L) {      if(answer &gt;500) return -1      when (value%2L) {        0L -&gt; value /= 2L        else -&gt; value = value * 3L + 1L      }      answer++    }    return answer  }}재귀 : 꼬리 재귀 함수를 이용해 해결 12345678910class Solution {  fun solution(num: Int): Int = collatzAlgorithm(num. toLong(),0)  tailrec fun collatzAlgorithm(n:Long, c:Int):Int =    when{      c &gt; 500 -&gt; -1      n == 1L -&gt; c      else -&gt; collatzAlgorithm(if( n%2 == 0L ) n/2 else (n*3)+1, c+1)    }}"
    }, {
    "id": 140,
    "url": "/study_Kotlin_math_1/",
    "title": "Math 활용 예제",
    "body": "2020/09/07 - Math: 연습문제 : 정수 제곱근 판별: programmers. co. kr kotlin. Math를 사용하는 방법과 정수인지 판단하는 방법을 잘 숙지해 두자. 12double % 1. 0(double!) == 0. 0(double!)Math. pow(sqrt + 1, 2. 0(double!))12345678910class Solution {  fun solution(n: Long): Long {    val sqrt = Math. sqrt(n. toDouble())    return if(sqrt % 1. 0 == 0. 0) {      Math. pow(sqrt + 1, 2. 0). toLong()    } else {      -1L    }  }}연습문제 : 최대 공약수와 최소 공배수: programmers. co. kr 최대 공약수의 2부터 두 숫자 중 작은 숫자까지 둘다 나누어 떨어지는 값이 있다면 그중 가장 큰 값에 해당하며, 없다면 1이게 된다. 최대 공배수는 두 숫자의 곱에 최대 공약수로 나눈 값에 해당한다. 123456789101112class Solution {  fun solution(n: Int, m: Int): IntArray {    var gcd: Int = 1    for(i in Math. min(n, m) downTo 2) {      if(n % i == 0 &amp;&amp; m % i == 0) {        gcd = i        break      }    }    return intArrayOf(gcd, m*n/gcd)  }}재귀 1fun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)a와 b가 있을때, a와 b의 최대공약수를 구하면 a를 b로 나눈 나머지를 구하고,해당 나머지를 다시 b로 나눈 나머지를 구하며 나누어 떨어질때까지 진행한다. a와 b의 크기에 따른 순서는 상관이 없다. 유클리드 호제법을 통한 최대공약수를 구한는 방법이다. 이를 꼬리 재귀 함수를 사용해 해결하였다. 123456789class Solution {  fun solution(n: Int, m: Int): IntArray {    val gcd = gcd(n, m)    return intArrayOf(gcd, n * m / gcd)  }  tailrec fun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)}연습문제 : 평균 구하기: programmers. co. kr 배열의 평균을 구해준다. 123class Solution {  fun solution(arr: IntArray) = arr. sum(). toDouble()/arr. size}average() 함수가 지원이 된다. (Double return) 123class Solution {  fun solution(arr: IntArray) = arr. average()}소수 찾기: 123fun isPrimeNumber(num: Int): Boolean {  return (2. . num / 2). filter { num % it == 0 }. count() == 0 }"
    }, {
    "id": 141,
    "url": "/study_Kotlin_loop_1/",
    "title": "반복문 활용 예제",
    "body": "2020/09/07 - 반복문: 연습문제 : 두 정수 사이의 합: programmers. co. kr 두 정수 a, b 중 큰 값을 찾고, 순서대로 더해주는 쉬운 문제a와 b가 같다면 굳이 for문에 넣지 말고 바로 return 해주자. 1234567891011121314class Solution {  fun solution(a: Int, b: Int): Long {    var answer:Long = 0    val max:Int    val min:Int    if (a&gt;b) {max=a; min=b} else if (a&lt;b) {max=b; min=a} else return a. toLong()    for (i in min. . max) {      answer += i    }    return answer  }}연습문제 : 약수의 합: programmers. co. kr 전형적인 문제풀이 123456789101112class Solution {  fun solution(n: Int): Int {    var answer = 1    if (n &lt;= 1) return n    for( i in 2. . n/2) {      if(n%i == 0) {        answer += i      }    }    return answer+n  }}배열과 filter를 이용해서 문제를 해결할 수 있다. 이때, n 이 1일경우 (1. . 0. 5) 이기 때문에 answer는 0이다. 1234567class Solution {  fun solution(n: Int): Int {    var answer = 0    answer = (1. . n/2). filter { n % it == 0 }. sum()    return answer  }}"
    }, {
    "id": 142,
    "url": "/study_Kotlin_logicaloperator/",
    "title": "논리연산자 활용 예제",
    "body": "2020/09/07 - 논리 연산자 - and: 연습문제 : 짝수와 홀수: programmers. co. kr 전형적인 문제풀이 123class Solution {  fun solution(num: Int) = if(num % 2 == 0)  Even  else  Odd }and operator를 사용하여 해결한다. 여기서 and는 논리연산 and를 의미하며 비트연산으로 판단한다. 123class Solution {  fun solution(num: Int): String = if (num and 1 == 1)  Odd  else  Even }"
    }, {
    "id": 143,
    "url": "/study_Kotlin_collection_1/",
    "title": "Collection 활용 예제",
    "body": "2020/09/07 - Collection List: 연습문제 : 나누어떨어지는 숫자 배열: programmers. co. kr 2가지 방법을 생각하였다.  arr에서 순환하여 조건에 맞는 값을 빈 공간에 추가하기 arr로부터 filter를 이용해 배열을 만들기그런데 2가지 방법 모두 Collection을 이용해야 하므로 List에서만 사용이 가능하다. 따라서 List에서 처리한후 toIntArray를 이용해 return함으로써 해결하였다. 123456789101112class Solution {  fun solution(arr: IntArray, divisor: Int): IntArray {    var answer = ArrayList&lt;Int&gt;()    for (value in arr) {      if (value%divisor == 0) {        answer. add(value)      }    }    if (answer. isEmpty()) answer. add(-1)    return answer. toIntArray(). sortedArray()  }}1234567class Solution {  fun solution(arr: IntArray, divisor: Int): IntArray {    var answer = arr. filter{ it % divisor == 0 }    if (answer. isEmpty()) return intArrayOf(-1)    else return answer. toIntArray(). sortedArray()  }}연습문제 : 제일 작은 수 제거하기: programmers. co. kr 작은수를 찾고, 해당 index를 알아서 빼줘야하는 고민을 하고 있엇는데, filter기능을 이해하면 한번에 해결이 가능하다. 123456class Solution {  fun solution(arr: IntArray): IntArray {    if(arr. size == 1) return intArrayOf(-1)    else return arr. filter{ it != arr. min() }. toIntArray()  }}Collection 확장함수 fold: 연습문제 : 평균 구하기: programmers. co. kr 123class Solution {  fun solution(x: Int) = x % x. toString(). map{it. toInt() - '0'. toInt()}. toIntArray(). sum() == 0}fold를 사용할 수 있다. 123class Solution {  fun solution(x: Int) = x % x. toString(). fold(0){acc, v -&gt; acc + v. toInt() - '0'. toInt()} == 0}"
    }, {
    "id": 144,
    "url": "/study_Kotlin_binarySearch_2/",
    "title": "이분 탐색 : 가사 검색",
    "body": "2020/09/07 - 2020 KAKAO BLIND RECRUITMENT : 가사 검색: programmers. co. kr 이분 탐색이라고 타이틀을 정했지만, 사실 이 문제로부터 이분 탐색을 끌어내는 것 보다 더 쉽게 풀수 있는 방법이 있는데 Trie 자료구조라는 것이다. 그럼에도 이분 탐색이라고 하는 이유는 Trie 자료구조라는 것은 실무에서 적용 사례가 드물기 때문에, 만일 필요하다면 그때 가서 공부하는 것이 더욱 좋을 것 같은 판단 떄문이다. 정답률은 0. 8%로, 아마도 문제로 확인하고 나서야 이러한 자료구조라는 것이 있다는 것을 사람들이 많이 생각했을것 같다. 심지어 카카오에서도 풀이 방법으로 제시한 것이 Trie구조 이지만, 이분 탐색으로도 풀수 있다고 첨언을 해놓았기 때문에 앞서 밝힌 생각을 가지고 이분 탐색으로 풀고자 한다. 이 문제 또한 문제 설명을 토대로 구현을 하다보면 결국에는 완전탐색으로 만들어지게 된다. 문제를 살펴보면 queries에 있는 값이 words와 비교해 특정 조건이 같은 값의 개수를 배열로 return을 해야한다.  따라서 값을 하나마다 조건에 대입해 검사를 하고 해당 개수를 count하는 방법으로 해결할 수 있는데, 이는 완전탐색이다.  아래가 위의 방법으로 풀어본 예시 그나마 효율성에서 어느정도 점수를 받기 위하여 data클래스를 사용하여, length 비교롤 추가시켰다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061data class QuerySet(var length: Int, var frontFlag: Boolean, var markNum: Int, var leftStr: String)class Solution {  fun solution(words: Array&lt;String&gt;, queries: Array&lt;String&gt;): IntArray {    var answer = IntArray(queries. size) { 0 }    val querySet = makeQuerySet(queries)    querySet. forEachIndexed{ index, query -&gt;      words. forEach {        if (queryCompare(it, query)) answer[index]++      }    }    return answer  }  fun makeQuerySet(queries: Array&lt;String&gt;): List&lt;QuerySet&gt; {    var querySet = mutableListOf&lt;QuerySet&gt;()    queries. forEach {      val len = it. length      var queryInfo = QuerySet(len, false, 0,   )      if(it[0] == '?') {        queryInfo. frontFlag = true        var num = getMarkNum(it, true)        queryInfo. markNum = num        queryInfo. leftStr = it. reversed(). substring(0 until len-num)      } else {        queryInfo. frontFlag = false        var num = getMarkNum(it, false)        queryInfo. markNum = num        queryInfo. leftStr = it. substring(0 until len-num)      }      querySet. add(queryInfo)    }    return querySet  }  private fun getMarkNum(query: String, frontFlag: Boolean): Int {    var count = 1    if(frontFlag) {      for( i in 1 until query. length) {        if(query[i] == '?') count++        else return count      }    } else {      for( j in query. length-2 downTo 0) {        if (query[j] == '?') count++        else return count      }    }    return -1  }  private fun queryCompare(oneWord: String, query: QuerySet): Boolean {    if(query. length != oneWord. length) return false    return if(query. frontFlag) {      query. leftStr. compareTo(oneWord. reversed(). substring(0 until oneWord. length-query. markNum)) == 0    } else {      query. leftStr. compareTo(oneWord. substring(0 until oneWord. length-query. markNum)) == 0    }  }} 결과 : 정확성 100% 효율성 60%위와 같은 이해를 바탕으로 더 빨리 풀수 있는 방법(스킬)을 찾아야 하는데, 결론적으로 찾은 방법은 이분탐색이다. 방법을 구체적으로 설명하자면  words를 아래와 같은 조건으로 정렬을 한다.      우선 length로 정렬을 하고, length가 같으면 문자열 순 정렬    words의 요소들을 reverse를 하고 똑같은 방법으로 정렬을 한다.  이분 탐색이므로 값을 먼저 예상을 하고 해당 값이 잎서 정리한 값을 찾기위한 특정한 조건에 일치하는지를 검사한다.  구하고자 하는 값은 조건에 맞는 값의 개수이므로 3번에서의 일치하는 값 중에서 처음 값(lower bound)과 마지막 값(upper bound)의 index를 구한후 두 index를 빼주면 조건에 맞는 값의 개수가 나온다. 아래가 해당 방법으로 푼 예시 아래에선 값을 예상할 때, 위에서 완전탐색으로 푼 문제를 통해 결국에는 값이 stones에서 나올수 밖에 없기 때문에 stones의 중복값을 제거하고 정렬을 한 뒤index 이분탐색을 진행하였다. 물론 러프하게 이분탐색을 진행해도 된다. 사실 기본 upper/lower bound의 컨셉은 양끝지점으로 부터 절반씩 지점으로 옮기며 찾아가는 방식인데, 이 방식은 양끝지점이 한번 정해지면 해당 범주를 설계상 전혀 넘어갈 수 가 없다. 그렇기 때문에 이 문제에서 만일 구하고자 하는 값의 right값이 마지막 값이거나, 초기값일 경우에 대해 구하지 못하게 된다. 그래서 다른 방법을 찾아보니 c++에서 직접 설계를 해놓은 upper_bound와 lower_bound를 찾게 되었고 이 방식은 step을 통한 전진 후진 방식이므로 mid 값을 구하는 과정에서 범주를 자유롭게 넘나들수 있게 된다. 그래서 참고하여 만들었다. 주의해야할 사항은 compare에서 pivot과 target의 위치가 upper_bound 와 lower_bound에서 각각 달라야 한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485class Solution {  fun solution(words: Array&lt;String&gt;, queries: Array&lt;String&gt;): IntArray {    var answer = IntArray(queries. size) { 0 }    val sortedWords = words. sortedWith(compareBy({it. length}, {it}))    val sortedReverseWords = words. map { it. reversed() }. sortedWith(compareBy({it. length}, {it}))    var wordStart = 0    var wordEnd = words. size-1    var len:Int    var left: Int    var right: Int    queries. forEachIndexed{ index, item -&gt;      len = item. length      if(item[0] == '?') {        var pivot = item. reversed()        var leftPivot = pivot. map { if(it == '?') 'a' else it}. joinToString(separator =   )        var rightPivot = pivot. map { if(it == '?') 'z' else it}. joinToString(separator =   )        left = lowerBound(sortedReverseWords, wordStart, wordEnd, leftPivot)        right = upperBound(sortedReverseWords, wordStart, wordEnd, rightPivot)      } else {        var leftPivot = item. map { if(it == '?') 'a' else it}. joinToString(separator =   )        var rightPivot = item. map { if(it == '?') 'z' else it}. joinToString(separator =   )        left = lowerBound(sortedWords, wordStart, wordEnd, leftPivot)        right = upperBound(sortedWords, wordStart, wordEnd, rightPivot)      }      answer[index] = right-left    }    return answer  }  private fun lowerBound(list: List&lt;String&gt;, start: Int, end: Int, pivot: String): Int {    var target: String    var step: Int    var advance: Int    var first = start    var count = end - start + 1    while(count &gt; 0) {      step = count/2      advance = first+step      target = list[advance]      if(queryCompare(target, pivot)) {        // pivot과 target의 순서 중요!        first = ++advance        count -= step + 1      } else {        count = step      }    }    return first  }  private fun upperBound(list: List&lt;String&gt;, start: Int, end: Int, pivot: String): Int {    var target: String    var step: Int    var advance: Int    var first = start    var count = end - start + 1    while(count &gt; 0) {      step = count/2      advance = first+step      target = list[advance]      if(!queryCompare(pivot, target)) {         // pivot과 target의 순서 중요!        first = ++advance        count -= step + 1      } else {        count = step      }    }    return first  }    private fun queryCompare(a: String, b: String): Boolean {    if(a. length &lt; b. length) return true    else if(a. length == b. length) {      if(a &lt; b) return true    }    return false  }}"
    }, {
    "id": 145,
    "url": "/study_Kotlin_array_1/",
    "title": "배열 활용 예제",
    "body": "2020/09/07 - 기본적인 배열 선언: 연습문제 : 2016년: programmers. co. kr 내 풀이 12345678910111213141516171819202122232425262728class Solution {  fun solution(a: Int, b: Int): String {    var answer =       var monthArr = intArrayOf(31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)    var day = 0      var monthCal = a-1    var count = 0;    while (monthCal&gt;0) {      day += monthArr[count]      count++      monthCal--    }    day += b-1    var weekend = day % 7      when(weekend) {      1 -&gt; answer =  SAT       2 -&gt; answer =  SUN       3 -&gt; answer =  MON       4 -&gt; answer =  TUE       5 -&gt; answer =  WED       6 -&gt; answer =  THU       0 -&gt; answer =  FRI     }    return answer  }}다른사람 풀이 123456789101112131415class Solution {  fun solution(a: Int, b: Int): String {        val month = listOf(31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)    val dayOfWeek = listOf( FRI ,  SAT ,  SUN ,  MON ,  TUE ,  WED ,  THU )    var diff = 0    for (i in 0 until a - 1) {      diff += month[i]    }    diff += (b - 1)    return dayOfWeek[diff%7]  }} 1월 1일이 고정이라는 조건을 생각한다면, 위와 같이 단순히 for문을 통해서 월에 해당하는 일수를 더해줄 수 있다. 그리고 그런 방식의 코딩이 더 깔끔해 보이긴 하다. 배열 forEach: 연습문제 : 행렬의 덧셈: programmers. co. kr 우선 새로 배열을 만들고, 해당 배열의 값을 직접 넣어주는 방법이 있다. 123456789101112class Solution {  fun solution(arr1: Array&lt;IntArray&gt;, arr2: Array&lt;IntArray&gt;): Array&lt;IntArray&gt; {    var answer = Array&lt;IntArray&gt;(arr1. size,{ IntArray(arr1. get(0). size,{0})})    for(i in 0 until arr1. size) {      arr1[i]. forEachIndexed { j, it -&gt;        var num = it + arr2[i]. get(j)        answer[i]. set(j, num)      }    }    return answer  }}Array class를 사용해서 생성할 때, 값을 직접 넣어주는 방법이 있다. 123456789class Solution {  fun solution(arr1: Array&lt;IntArray&gt;, arr2: Array&lt;IntArray&gt;): Array&lt;IntArray&gt; {    return Array(arr1. size) { row -&gt;      IntArray(arr1[0]. size) { col -&gt;        arr1[row][col] + arr2[row][col]      }    }  }}배열 - 람다식을 이용한 초기화: 연습문제 : x만큼 간격이 있는 n개의 숫자: programmers. co. kr 람다식을 이용한 배열 초기화 기억해두자. 123class Solution {  fun solution(x: Int, n: Int) = LongArray(n) { it -&gt; x. toLong() * (it + 1) }}"
    }, {
    "id": 146,
    "url": "/study_Kotlin_binarySearch_1/",
    "title": "이분 탐색 : 징검다리 건너기",
    "body": "2020/09/06 - 2019 카카오 개발자 겨울 인턴십 : 징검다리 건너기: programmers. co. kr [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다. ] = 완전탐색으로 풀면 0 점이라는 소리다. 보통 이런 문제의 가장 큰 해결 방안 중 하나는 이분 탐색이다. 그렇지만 문제에서 설명하는 대로 문제를 해결하다 보면 방법이 결국에는 완전탐색쪽으로 떠오른다.  이 문제를 살펴보면 stone의 값이 결국 걸어갈 수 있는 인원을 나타내므로 stone의 가장 적은 값부터 빼주되 처음 0이하가 되는 index를 true로 하는 배열을 가질 수 있다. 이 배열에서 true를 가지는 index의 연속적인 개수가 k값보다 커지는 직후의 순간을 찾아내도록 하는 방법이 하나의 방법이 될수 있는데, 이는 완전탐색이다.  아래가 위의 방법으로 풀어본 예시아래에선 stones의 값을 중복을 제거 한후 내림차순 정렬을 하게 되면 해당 값들이 각각의 배열 안에서 0이 되는 값이기 때문에그 값의 index를 찾아주면 k값을 검사할 수 있게 된다. 12345678910111213141516171819202122232425262728293031323334353637class Solution {  fun solution(stones: IntArray, k: Int): Int {    val checkStoneSet = BooleanArray(stones. size) { false }    val stoneSet = mutableSetOf&lt;Int&gt;()    stones. forEach { stoneSet. add(it) }    var sortedStoneSet = stoneSet. sorted()    var curStone = 0    curStone = sortedStoneSet. first()    sortedStoneSet = sortedStoneSet. drop(1)    while (sortedStoneSet. isNotEmpty()) {      stones. forEachIndexed{ index, i -&gt;        if(i==curStone) {          checkStoneSet[index] = true        }      }      if( checkStone(checkStoneSet, k)) {        return curStone      }      curStone = sortedStoneSet. first()      sortedStoneSet = sortedStoneSet. drop(1)    }    return curStone  }}fun checkStone(stonesList: BooleanArray, k: Int): Boolean {  var now = 0  for( i in stonesList) {    if(i) now += 1    else now = 0    if(now &gt;= k) return true  }  return false} 결과 : 정확성 100% 효율성 0%위와 같은 이해를 바탕으로 더 빨리 풀수 있는 방법(스킬)을 찾아야 하는데, 결론적으로 찾은 방법은 이분탐색이다. 방법을 구체적으로 설명하자면  구하고자 하는 값을 어떤 로직의 결과로 도출이 내는 것이 아닌, 값을 특정한 다음 해당 값이 조건에 일치한지 검사한다.  해당 조건에서는 값이 맞는지 틀리는지와 함께 틀리다면 해당 결과값이 조건에 맞는 값과 비교 할수 있으며, 해당 값과 비교하여 크기 여부를 확인한다.  예상값이 크다면 예상값을 작게, 작다면 예상값을 크게한다. 그렇게 하는 방법은 범주를 정하고 양 끝값의 절반을 예상값으로 한다. (이렇게 이분법으로 나누니 때문에 이분탐색) 그러나 이 문제에서는 조건에 맞는 값이 여러개가 존재하기 때문에 위 단계에서 추가적으로 조건에 맞는 값이더라도 해당 값중 가장 낮은값을 찾는 upper bound를 로써 문제를 풀어나간다. 아래가 해당 방법으로 푼 예시 아래에선 값을 예상할 때, 위에서 완전탐색으로 푼 문제를 통해 결국에는 값이 stones에서 나올수 밖에 없기 때문에 stones의 중복값을 제거하고 정렬을 한 뒤index 이분탐색을 진행하였다. 물론 러프하게 이분탐색을 진행해도 된다. 123456789101112131415161718192021222324252627282930class Solution {  fun solution(stones: IntArray, k: Int): Int {    val stoneSet = mutableSetOf&lt;Int&gt;()    stones. forEach { stoneSet. add(it) }    var sortedStoneSet = stoneSet. sorted()        var right = sortedStoneSet. size-1    var left = 0        var mid: Int        while (left &lt;= right) {        mid = (left+right)/2            if(checkStone(stones, sortedStoneSet[mid], k)) right = mid-1      else left = mid+1    }    return sortedStoneSet[left-1]  }}fun checkStone(stones: IntArray, mid: Int, k: Int): Boolean {  var now = 0  for( i in stones) {    if(i &lt; mid) now += 1    else now = 0    if(now &gt;= k) return true  }  return false}"
    }, {
    "id": 147,
    "url": "/study_Programming_priorityQueue/",
    "title": "우선순위 큐",
    "body": "2020/09/06 - 우선순위 큐max heap 또는 min heap 이라고도 할 수 있는 우선순위 큐를 코틀린에서는 지원을 해준다. 이런 우선순위 큐를 알아보자. 1import java. util. PriorityQueue1234fun main() { val queue1 = PriorityQueue&lt;Int&gt;()  val queue2 = PriorityQueue(Comparator. reverseOrder&lt;Int&gt;())}PriorityQueue를 사용하기 위해서는 java. util. PriorityQueue(java. util. *)가 필요하다. 기본값으로는 값이 낮을 수록 우선순위가 높게 설정되어 있다. 이를 값이 높을 수록 우선순위가 높도록 바꾸기 위해선 queue2처럼 선언하면 된다. 사용가능한 함수로는 아래와 같다.       함수   기능         add   추가       offer   추가       size   크기       clear   모두 지우기       peek   가장 앞부분 가져오기(해당 값 복사)       poll   가장 앞부분 빼오기(해당 값 잘라내기)       isEmpty   비어있는지 확인   add 와 offer의 차이: AbstarctQueue일때 123456public boolean add(E e) {  if (offer(e))    return true;  else    throw new IllegalStateException( Queue full );}사용 예: 12345678910111213141516fun main(args: Array&lt;String&gt;) { val nums: PriorityQueue&lt;Int&gt; = PriorityQueue&lt;Int&gt;() // Add items (enqueue) nums. add(800) nums. add(50) nums. add(200) nums. add(550) println( peek:   + nums. peek())  // Remove items (dequeue) while (!nums. isEmpty()) {  println(nums. remove()) }}Output: 12345peek: 5050200550800"
    }, {
    "id": 148,
    "url": "/study_Kotlin_stack&queue_1/",
    "title": "스택/큐 : 프린터",
    "body": "2020/09/02 - 스택/큐 : 프린터: programmers. co. kr 생각하는데 조금 애를 먹었다. 문제의 해결과정은 다음과 같다. 대기 목록에서 꺼낸 문서의 중요도 보다 대기 목록의 중요도가 높을 경우 꺼낸 문서를 대기 문서 맨 뒷부분으로 넣는다.    직접 대기 목록을 꺼내 맨 뒷부분으로 넣으려고 했으나, 이 같은 과정은 시간 소요가 너무 크다     그렇다면 다른 방법을 생각을 해야 하는 것인데, 대기목록 순서대로 인쇄를 하나 중요도가 있을 시 맨 뒤로 옮겨지는 것을 다시 생각해 보면 대기 목록 순서대로 꺼내는 동작을 반복적으로 하면서 중요도와 맞으면 꺼내고 아니면 지나간다. 이때, 해당 동작하나마다 count를 세는 병렬적인 방식으로 문제 해결방향을 잡았다.  이때 중요도를 꺼내는 방법으로 우선순위 큐를 사용하였다. 123456789101112131415161718192021class Solution {  fun solution(priorities: IntArray, location: Int): Int {    var answer = 1    val queue = PriorityQueue(Comparator. reverseOrder&lt;Int&gt;())    for (i in priorities) {      queue. offer(i)    }    while (!queue. isEmpty()) {      for (i in priorities. indices) {         if (priorities[i] == queue. peek()) {          if (location == i) {            return answer          }          answer++          queue. poll()        }      }    }    return answer  }}"
    }, {
    "id": 149,
    "url": "/study_Kotlin_design_3/",
    "title": "설계 : 실패율",
    "body": "2020/09/02 - 연습문제 : 실패율: programmers. co. kr 위 문제를 푸는 과정은 다음과 같다.  실패율에 해당하는 값을 계산한다.  실패율값을 배열에 Stage - 실패율값 으로 저장한다.  조건에 맞게 정렬을 한다.  IntArray return우선 실패율을 구하기 위한 방법으로 2가지를 제시하자면 아래와 같다  2중 반복문을 이용하여 pass와 fail의 수를 구하여 실패율 값을 계산 stages를 정렬하여 다른 stage가 나오게 하며, 해당 스테이지의 fail을 오름차순으로 올라가면 자연스레 pass한 숫자를 알수 있다. 또한 Stage와 실패율 값을 기록하는 방법으로 2가지를 제시하자면 아래와 같다  Pair를 이용하여 값을 Array에 저장 data class를 이용하여 값을 Array에 저장아래에서 확인하자.  stage를 정렬하여 실패율 계산, Pair를 이용하여 값을 Array에 저장1234567891011121314151617181920212223242526272829303132333435class Solution {  fun solution(N: Int, stages: IntArray): IntArray {    var answer = intArrayOf()    var failrate = Array(N+2) { Pair(it, 0. 0) }         var stage = 0    var count = 0. 0    var len = stages. size. toDouble()        for( i in stages. sortedArray() ) {      if(stage != i ) {        failrate[stage] = Pair(stage, count/len)        stage = i        len -= count        count = 0. 0      }      count++    }    failrate[stage] = Pair(stage, count/len)        return failrate. sliceArray(1. . failrate. size-2)            . sortedArrayWith(Comparator&lt;Pair&lt;Int, Double&gt;&gt; { a, b -&gt;              when {                a. second &lt; b. second -&gt; 1                a. second == b. second -&gt; {                  when {                    a. first &gt; b. first -&gt; 1                    else -&gt; -1                  }                }                else -&gt; -1              }    }). map{ it. first }. toIntArray()  }}Pair는 여러모로 유용할 것 같다. 람다식을 이용한 정렬도 가능하며, 각 값을 쉽게 바꿀 수 있으며, 해당 값은 쌍으로 다룰수 있기 때문이다.  2중 반복문을 이용하여 실패율을 계산, data class를 이용하여 값을 저장12345678910111213141516171819data class Stage(var level: Int, var pass: Int, var fail: Int) {  val failRate: Float  get() = if (fail+pass == 0) 0. 0f else (fail. toFloat()) / (pass + fail)}class Solution {  fun solution(N: Int, stages: IntArray): IntArray {    var stageInfo = Array(N, { Stage(it+1, 0, 0)})    for (level in stages) {      for (i in 0. until(level-1)) {        stageInfo[i]. pass++      }      if (level != N+1) stageInfo[level-1]. fail++    }    stageInfo. sortByDescending { it. failRate }    return stageInfo. map { it. level }. toIntArray()  }}사실 단순히 실패율로만 저장하면 되는 것이 이미 내림차순으로 정렬이 되어 있기 때문에 값이 같다면 내림차순으로 정렬된다. "
    }, {
    "id": 150,
    "url": "/study_Kotlin_design_2/",
    "title": "설계 : 키패드 누르기",
    "body": "2020/09/01 - 연습문제 : 키패드 누르기: programmers. co. kr 왼쪽, 오른쪽의 Starting Point이 존재하고 조건에 따라 해당 Point는 바뀌는데, 조건은 바꾸려는 Point와 양쪽 의 거리 차이이다. 따라서 배열을 구성해서 해당 Point간 거리를 구할수 있어야 하며, 움직일때마다 Point를 저장하고 있어야 한다. 아래는 다음과 같은 설계를 통해 구성하였다.  각 숫자에 맞는 배열을 구성하여 해당 위치를 배열을 기준을 찾도록 한다.  오른손과 왼손의 현재 위치를 Location이란 Data class에 담는다.  Data class는 comparable을 상속하여 위치간 거리를 계산할수 있도록 한다.  매개값으로 들어오는 숫자에 해당하는 배열의 위치를 구하도록 함수를 구성한다.  조건에 맞으면 현재 위치를 다음 위치로 변경한 후 record에 움직인 값을 기록한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution { data class Location(val x: Int, val y: Int) : Comparable&lt;Location&gt; {  override fun compareTo(other: Location): Int {   return abs(this. x - other. x) + abs(this. y - other. y)  } } val keypad = arrayOf(  intArrayOf(1,2,3),  intArrayOf(4,5,6),  intArrayOf(7,8,9),  intArrayOf(-1,0,-1) ) var left = Location(0, 3) var right = Location(2, 3) fun solution(numbers: IntArray, hand: String): String {  var record =     numbers. forEach {   when(it){    1, 4, 7 -&gt; record += move( left , it)    3, 6, 9 -&gt; record += move( right , it)    else -&gt; {     val leftOrRight = distance(findLocation(it), left, right)     when {      leftOrRight == 0 -&gt; {       if (hand ==  right ) {        record += move( right , it)       } else {        record += move( left , it)       }      }      leftOrRight &lt; 0 -&gt; record += move( left , it)      else -&gt; record += move( right , it)     }    }   }  }  return record } fun move(hand: String, target: Int): String {  if (hand ==  left ) {   left = findLocation(target)   return  L   } else {   right = findLocation(target)   return  R   } } fun findLocation(target: Int): Location {  for (i in 0. . 3) {   if (keypad[i]. contains(target)) {    return Location(keypad[i]. indexOf(target), i)   }  }  return Location(0, 0) } fun distance(target: Location, left: Location, right: Location): Int   = left. compareTo(target) - right. compareTo(target)}또 다른 풀이로아래는 다음과 같은 설계를 통해 구성하였다.  각 숫자에 맞는 위치를 Collection Map에 Pair로 지정하여 구성한다.  오른손과 왼손의 현재 위치를 Pair로 지정한다.  abs를 통해 거리를 구한다.  map의 결과를 joinToString을 이용해 결과값으로 만든다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051class Solution {  val info = mapOf ( 0 to Pair(1,3),      1 to Pair(0,0),      2 to Pair(1,0),      3 to Pair(2,0),      4 to Pair(0,1),      5 to Pair(1,1),      6 to Pair(2,1),      7 to Pair(0,2),      8 to Pair(1,2),      9 to Pair(2,2)  )    fun solution(numbers: IntArray, hand: String): String {    val lefthanded = hand ==  left  // boolean 만들기!    var nowLeft = Pair(0,3)    var nowRight = Pair(2,3)        return numbers. map { value -&gt;      info[value]?. let {        if(it. first == 0) {          nowLeft = it          'L'        } else if(it. first == 2) {          nowRight = it          'R'        } else {          val distLeft = abs(it. first-nowLeft. first)                   + abs(it. second-nowLeft. second)          val distRight = abs(it. first-nowRight. first)                   + abs(it. second-nowRight. second)          if(distLeft &gt; distRight) {            nowRight = it            'R'          } else if(distLeft &lt; distRight) {            nowLeft = it            'L'          }else {            if(lefthanded) {              nowLeft = it              'L'            }else {              nowRight = it              'R'            }          }        }      }    }. joinToString(  )  }}"
    }, {
    "id": 151,
    "url": "/study_Programming_memo/",
    "title": "Kotlin 코딩테스트 메모장",
    "body": "2020/08/24 - 123456/******************************************************************************/try {  . . . } catch ( e: CancellationExceoption) {ㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁㅁ  . . . 취소에 대한 예외처리 . . . }"
    }, {
    "id": 152,
    "url": "/feat_study_programming_templet/",
    "title": "Kotlin 코딩테스트 템플릿",
    "body": "2020/08/24 - 코틀린 기본: 코틀린에서 기본적인 동작을 예제에서 확인해보자.  배열 예제 문자열 예제 반복문 예제,   예제 2 수식 예제,   예제 2 재귀 예제   논리 연산자 예제   find와 first 예제배열: 배열 선언과 출력하는 부분을 잘 숙지해 두자  배열 배열의 선언배열 예제 배열 정렬: 기본적인 함수라고 할수 있지만, 자주 쓰이므로 따로 구분해 놓는다.  배열의 정렬배열의 정렬 예제배열의 정렬 예제 표준 함수: 함수형 프로그래밍을 하도록 코틀린에서 지원하는 여러 함수 들을 잘 숙지하고 이용하자.  closure, let, also, apply   run, with, use, takeIf, takeUnless   let과 run을 이용한 Null 검사표준 함수의 이용 예제 확장 함수: 함수형 프로그래밍을 하도록 코틀린에서 지원하는 여러 함수 들을 잘 숙지하고 이용하자.  forEach, reduce, fold     reduce, fold 응용      map, groupBy, sequence   apply, fold, asSequence 사용 예 + SetCollection &amp; 해시: Collection은 Data의 입력, 출력에서 강력한 기능을 가지고 있기 때문에 자주 쓰인다. 해당 기능 수행 후 toIntArray() 와 같이 원하는 자료형 형태로 return이 가능하게 해준다.  List :      Collection List-1   Collection List-2    Set :      Collection Set    Map :      Collection Map   Collection 관련 예제 해당 Collection - Set, Map를 이용해 해시문제를 풀수 있다. 해시 관련 예제해시 관련 예제 조합, 순열. 멱집합:  조합 순열 멱집합그래프: DFS, BFS에서 주로 사용된다. 방향, 가중치를 이용한 문제도 출시 된적이 있으니 잘 숙지해두자.  그래프BFS/DFS: 어려운 문제로 자주 사용되는 알고리즘.  BFS/DFS스택/큐:  큐 예제우선순위 큐: 코틀린은 자바와 같이 우선순위 큐를 지원해 준다. 우선 순위 큐 기본  우선 순위 큐 예제이분탐색: 어려운 문제로 등장하기 쉬운 문제 중 하나 이다. 기본 컨셉은 매우 간단해서 단순히 이분 탐색을 이용해 조건에 맞는 값을 찾는 것을 구하는 것보다 upper/lower bound를 이용하여 조건에 맞는 가장 작은 값을 찾는 문제로 변별력을 갖추려는 것 같다.  이분 탐색 예제 - upper/lower bound easy 이분 탐색 예제 - upper/lower bound hardGreedy: 사고력과 순발력을 요구를 하기 때문에 여러워지기 쉬운것 같다. 그런데 해당 알고리즘의 한계점인 100% 최적해를 보장하지 않으므로, 문제를 낼 때 어느정도의 최적해를 정답으로 구분할지 판단하기 어려워진다. 간단하게 100% 최적해가 만들어 지지 않는 이상 굳이 문제로 내지 않을 것으로 생각이 된다.  Greedy 예제1 : 간단하게 최적해 보장 Greedy 예제2 : 최적해를 보장하기 어려움"
    }, {
    "id": 153,
    "url": "/study_Kotlin_41/",
    "title": "Kotlin 객체편 - [31]",
    "body": "2020/08/20 - 완료를 기다리기 위한 블로킹: runBlocking의 사용  새로운 코루틴을 실행하고 완료되기 전까지는 현재(caller) 스레드를 블로킹 코루틴 빌더와 마찬가지로 CoroutineScope의 인스턴스를 가짐  1234fun &lt;T&gt; runBlocking( context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope. () -&gt; T): T (source)   main()을 블로킹 모드로 동작시키기 1234567891011import kotlinx. coroutines. *fun main() = runBlocking&lt;Unit&gt; { // 메인 메서드가 코루틴 환경에서 실행  launch { // 백그라운드로 코루틴 실행    delay( 1000L )    println( World! )  }  println( Hello ) // 즉시 이어서 실행됨  // delay( 2000L ) // delay()를 사용하지 않아도 코루틴을 기다림}runBlocking()을 클래스 내의 멤버 메서드에서 사용할 때 123456class MyTest {  . . .   fun mySuspendMethod() = runBlocking&lt;Unit&gt; {    // 코드  }}특정 디스패처 옵션을 주어줄 때 12345678runBlocking(Dispatchers. IO) {  launch {    repeat(5) {      println( counting ${it + 1} )      delay(1000)    }  }}특정 문맥과 함께 실행: withContext()  인자로 코루틴 문맥을 지정하며 해당 문맥에 따라 코드 블록을 실행 해당 코드 블록은 다른 스레드에서 수행되며 결과를 반환 한다.  부모 스레드는 블록하지 않는다. 12345// 함수 원형suspend fun &lt;T&gt; withContext(  context: CoroutineContext,  block: suspend CoroutineScope. () -&gt; T): T (source)예 1resultTwo = withContext(Dispatchers. IO) { function2() }완료보장  withContext(NonCancellable) {…}     try { … } finally { … } 에서 finally 블록의 실행을 보장하기 위해 취소불가 블록 구성   스코프 빌더: coroutineScope 빌더  자신만의 코루틴 스코프(scope)를 선언하고 생성할 수 있다. (구조화된 코루틴) 모든 자식이 완료되기 전까지는 생성된 코루틴 스코프는 종료되지 않는다.  runBlocking과 유사하지만 runBlocking은 단순 함수로 현재 스레드를 블록킹, coroutineScope는 단순히 지연(suspend)함수 형태로 넌블로킹으로 사용됨123suspend fun &lt;R&gt; coroutineScope(  block: suspend CoroutineScope. () -&gt; R): R (source) 만일 자식 코루틴이 실패하면 이 스코프도 실패하고 남은 모든 자식은 취소(cancel)된다. (반면에 supervisorScope는 실패하지 않음)     외부에 의해 작업이 취소되는 경우 CancellationException 발생   supervisorScope 빌더  마찬가지로 코루틴 스코프를 생성하며 이때 SupervisorJob과 함께 생성하여 기존 문맥의 Job을 오버라이드 한다.      launch를 사용해 생성한 작업의 실패는 CoroutineExceptionHandler를 통해 핸들링   async를 사용해 생성한 작업의 실패는 Deferred. await의 결과에 따라 핸들링   parent를 통해 부모작업이 지정되면 자식작업이 되며 이때 부모에 따라 취소여부 결정    1fun SupervisortJob(parent: Job? = null): CompletableJob ( source )           자식이 실패하더라도 이 스코프는 영향을 받지 않으므로 실패하지 않는다.      실패를 핸들링하는 정책을 구현할 수 있다.     예외나 의도적인 취소에 의해 이 스코프의 자식들을 취소하지만 부모의 작업은 취소하지 않는다. 예시 123456789101112131415161718192021import kotlinx. coroutines. *fun main() = runBlocking { // this: CoroutineScope  launch {    delay( 200L )    println( Task from runBlocking)  }  coroutineScole { // 코루틴 스코프의 생성 -- 부모가 하위 코루틴 완료를 기다림  // CoroutineScope(Dispatchers. Default). launch { // -- 이때는 부모-자식 관계와 무관(완료를 기다리지 않음)    launch {      delay( 500L )      println( Task from nested launch )    }    delay( 100L )    println( Task from coroutine scope )  }  println( Coroutine scope is over )}부모와 자식 코루틴 관의 관계: 병렬 분해(Parallel decomposition) 12345suspend fun loadAndCombine(name1: String, name2: String): Image {  val deferred1 = async { loadImage(name1) }  val deferred2 = async { loadImage(name2) }  return combineImages(deferred1. await(), deferred2. await())} loadImage(name2)는 여전히 진행된다.  코루틴 문맥에서 실행하여 자식 코루틴으로 구성한다면 예외를 부모에 전달하고 모든 자식 코루틴을 취소할 수 있다.   123456suspend fun loadAndCombine(name1: String, name2: String): Image = coroutineScope { // 스코프를 설정함으로 특정 자식 코루틴의 취소가 생기면 모든 자식을 취소하게됨 val deferred1 = async { loadImage(name1) } val deferred2 = async { loadImage(name2) } combineImages(deferred1. await(), deferred2. await())}   스코프의 취소와 예외처리: 123456789101112val scope2 = CoroutineScopeval routine1 = scope2. launch { . . . }val routine2 = scope2. async { . . . }scope2. cancel()/* 또는val scope2 = CoroutineScopeval routine1 = scope2. launch { . . . }val routine2 = scope2. async { . . . }scope2. cancelChildern()*/12345try {  . . . } catch ( e: CancellationExceoption) {  . . . 취소에 대한 예외처리 . . . }코루틴의 실행 시간 지정: 실행 시간 제한  withTimeout(시간값) { … } = 특정 시간값 동안만 수행하고 블록을 끝냄     시간값이 되면 TimeoutCancellationException 예외를 발생    withTimeoutOrNull(시간값) { … } - 동작은 위와 동일     단, 예외를 발생하지 않고 null을 반환   12345678val result = withTimeoutOrNull( 1300L ) {  repeat(1000) { i =&gt;    println( I'm sleeping $i . . .  )    delay(500L)  }   Done  // 코루틴 블록이 취소되면 이 값이 result에 반환됨}println( Result is $result )요약:  MainScopeMainScope는 UI 컴포넌트를 위한 스코프입니다. MainScope는 SupervisorJob을 생성하고 이 스코프에서 만들어진 모든 코루틴을 Main스레드에서 실행합니다. SupervisorJob을 생성하기 때문에 하나의 코루틴이 예외를 던지면서 실패해도 다른 코루틴들은 취소되지 않습니다. 자식 코루틴의 실패는 CoroutineExceptionHandler를 사용하여 처리 할 수 있습니다.    CoroutineScope(context)CoroutineScope(context) 함수는 제공된 코루틴 문맥에서 새로운 코루틴 스코프를 생성합니다.     블로킹 모드의 실행 runBlocking은 새로운 코루틴을 시작하고 코루틴이 완료될 때까지 현재 스레드를 차단합니다. 일시 중단 및 논블록킹 스타일로 작성된 일반 블록 코드와 라이브러리를 연결하도록 설계되었습니다.  코루틴의 문맥들    기본 문맥Dispatchers. Default는 기본 문맥인 CommonPool에서 실행되기 때문에 새로운 스레드를 생성하지 않고 기존에 있는 것을 이용합니다. 그러므로 연산 중심의 코드에 적합합니다.     I/O를 위한 문맥Dispatchers. IO는 입출력에 적합한 공유 풀로써, 볼로킹 동작이 많은 파일 or 소켓 I/O 처리에 사용하면 좋습니다.     Unconfined 문맥비한정 문맥에서 실행된 코루틴은 첫번째 중단점을 만날때까지만 호출자 스레드에서 실행됩니다. 중단점 이후에 재개 되었을때는 서스펜드 함수가 실행된 스레드에서 수행됩니다. 그렇기 때문에 비한정 문맥은 예측 불능한 상태로 수행되기 때문에 해당 기능을 사용하는 것은 권장되지 않습니다.     새 스레드를 생성하는 문맥newSingleThreadContext는 새로운 스레드가 생성되기 때문에 비용이 많이 들고 더 이상 필요하지 않으면 해제하거나 종료시켜야 합니다. 부모 코루틴이 취소되는 경우 자식 코루틴도 재귀적으로 취소됩니다.  따라서 필요한 경우 join()함수를 사용하여 명시적으로 처리를 기다리도록 만들 수 있습니다. 문맥 바꾸기 - withContext(context)  withContext(context) : 현재 코 루틴의 컨텍스트를 전환합니다. 주어진 블록이 실행될 때 코 루틴은 이전 컨텍스트로 다시 전환됩니다. "
    }, {
    "id": 154,
    "url": "/study_Kotlin_40/",
    "title": "Kotlin 객체편 - [30]",
    "body": "2020/08/20 - 스레드풀: 스레드풀(thread pool)의 사용  보통 CommonPool이 지정되어 코루틴이 사용할 스레드의 공동 풀(pool)을 사용 이미 초기화되어 있는 스레드 중 하나 혹은 그 이상이 선택되며 초기화하기 때문에 스레드를 생성하는 오버헤드가 없어 빠름 하나의 스레드에 다수의 코루틴이 동작할 수 있다. 특정 스레드 개수를 직접 지정하는 경우 12345val threadPool = Executors. newFixedThreadPool(4)val MyContext = threadPool. asCoroutineDispatcher(). . . async(MyContext) { . . . }. . . 부모-자식 및 독립적인 스코프의 코루틴 예시 1234567891011121314151617181920212223fun main() = runBlocking&lt;Unit&gt; {  println( runBlocking: $coroutineContext )  val request = launch {    println( requst: $coroutineContext )    GlobalScope. launch { // 프로그램 전역으로 독립적인 수행 (부모-자식관계 없음)      println( job1: before suspend function, $coroutineContext )      delay(1000)      println( job1: after suspend function, $coroutineContext ) // 작업 취소에 영향을 받지 않음    }    launch { // 부모의 문맥을 상속(상위 launch의 자식)      delay(100)      println( job2: before suspend function, $coroutineContext )      delay(1000)      println( job2: after suspend function, $coroutineContext ) // request(부모)가 취소되면 수행되지 않음    }  }  delay(500)  request. cancel() // 부모 코루틴의 취소  delay(1000)  println( end )}123456runBlocking: [Blocking. . . {Active}. . . , BlockingEventLoop. . . ]request: [Standalone. . . {Active}. . . , BlockingEventLoop. . . ]job1: before suspend function, [Standalone. . . {Active}. . . , DefaultDispatcher]job2: before suspend function, [Standalone. . . {Active}. . . , BlockingEventLoop. . . ]job1: after suspend function, [Standalone. . . {Active}. . . , DefaultDispatcher]end1234567891011121314151617181920212223fun main() = runBlocking&lt;Unit&gt; {  println( runBlocking: $coroutineContext )  val request = launch {    println( requst: $coroutineContext )    GlobalScope. launch {       println( job1: before suspend function, $coroutineContext )      delay(1000)      println( job1: after suspend function, $coroutineContext )     }    launch(Dispatchers. Default) { // 부모의 문맥을 상속(상위 launch의 자식), 분리된 작업      delay(100)      println( job2: before suspend function, $coroutineContext )      delay(1000)      println( job2: after suspend function, $coroutineContext ) // 여전히 상속되었으므로 취소    }  }  delay(500)  request. cancel()  delay(1000)  println( end )}123456runBlocking: [Blocking. . . {Active}. . . , BlockingEventLoop. . . ]request: [Standalone. . . {Active}. . . , BlockingEventLoop. . . ]job1: before suspend function, [Standalone. . . {Active}. . . , DefaultDispatcher]job2: before suspend function, [Standalone. . . {Active}. . . , DefaultDispatcher] // 달라진 부분job1: after suspend function, [Standalone. . . {Active}. . . , DefaultDispatcher]end1234567891011121314151617181920212223fun main() = runBlocking&lt;Unit&gt; {  println( runBlocking: $coroutineContext )  val request = launch {    println( requst: $coroutineContext )    GlobalScope. launch {       println( job1: before suspend function, $coroutineContext )      delay(1000)      println( job1: after suspend function, $coroutineContext )     }    CoroutineScope(Dispatchers. Default). launch { // 새로운 스코프가 구성되어 request와 무관      delay(100)      println( job2: before suspend function, $coroutineContext )      delay(1000)      println( job2: after suspend function, $coroutineContext ) // 무관하므로 실행된다.     }  }  delay(500)  request. cancel()  delay(1000)  println( end )}1234567runBlocking: [Blocking. . . {Active}. . . , BlockingEventLoop. . . ]request: [Standalone. . . {Active}. . . , BlockingEventLoop. . . ]job1: before suspend function, [Standalone. . . {Active}. . . , DefaultDispatcher]job2: before suspend function, [Standalone. . . {Active}. . . , DefaultDispatcher]job1: after suspend function, [Standalone. . . {Active}. . . , DefaultDispatcher]job2: after suspend function, [Standalone. . . {Active}. . . , DefaultDispatcher]end실행방법의 비교1. 1234567891011121314151617fun work(i: Int) {  Thread. sleep(1000)  println( Work $i done )}fun main() {  val time = measureTimeMillis {    runBlocking {      for (i in 1. . 2) {        launch {          work(i)        }      }    }  }  println( Done in $time ms )}123Work 1 doneWork 2 doneDone in 2268 ms생성된 두개의 작업은 단일 스레드에서 순차적으로 실행 된다. 2. 1234567891011121314151617fun work(i: Int) {  Thread. sleep(1000)  println( Work $i done )}fun main() {  val time = measureTimeMillis {    runBlocking {      for (i in 1. . 2) {        launch(Despatchers. Default) {          work(i)        }      }    }  }  println( Done in $time ms )}123Work 1 doneWork 2 doneDone in 1260 ms생성된 두개의 작업은 동시성을 제공하여 분리된 작업으로 실행된다. 3. 1234567891011121314151617fun work(i: Int) {  Thread. sleep(1000)  println( Work $i done )}fun main() {  val time = measureTimeMillis {    runBlocking {      for (i in 1. . 2) {        GlobalScope. launch {          work(i)        }      }    }  }  println( Done in $time ms )}1Done in 118 ms부모와 무관한 독립 실행이므로 작업 완료를 기다리지 않는다. (join()으로 기다려줘야 한다. ) 빌더의 특정 속성 지정: 시작 시점에 대한 속성 - launch의 원형 123456789public fun launch(  context: CoroutineContext,  start: CoroutineStart,  parent: Job?,  onCompletion: CompletionHandler?,  block: suspend CoroutineScope. () -&gt; Unit): Job {    . . .   })CooroutineStart  DEFAULT: 즉시 시작(해당 문맥에 따라 즉시 스케쥴링 됨) LAZY: 코루틴을 느리게 시작(처음에는 중단된 상태이며 start()나 await() 등으로 시작) ATOMIC: 원자적으로 즉시 시작(DEFAULT와 비슷하나 코루틴을 실행저에는 취소 불가) UNDISPATCHED: 현재 스레드에서 즉시 시작(첫 지연함수까지, 이후 재개시 디스패치 된다)start() 혹은 await()가 호출될 때 실제로 시작  launch나 async는 즉시 실행되지만 start 옵션에 따라 실행시점을 늦출 수 있다.   123val job = async(start = CoroutineStart. LAZY) { doWork1() }. . . job. start() // 실제 시작 시점으로 또는 job. await()으로 시작됨    안드로이드의 버튼을 통한 시작 예  123456val someJob = launch(start = CoroutineStart. LAZY) { // some code //}someButton. setOnClickListener { someJob. start()}   "
    }, {
    "id": 155,
    "url": "/study_Kotlin_39/",
    "title": "Kotlin 객체편 - [29]",
    "body": "2020/08/20 - 코루틴 문맥: Coroutine Context  코루틴을 실행하기 위한 다양한 설정값을 가진 관리 정보     코루틴 이름, 디스패처, 작업 상세사항, 예외 핸들러 등    디스패처는 코루틴 문맥을 보고 어떤 스레드에서 실행되고 있는지 식별이 가능해진다.  코루틴 문맥은 + 연산을 통해 조합될 수 있다. 1val comCoroutineContext = someJob + Dispatchers. IO + someCoroutineName + someExceptionHandler관련 문맥 CoroutineName  코루틴에 이름을 주며 디버깅을 위해서 사용된다  1val someCoroutineName = CoroutineName( someCoroutineName )   Job  작업 객체를 지정할 수 있으며 취소가능 여부에 따라 SupervisorJob() 사용  12val parentJob = SupervisorJob() // or Job()val someJob = Job(parentJob)   CoroutineDispatcher  dispatchers. Default, …IO, 등을 지정할 수 있으며 필요에 따라 스레드풀 생성 가능  1val MyPool = Executors. newFixedThredPool(2). asCoroutineDispatcher()   CoroutineExceptionHandler  코루틴 문맥을 위한 예외처리를 담당하며 코루틴에서 예외가 던져지면 처리한다.  예외가 발생한 코루틴은 상위 코루틴에 전달되어 처리될 수 있다.      스코프를 가지는 경우 예외 에러를 잡아서 처리할 수 있다.     만일 예외처리가 자식에만 있고 부모에 없는 경우 부모에도 예외가 전달되므로 주의     이 경우 앱이 깨지게(crash)됨    예외가 다중으로 발생하면 최초 하나만 처리하고 나머지는 무시됨12345// 예외 선언val someExceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable -&gt;   val coroutineName = coroutineContext[CoroutineName]?. name ?:  default coroutine name   println( Error in $coroutineName: ${throwable. localizedMessage} )}코루틴의 스코프: GlobalScope  독립형(Standalone)코루틴을 구성, 생명주기는 프로그램 전체(top-level)에 해당하는 범위를 가지며 main의 생명 주기가 끝나면 같이 종료됨 Dispatchers. Unconfined와 함께 작업이 서로 무관한 전역 범위 실행 보통 GlobalScope 상에서는 launch나 async 사용이 권장되지 않음CoroutineScope  특정 목적의 디스패처를 지정한 범위를 블록으로 구성할 수 있다.  모든 코루틴 빌더는 CoroutineScope의 인스턴스를 갖는다.  launch {…}와 같이 인자가 없는 경우에는 CoroutineScope에서 상위의 문맥이 상속되어 결정 (기본값) launch(Dispatchers. 옵션인자) {…}와 같이 디스패처의 스케쥴러를 지정가능     Dispatchers. Default는 GlobalScope에서 실행되는 문맥과 동일하게 사용   코루틴 스코프 사용 예시 GlobalScope 12345//GlobalScopeval scope1 = GlobalScope// 권장하지 않는 사항scope1. launch { . . . } scope1. async { . . . }1234//GlobalScopeGlobalScope. launch { . . . }val job1 = GlobalScope. launch { . . . } // Job 객체 -&gt; Job. join()으로 기다림val job2 = GlobalScope. async { . . . } // Deferred 객체 -&gt; Deferred. await()으로 기다림(결과 반환)CoroutineScope 1234//CoroutineScopeval scope2 = CoroutineScope(Dispatcher. Default)val routine1 = scope2. launch { . . . }val routine2 = scope2. async { . . . }123//CoroutineScopelaunch(Dispatcher. Default) { . . . } async(Dispatcher. Default) { . . . } practice 1234567891011121314151617181920import kotlinx. coroutines. *fun main() = runBlocking { // Main이 runBlocking 스코프가 된다. 일종의 하나의 코루틴 스코프   launch { // 단순히 launch의 인자를 사용하지 않음(생략함)으로써 상위의 문맥이 상속되게 한다.     delay( 200L )    println( Task from runBlocking)  }  coroutineScope {    launch {      delay( 200L )      println( Task frm nested launch )    }    delay( 200L )    println( Task from coroutineScope )  }  println( end of runBlocking )}1234Task from coroutineScopeTask from runBlockingTask from nested launchend of runBlocking1234567891011121314151617181920import kotlinx. coroutines. *fun main() = runBlocking {   launch {     delay( 1200L ) // 시간을 더 줘서 나중에 출력하도록 한다.     println( Task from runBlocking)  }  coroutineScope {    launch {      delay( 200L )      println( Task frm nested launch )    }    delay( 200L )    println( Task from coroutineScope )  }  println( end of runBlocking )}1234Task from coroutineScopeTask from nested launchend of runBlockingTask from runBlocking 123456789101112131415161718192021import kotlinx. coroutines. *fun main() = runBlocking {   launch {     delay( 1200L )     println( Task from runBlocking)  }  coroutineScope {    launch {      delay( 1500L ) /* 해당 시간을 늘려주면 coroutineScope의 시간 전체가 증가하므로              runBlocking의 launch가 실행될 여유가 생긴다. */      println( Task frm nested launch )    }    delay( 200L )    println( Task from coroutineScope )  }  println( end of runBlocking )}1234Task from coroutineScopeTask from runBlockingTask from nested launchend of runBlocking1234567891011121314151617181920import kotlinx. coroutines. *fun main() = runBlocking(Dispatchers. Default) { // 필요에 따라 인자가 주어질 수 있다.   launch(Dispatchers. IO) { // launch 또한 필요에 따라 인자가 주어질 수 있다.     delay( 1200L )     println( Task from runBlocking)  }  coroutineScope { // 인자가 주어질 수 없다!    launch {      delay( 1500L )      println( Task frm nested launch )    }    delay( 200L )    println( Task from coroutineScope )  }  println( end of runBlocking )}1234Task from coroutineScopeTask from runBlockingTask from nested launchend of runBlocking"
    }, {
    "id": 156,
    "url": "/study_Kotlin_38/",
    "title": "Kotlin 객체편 - [28]",
    "body": "2020/08/20 - 1234567891011121314151617181920212223242526import kotlinx. coroutines. *suspend fun doWork1(): String {  delay( 1000 )  return  Work1 }suspend fun doWork2(): String {  delay( 3000 )  return  Work2 }private fun worksInSerial() {  // 순차적 실행  GlobalScope. launch {    val one = doWork1()    val two = doWork2()    println( Kotiln One : $one )    println( Kotiln two : $two )  }}fun main() {  worksInSerial()  readLine()}12Kotlin One : Work1Kotlin Two : Work21234567891011121314151617181920212223242526import kotlinx. coroutines. *suspend fun doWork1(): String {  delay( 3000 )  return  Work1 }suspend fun doWork2(): String {  delay( 1000 ) // 시간을 반대로 하더라도 같은 결과  return  Work2 }private fun worksInSerial() {  // 순차적 실행  GlobalScope. launch {    val one = doWork1()    val two = doWork2()    println( Kotiln One : $one )    println( Kotiln two : $two )  }}fun main() {  worksInSerial()  readLine() // Enter를 눌러서 종료되게끔 하는 장치}12Kotlin One : Work1Kotlin Two : Work212345678910111213141516171819202122232425262728293031import kotlinx. coroutines. *suspend fun doWork1(): String {  delay( 3000 )  return  Work1 }suspend fun doWork2(): String {  delay( 1000 ) // 시간을 반대로 하더라도 같은 결과  return  Work2 }private fun worksInSerial(): Job {  // 순차적 실행  val job = GlobalScope. launch {    val one = doWork1()    val two = doWork2()    println( Kotiln One : $one )    println( Kotiln two : $two )  }  return job}fun main() = runBlocking {  val time = measureTimeMillis {    val job = worksInSerial()    job. join()  }  println( time: $time )}123Kotlin One : Work1Kotlin Two : Work2time: 4026 // 병행적으로 실행되지 않고 순차적임을 알수 있다. async 코루틴 빌더 생성: 동시성 처리를 위한 async 코루틴  launch와 다른 점은 Deferred를 통해 결과값을 반환 지연된 결과 값을 받기 위해 await()를 사용123456789101112131415161718192021222324. . . private fun worksInParallel() {  // Deferred&lt;T&gt; 를 통해 결과값을 반환  // 새로운 코루틴 빌더 (병행 처리!)  /*------------------------------------------------*/  val one = GlobalScope. async {    doWork1()  }  /*------------------------------------------------*/  // 새로운 코루틴 빌더 (병행 처리!)  /*------------------------------------------------*/  val two = GlobalScope. async {    doWork2()  }  /*------------------------------------------------*/  // await에서 대기!  /*------------------------------------------------*/  GlobalScope. launch {    val combined = one. await() +  _  + two. await()    println( Kotlin Combined : $combined )  }  /*------------------------------------------------*/}. . . 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import kotlinx. coroutines. *suspend fun doWork1(): String {  delay( 3000 )  return  Work1 }suspend fun doWork2(): String {  delay( 1000 ) // 시간을 반대로 하더라도 같은 결과  return  Work2 }private fun worksInSerial(): Job {  // 순차적 실행  val job = GlobalScope. launch {    val one = doWork1()    val two = doWork2()    println( Kotiln One : $one )    println( Kotiln two : $two )  }  return job}private fun worksInParallel(): Job {  // 순차적 실행  val one = GlobalScope. async {    doWork1()  }  val two = GlobalScope. async {    doWork2()  }  val job = GlobalScope. launch {    val combined = one. await() +  _  + two. await()    println( Kotlin Combined: $combined )  }  return job}fun main() = runBlocking {  val time = measureTimeMillis {    val job = worksInParallel()    job. join()  }  println( time: $time )}123Kotlin One : Work1Kotlin Two : Work2time: 3026 // 병행적으로 실행 하고 있음을 할 수 있다. "
    }, {
    "id": 157,
    "url": "/study_Kotlin_37/",
    "title": "Kotlin 객체편 - [27]",
    "body": "2020/08/19 - Job(): 1234567891011121314151617import kotlinx. coroutines. *fun main() {  val job = GlobalScope. launch() {    delay( 1000L )    println( World )    doSomething()  }  println( Hello )  println( job: $job )  THread. sleep( 2000L )  println( job: $job )}suspend fun doSomething() {  println( Do Something )}12345Hellojob: StandaloneCoroutine{Active}@. . . . WorldDo Somethingjob: StandaloneCoroutine{Completed}@. . . . 1234567891011121314151617import kotlinx. coroutines. *fun main() {  val job = GlobalScope. launch() {    delay( 1000L )    println( World )    doSomething()  }  println( Hello )  println( job: ${job. isActive}, ${job. isCompleted} )  THread. sleep( 2000L )  println( job: ${job. isActive}, ${job. isCompleted} )}suspend fun doSomething() {  println( Do Something )}12345Hellojob: true, falseWorldDo Somethingjob: false, trueJob 객체: Job  코루틴의 생명주기를 관리하며 생성된 코루틴 작업들은 부모-자식과 같은 관계를 가질 수 있다. Job 규칙  부모가 취소(cancel)되거나 실행 실패하면 그 하위 자식들은 모두 취소된다.  자식의 실패는 그 부모에 전달되며 부모 또한 실패한다. (다른 모든 자식도 취소됨)SupervisorJob  자식의 실패가 그 부모나 다른 자식에 전달되지 않으므로 실행을 유지할 수 있다. Join() 결과 기다리기: Join()  Job 객체의 join()을 사용해 완료를 기다릴 수 있다.      launch에서 반환 값을 받으면 Job 객체가 되기 때문에 이것을 이용해 main 메서드에서 join()을 호출할 수 있다.    123456789. . . fun main() = runBlocking&lt;Unit&gt; {  val job = launch { // Job의 객체를 반환    delay(1000L)    println( World! )  }  println( Hello )  job. join() // 명시적으로 코루틴이 완료되길 기다림. 취소할 경우 job. cancel()을 사용}1234567891011121314151617181920import kotlinx. coroutines. *fun main() {  runBlocking { // coroutine Block 생성!    val job = GlobalScope. launch() {      delay( 1000L )      println( World )      doSomething()    }    println( Hello )    println( job: ${job. isActive}, ${job. isCompleted} )    job. join() // launch가 완료될 때까지 상위 루틴은 블록킹한다.     // join()이 suspend 함수라서 coroutine 안에서만 사용가능    println( job: ${job. isActive}, ${job. isCompleted} )  }}suspend fun doSomething() {  println( Do Something )}12345Hellojob: true, falseWorldDo Somethingjob: false, trueJob의 상태: | 상태 | isActive | isCompleted | isCancelled || — | — | — | — || New | false | false | false || Active(기본값 상태) | true | false | false || Completing | true | false | false || Cancelling | false | false | true || Cancelled(최종 상태) | false | true | true || Completed(최종 상태) | false | true | false | 코루틴의 중단과 취소: 중단 (코루틴 코드 내에서)  delay(시간값) - 일정 시간을 지연하며 중단 yield() - 특정 값을 산출하기 위해 중단취소 (코루틴 외부에서)  Job. cancel() - 지정된 코루틴 작업을 즉시 취소 Job. cancelAndJoin() - 지정된 코루틴 작업을 취소 (완료시까지 기다림) 기본적으로 부모 자식 관계에 적용될 수 있으며 부모 블록이 취소되면 모든 자식 코루틴이 취소된다. "
    }, {
    "id": 158,
    "url": "/study_Kotlin_36/",
    "title": "Kotlin 객체편 - [26]",
    "body": "2020/08/19 - 코루틴: 개념  스레드와 달리 코틀린은 코루틴을 통해 복잡성을 줄이고도 손쉽게 일시 중단하거나 다시 시작하는 루틴을 만들어 낼 수 있다.  멀티태스킹을 실현하면서 가벼운 스레드라고도 불림 코루틴은 문맥 교환 없이 해당 루틴을 일시 중단(suspended)을 통해 제어코루틴의 주요 패키지:    kotlinx. coroutines의 common 패키지| 기능 | 설명 || — | — || launch / async | 코루틴 빌더 || Job / Deferred | cancellation 지원을 위한 기능 || Dispatchers | Default는 백그라운드 코루틴읠 위한 것이고 Main은 Android나 Swing, JavaFx를 위해 사용 || delay / yield | 상위 레벨 지연(suspending) 함수 || Channel / Mutex | 토신과 동기화를 위한 기능 || coroutineScope / supervisorScope | 범위 빌더 || select | 표현식 지원 |     core 패키지| 기능 | 설명 || — | — || CommonPool | 코루틴 컨텍스트 || produce / actor | 코루틴 빌더 |  코루틴 빌더: launch  일단 실행하고 잊어버리는(fire-and-forget) 형태의 코루틴으로 메인 프로그램과 독립하여 실행할 수 있다.  기본적으로 즉시 실행하며 블록 내의 실행 결과는 반환하지 않는다.  상위 코드를 블록 시키지 않고(넌블로킹) 관리를 위한 Job 객체를 즉시 반환한다.  join을 통해 상위 코드가 종료되지 않고 완료를 기다리게 할 수 있다. async  비동기 호출을 위해 만든 코루틴으로 결과나 예외를 반환한다.  실행 결과는 Deffered를 통해 반환하며 await를 통해 받을 수 있다.  await는 작업이 완료될 때까지 기다리게 된다. practice 우선 코루틴 라이브러리를 사용하기 위해선 Project Structure에 들어야 한다. intelliJ - File - Project Structure (Ctrl + Alt + Shift + S) 좌측 배너에서 Libraries에 들어가서 라이브러리를 추가해 주어야 하는데, 기본 설정 방법인 Maven을 이용해 추가를 할 수있다. (Gradle도 가능하다. ) 중간 배너에서 +를 클릭하고, Maven을 클릭한 뒤 coroutine을 검색할 수 있다. 검색 결과중 가장 최신 라이브러리를 가지고 오면 된다. 12345678910111213import kotlinx. coroutines. *// 1번 코루틴fun main() { // 메인 스레드의 문맥   /*-------------------------------------------------------------*/  // 2번 코루틴  GlobalScope. launch { // 새로운 코루틴을 백그라운드에 실행    delay(1000L) // 1초의 넌블로킹 지연 (시간의 기본단위는 ms)    println( World! ) // 지연 후 출력  }  /*--------------------------------------------------------------*/  println( Hello, ) // main 스레드가 코루틴이 지연되는 동안 계속 실행  Thread. sleep(2000L) // main 스레드가 JVM에서 바로 종료되지 않게 2초 기다림}일시 중단(suspended)함수  delay()의 경우 일시 중단될 수 있으며 필요한 경우 재개(resume)된다.      이 소스의 경우 약 1초 후   delay()의 선언부 123// kotlinx-coroutines-core의 DelayKt. class의 일부public suspend fun delay(timeMillis: kotlin. Long) kotlin. Unit {   /* compiled code */ } suspend 함수를 코루틴 블록 외에 사용하면 오류가 난다. 사용자 함수에 suspend적용 123suspend fun doSomething() {  println( Do something! )} 컴파일러는 suspend가 붙은 함수를 자동적으로 추출해 Continuation 클래스로부터 분리된 루틴을 만든다.  이러한 함수를 사용하기 위해 코루틴 빌더인 launch와 async에서 이용할 수 있다. practice 12345678910import kotlinx. coroutines. *fun main() {  GlobalScope. launch() {    delay( 1000L )    println( World )  }  println( Hello )}1Hello코루틴이 돌고 있다 하더라도 println(“Hello”)의 동작을 마치면 함수가 끝나므로 World를 출력하지 않는다. 12345678910import kotlinx. coroutines. *fun main() {  GlobalScope. launch() {    delay( 1000L )    println( World )  }  println( Hello )  THread. sleep( 2000L )}12HelloWorld12345678910111213141516import kotlinx. coroutines. *fun main() {  //doSomething() // Error! suspend 함수는 coroutine 안에서만 사용 가능!  GlobalScope. launch() {    delay( 1000L )    println( World )    doSomething()  }  println( Hello )  THread. sleep( 2000L )}suspend fun doSomething() {  println( Do Something )}123HelloWorldDo Something"
    }, {
    "id": 159,
    "url": "/study_Kotlin_35/",
    "title": "Kotlin 객체편 - [25]",
    "body": "2020/08/19 - 동시성 프로그래밍: 동기적(synchronous) 수행  순서대로 작업을 수행하여 하나의 루틴을 완료한 후 다른 루틴을 실행하는 방식 다양한 기능이 한꺼번에 일어나는 다중 실행 환경에서는 성능상의 제약 발생     예시) UI, 데이터 다운로드를 동시에 대응해야 하는 경우   비동기적(asynchronous) 수행  다양한 기능을 동시에 수행할 수 있는 방식 전통적인 스레드를 이용하거나 RxJava, Reactive와 같은 서드파티(third-party)라이브러리에서 제공 코틀린에서는 코루틴 (coroutines)을 기본으로 제공코루틴  먼저 하나의 개별적인 작업을 루틴(routine)이라고 부르는데 여러 개의 루틴들이 협력(co)한다는 의미로 만들어진 합성어 코틀린의 코루틴을 사용하면 넌블로킹(non-blocking) 또는 비동기 코드를 마치 일반적인 동기 코드처럼 쉽게 작성하면서도 비동기 효과를 낼 수 있다.  Concurrency(병행성) : 시간을 짧게 나눠 하나의 코어에서 실행 - OS의 스케쥴러에서 처리를 해준다. 프로세스와 스레드: 태스크(Task) 개념  보통 태스크는 큰 실행 단위인 프로세스(process)나 조금 더 작은 실행 단위인 스레드(thread)로 생각할 수 있다.  프로세스는 실행되는 메모리, 스택, 열린 파일 등을 모두 포함하기 때문에 프로세스간 문맥 교환(context-switching)을 하는 데 비용이 크다.  스레드는 자신의 스택만 독립적으로 가지고 나머지는 대부분 공유하므로 문맥 교환 비용이 낮아 프로그래밍에서 많이 사용된다.  다만 여러 개의 스레드를 구성하면 코드가 복잡하다. 문맥 교환(context-switching)  하나의 프로세스나 스레드가 CPU를 사용하고 있는 상태에서 다른 프로세스나 스레드가 CPU를 사용하도록 하기 위해, 이전의 프로세스의 상태(문맥)를 보관하고 새로운 프로세스의 상태를 적재하는 과정(코루틴 자체에서는 문맥 교환이 없다고 할 수 있다. ) 스레드 연습 1234567891011121314151617181920212223242526272829303132// 클래스class SimpleThread : Thread() {  override fun run() {    println( Class Thread ${Thread. currentThread()} )  }}// 인터페이스class SimpleRunnalbe : Runnable {  override fun run() {    println( Interface Thread ${Thread. currentThread()} )  }}fun main() {  val thread = SimpleThread()  thread. start()  val runnalbe = SimpleRunnable()  val thread2 = Thread(runnable)  thread2. start()  // 익명 객체  object : Thread() {    override fun run() {      println( object Thread: ${Thread. currentThread()} )    }  }. start()  // 람다식  Thread {    println( Lambda Thread: ${Thread. currentThread()} )})  }. start()}123456789101112131415161718192021222324252627282930// 람다식 추가 함수를 만들어 실행public fun thread(start: Boolean = true, isDaemon: Boolean = false,         contextClassLoader: ClassLoader? = null, name: String? = null,         priority: Int = -1, block: () -&gt; Unit): Thread {    val thread = obejct : Thread() {    public override fun run() {      block()    }  }  if (isDaemon) thread. isDaemon = true // 백그라운드 실행 여부  if (priority &gt; 0) thread. priority = priority // 우선순위 ( 1: 낮음 ~ 5: 보통 ~ 10: 높음) [default는 5]  if (name != null) thread. name = name // 이름  if (contextClassLoader != null) thread. contextClassLoader = contextClassLoader  if (start) thread. start()  return thread}fun main() {  // 스레드의 옵션 변수를 손쉽게 설정할 수 있다.   thread(start = true) {    println( Current Threads(Custom function): ${Thread. currentThread()} )    println( Priority: ${Thread. currentThread(). priority} ) // 기본값은 5    println( Name: ${Thread. currentThread(). name} )    println( Name: ${Thread. currentThread(). isDaemon} )  }}1234Current Threads(Custom function): Thread[Thread-0,5,main]Priority: 5Name: Thread-0Name: false스레드 풀 사용하기: newFixedThreadPool()  자주 재사용되는 스레드를 이요하기 위해 미리 생성된 스레드풀에서 스레드 이용 예시) 8개의 스레드로 특정 백그라운드 서비스를 ㅏ도록 만든다고 했을 때1234567891011val myService:ExecutorService = Executors. newFixedThreadPool(8)var i = 0while (i &lt; items. size) { // 아주 큰 데이터를 처리할 때  val item = items[i]  myService. submit {    processItem(item) // 여기서 아주 긴 시간 동안 처리 하는 경우  }  i += 1}"
    }, {
    "id": 160,
    "url": "/study_Kotlin_34/",
    "title": "Kotlin 객체편 - [24]",
    "body": "2020/08/19 - Mapping 관련 연산: map()  주어진 컬렉션의 요소를 일괄적으로 모든 요소에 식을 적용해 새로운 컬렉션을 만든다.  forEach와는 다르게 주어진 컬렉션을 건드리지 않는다. 1234567891011121314fun main() {  val list = listOf(1, 2, 3, 4, 5, 6)  val listWithNull = listOf(1, null, 3, null, 5, 6)  // map: 컬렉션에 주어진 식을 적용해 새로운 컬렉션 반환  println(list. map { it * 2}) // [2, 4, 6, 8, 10, 12]  // mapIndexed: 컬렉션에 인덱스를 포함해 주어진 식을 적용해 새로운 컬랙션 반환  val mapIndexed = list. mapIndexed { index, it -&gt; index * it }  println(mapIndexed) // [0, 2, 6, 12, 20, 30]  // mapNotNull: null을 제외하고 식을 적용해 새로운 컬렉션 반환  println(listWithNull. mapNotNull { it?. times(2) }) // [2, 6, 10, 12]}flatMap()  각 요소에 식을 적용한 후 이것을 다시 하나로 합쳐 새로운 컬렉션을 반환1234// flatMap: 각 요소에 식을 적용 후 다시 합쳐 새로운 컬렉션을 반환println(list. flatMap { listOf(it, 'A')})val result = listOf( abc ,  12 ). flatMap { it. toList() }println(result)12[1, A, 2, A, 3, A, 4, A, 5, A, 6, A][a, b, c, 1, 2]groupBy()  주어진 식에 따라 요소를 그룹화 하고 이것을 다시 Map으로 반환     이때, 해당 값은 Pair&lt;String, List&lt;–» 이 된다.    123// groupBy: 주어진 함수의 결과에 따라 그룹하 하여 map으로 반환val grpMap = list. groupBy { if (it % 2 == 0)  even  else  odd  }println(grpMap) // {odd=[1, 3, 5], even=[2, 4, 6]}요소 처리와 검색 연산: element 관련 연산  보통 인덱스와 함께 해당 요소의 값을 반환 식에 따라 처리하거나 인덱스를 벗어나면 null을 반환1234567891011121314151617fun main() {  val list = listOf(1, 2, 3, 4, 5, 6)  val listPair = listOf(Pair( A , 300), Pair( B , 200), Pair( C , 100), Pair( D , 200))  val listRepeated = listOf(2, 2, 3, 4, 5, 5, 6)  // elementAt: 인덱스에 해당하는 요소 반환  println( elementAt:   + list. elementAt(1))  // elementAtOrElse: 인덱스를 벗어나는 경우 식에 따라 결과 반환 아니면 요소 반환  println( elementAtOrElse:   + list. elementAtOrElse(10, { 2 * it }))  /*  elementAtOrElse(10) { 2 * it } 표현식과 동일  */  // elementAtorNull: 인덱스를 벗어나는 경우 null 반환  println( elementAtOrNull:   + list. elementAtOrNull(10))}123elementAt: 2elementAtOrElse: 20elementAtOrNull: null순서와 정렬 연산: 컬렉션에 대한 정렬 연산  reversed() sorted() / sortedDescending() sortedBy { it % 3 } / sortedByDescending { it % 3 }시퀀스: sequence  순차적으로 요소의 크기를 특정하지 않고 추후에 결정하는 특수한 컬렉션 예를 들어 특정 파일에서 줄 단위로 읽어서 요소를 만들 때 시퀀스는 처리 중에는 계산하고 있지 않다가 toList()나 count()같은 최종 연산에 의해 결정generateSequence  시드(seed) 인수에 의해 시작 요소의 값이 결정123456789fun main() {  // 시드값 1을 시작으로 1씩 증가하는 시퀀스 정의  val nums: Sequence&lt;Int&gt; = generateSequence(1) { it + 1 }  // take()를 사용해 원하는 요소 개수만큼 획득하고  // toList()를 사용해 List 컬렉션으로 반환  println(nums. take(10). toList())}1[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]map이나 fold같은 연산을 같이 이용 12345val squares = generateSequence(1) {it + 1}. map {it * it}println(squares. take(10). toList())val oddSquares = squares. filter { it % 2 != 0 }println(oddSquares. take(5). toList())12[1, 4, 9, 16, 25, 36, 49, 64, 81, 100][1, 9, 25, 49, 81] 메서드 체이닝(chaining)하여 연속해서 쓴다면 하나의 구문이 끝날 때마다 중간 결과로 새로운 List를 계속해서 만들어 낸다. asSequence()  중간 연산 결과 없이 한 번에 끝까지 연산한 후 결과를 반환     filter나 map을 메서드 체이닝해서 사용할 경우 순차적 연산이기 때문에 시간이 많이 걸릴 수 있지만 asSequence()를 사용하면 병렬 처리되기 떄문에 처리 성능이 좋아짐   12345678fun main() {  // 단순 메서드 체이닝을 사용할 때  val list1 = listOf(1, 2, 3, 4, 5)  val listDefault = list1      . map { println( map($it)  ); it * it }      . filter { println( filter($it)  ); it % 2 == 0 }  println(listDefault)}1234567891011map(1)map(2)map(3)map(4)map(5)filter(1)filter(4)filter(9)filter(16)filter(25)[4, 16]123456. . . val listSeq = ist1. asSequence()    . map { print( map($it)  ); it * it } // 1    . filter { println( filter($it)  ); it % 2 == 0 } // 2    . toList() // 3println(listSeq)123456map(1) filter(1)map(2) filter(4)map(3) filter(9)map(4) filter(16)map(5) filter(25)[4, 16] 3번 과정에 의해 TransformingSequence의 형태인 최종 결과를 List 목록으로 변환할 때, 모든 연산이 수행되고 결과물이 새로운 리스트인 listSeq에 지정 요소의 개수가 많을 때 속도나 메모리 측면에서 훨씬 좋은 성능을 낼 수 있다"
    }, {
    "id": 161,
    "url": "/study_Kotlin_33/",
    "title": "Kotlin 객체편 - [23]",
    "body": "2020/08/19 - 컬렉션의 확장 함수: 코틀린은 컬렉션을 위한 많은 확장 함수를 제공하고 있다. 확장 함수 범주  연산자(operators) 기능의 메서드: 더하고 빼는 등의 기능 집계(aggregators) 기능의 메서드: 최대, 최소, 집합, 총합 등의 계산 기능 검사(checks) 기능의 메서드: 요소를 검사하고 순환하기 위한 기능 필터(filtering) 기능의 메서드: 원하는 요소를 골라내기 위한 기능 변환(transformers) 기능의 메서드: 뒤집기, 정렬, 자르기 등의 변환 기능예시 1234567891011121314151617181920212223242526fun main() {  // 연산자를 사용하게 될 경우, 기존 컬렉션의 값을 바꾸는 것이 아닌 새로운 컬렉션을 만드는 것임을 기억하자!  val list1 = listOf( one ,  two ,  three )  val list2 = listOf(1, 2, 3)  val list3: List&lt;Int&gt; = listOf(1, 2, 3)  // val list3: List&lt;Int&gt; = listOf(1, 2, 3,  Hello ) // Error!  println(list1 +  four ) // + 연산자를 사용한 문자열 요소 추가 : [one, two, three, four]  println(list1 -  one ) // 요소의 제거 : [two, three]  println(list1) // [one, two, three] 불변형!  println(list1 + listOf( abc ,  def )) // 두 lIst의 병합 : [one, two, three, abc, def]    println(list2 + 4) // [1, 2, 3, 4]  println(list2 +  Hello ) // [1, 2, 3, Hello]   println(list2 - 1) // [2, 3]  println(list2 - listOf(2, 3, 4)) // 일차하는 요소의 제거 : [1]  println(list2) // [1, 2, 3]    println(list3 +  Hello ) // [1, 2, 3, Hello] 새로운 컬렉션이 생성된다고 할수 있기 때문에 가능하다.   val map1 = mapOf( hi  to 1,  hello  to 2,  Goodbye  to 3)  println(map1 + Pair( Bye , 4)) // Pair()를 사용한 Map의 요소 추가  println(map1 -  hello ) // 일치하는 값의 제거  println(map1 + mapOf( Apple  to 4,  Orange  to 5)) // Map의 병합  println(map1 - listOf( hi ,  hello )) // List에 일치하는 값을 Map에서 제거}요소의 처리와 집계에 대한 연산: 요소를 집계를 위한 확장 함수  forEach, forEachIndexed, onEach, count, max, min, maxBy, minBy, fold, reduce, sumBy 등요소의 순환  forEach: 각 요소를 람다식으로 처리한 후 컬렉션을 반환하지 않음 onEach: 각 요소를 람다식으로 처리한 후 컬렉션을 반환 받음forEach 예시 12345678910fun main() {  val list = listOf(1, 2, 3, 4, 5, 6)  val listPair = listOf(Pair( A , 300), Pair( B , 200), Pair( C , 100))  val map = mapOf(11 to  Java , 22 to  Kotlin , 33 to  C++ )  // forEach: 각 요소를 람다식으로 처리  list. forEach { print( $it  )}  println()  list. foreachInexed { index, value -&gt; println( index[$index] : $value ) } // 인덱스 포함}12345671 2 3 4 5 6index[0] : 1 index[1] : 2index[2] : 3index[3] : 4index[4] : 5index[5] : 6onEach 예시 123456  // onEach: 각 요소를 람다식으로 처리한 후 컬렉션으로 반환  val returnedList = list. onEach { print(it) }  println()  val returnedMap = map. onEach { println( key: ${it. ket}, value: ${it. value} ) }  println( returnedList = $returnedList )  println( returnedMap = $returnedMap )123456123456key: 11, value: Javakey: 22, value: Kotlinkey: 33, value: C++returnedList = [1, 2, 3, 4, 5, 6]returnedMap = {11=Java, 22=Kotlin, 33=C++}forEach에서 break의 기능을 할수 있도록 해보자: 사실 확장 함수로서 return의 지점을 정해주는 것이 정확한 표현이지만 더 기억하기 쉽도록 하자. 123456789101112131415class Solution {  fun solution(seoul: Array&lt;String&gt;): String {    var answer = 0    run loop@{      seoul. forEachIndexed{ index, value -&gt;        if(value. contains( Kim )) {          answer = index          return@loop        }      }    }    return  김서방은 ${answer}에 있다   }}요소를 집계를 위한 확장 함수: 각 요소의 정해진 식 적용  fold와 reduce : 초기 값과 정해진 식에 따라 요소에 처리하기 위해     fold는 초기값과 정해진 식에 따라 처음 요소부터 끝 요소에 적용해 값 반환   reduce는 fold와 동일하지만 초기값을 사용하지 않는다.     foldRight, reduceRight: 위의 개념과 동일하지만 요소의 마지막(오른쪽)요소에서 처음 요소로 순서대로 적용한다. 12345678910111213val list = listOf(1, 2, 3, 4, 5, 6)// fold: 초기값과 정해진 식에 따라 처음 요소부터 끝 요소에 적용하며 값을 생성println(list. fold(4) { total, next -&gt; total + next }) // 4 + 1 + . . . + 6 = 25println(list. fold(1) { total, next -&gt; total * next }) // 1 * 1 * 2 * . . . * 6 = 720// foldRight: fold와 같고 마지막 요소에서 처음 요소로 반대로 적용println(list. foldRight(4) { total, next -&gt; total + next }) // 4 + 6 + . . . + 1 = 25println(list. foldRight(1) { total, next -&gt; total * next }) // 1 * 6 * . . . * 1 = 720// reduce: fold와 동일하지만 초기값을 사용하지 않음println(list. reduce { total, next -&gt; total + next }) // 1 + . . . + 6 = 21println(list. reduceRight) { total, next -&gt; total + next }) // 6 + . . . + 1 = 21"
    }, {
    "id": 162,
    "url": "/study_Kotlin_32/",
    "title": "Kotlin 객체편 - [22]",
    "body": "2020/08/19 - Map: 개념  키(Key)와 값(Value)으로 구성된 요소를 저장한다.      키와 값은 모두 객체    키는 중복될 수 없지만 값은 중복 저장될 수 있다.      만약 기존에 저장된 키왇 ㅗㅇ일하면 기존의 값은 없어지고 새로운 값으로 대체 된다.    Map의 생성  불변형: mapOf() 가변형: mutableMapOf()mapOf() - 불변형: 1val map: Map&lt;키자료형, 값자료형&gt; = mapOf(키 to 값[, . . . ])키와 쌍은 ‘키 to 값’ 형태로 나타낸다. 123456789101112fun main() {  // 불변형 Map의 선언 및 초기화  val langMap: Map&lt;Int, String&gt; = mapOf(11 to  Java , 22 to  Kotlin , 33 to  C++ )  for ((key, value) in langMap) {    println( key = $key, value = &amp;value )  }  println( langMap[22] = ${langMap[22]} ) // 키 22에 대한 요소 출력  println( langMap. get(22) = ${langMap. get(22)} ) // 위와 동일한 표현  println( langMap. keys = ${langMap. keys} ) // 맵의 모든 키 출력}Map의 멤버       멤버   설명         size   맵 컬렉션의 크기를 반환한다.        keys   이 프로퍼티는 Set의 모든 키를 반환한다.        values   이 프로퍼티는 Set의 모든 값을 반환한다.        isEmpty()   맵이 비어있는지 확인하고 비어 있으면 true를, 아니면 false를 반환한다.        containsKey(key: K)   인자에 해당하는 키가 있다면 true를, 아니면 false를 반환한다.        containsValue(value: V)   인자에 해당하는 값이 있다면 true를, 아니면 false를 반환한다.        get(key: K)   키에 해당하는 값을 반환하며, 없으면 null을 반환한다.    MutableMap의 추가 멤버  추가, 삭제가 가능한 메서드 제공      멤버   설명         put(key: K, value: V)   키와 값의 쌍을 맵에 추가한다.        remove(key: K)   키에 해당하는 요소를 맵에서 제거한다.        putAll(from: Map&lt;out K, V&gt;)   인자로 주어진 Map 데이터를 갱신하거나 추가한다.        clear()   모든 요소를 지운다.    mutableMapOf() 예시 12345678910fun main() {  // 가변형 Map의 선언 및 초기화  val capitalCityMap: MutalbleMap&lt;String, String&gt; // 선언 시 키와 값의 자료형을 명시할 수 있음(추론 가능 시 생략도 가능)    = mutableMapOf( Korea  to  Seoul ,  China  to  Beijing ,  Japan  to  Tokyo )  println(capitalCityMap. values) // 값만 출력  println(capitalCityMap. keys) // 키만 출력  capitalCityMap. put( UK ,  London ) // 요소의 추가  capitalCityMap. remove( China ) // 요소의 삭제  println(capitalCityMap)}123[Seoul, Beiging, Tokyo][Korea, China, Japan]{Korea=Seoul, Japan=Tokyo, UK=London}putAll()을 사용해 맵 객체 통합해보기  기존 요소에 추가된 요소를 병합 할 수 있다. 1234// putAll()을 사용한 맵의 추가val addData = mutableMapOf( USA  to  Washington )capitalCityMap. putAll(addData)println(capitalCityMap) 기존 요소1{Korea=Seoul, Japan=Tokyo, UK=London} 병합된 요소1{Korea=Seoul, Japan=Tokyo, UK=London, USA=Washington}Map을 위한 기타 자료구조: 특정 자료구조 이용  Map에서도 자바의 HashMap, SortedMap과 LinkedHashMap을 사용할 수 있다.  hashMapOf(), sortedMapOf(), linkedMapOf()로 각각 초기화 SortedMap의 경우 기복적으로 키에 대해 오름차순 정렬된 형태로 사용 내부 구조는 앞서 설명했던 Set의 구조와 비슷하게 해시, 트리, 링크드 리스트의 자료구조로 구현예시 123456789101112131415import java. util. *fun main() {  // java. util. HashMap의 사용  val hashMap: HashMap&lt;Int, String&gt; = hashMapOf(1 to  Hello , 2 to  World )  println( hashMap = $hashMap )  // java. util. SortedMap의 사용  val sortedMap: SortedMap&lt;Int, String&gt; = sortedMapOf(1 to  Apple , 2 to  Bababa )  println( sortedMap = $sortedMap )  // java. util. LinkedHashMap의 사용  val linkedHash: LinkedHashMap&lt;Int, String&gt; = linkedMapOf(1 to  Computer , 2 to  Mouse )  println( linkedHash = $linkedHash )}123hashMap = {1=Hello, 2=World}sortedMap = {1=Apple, 2=Banana}linkedHash = {1=Computer, 2=Mouse}"
    }, {
    "id": 163,
    "url": "/study_Kotlin_31/",
    "title": "Kotlin 객체편 - [21]",
    "body": "2020/08/19 - Set: 개념  정해진 순서가 없는 요소들의 집합(set) 집합의 개념이기 때문에 동일한 요소를 중복해서 가질 수 없다. 생성 헬퍼 함수  불변형 Set : setOf() 가변형 Set : mutableSetOf()      함수   기능   불변형   가변형         contains   값이 있는지 확인   O   O       size   값의 개수   O   O       add   값 추가       O       remove   값 제거       O   예시 - 불변형 1234567fun main() {  val mixedTypesSet = setOf( Hello , 5,  world , 3. 14, 'c') // 자료형 혼합 초기화  var intSet: Set&lt;Int&gt; = setOf&lt;Int&gt;(1, 5, 5) // 정수형만 초기화  println(mixedTypeSet)  println(intSet)}12[Hello, 5, world, 3. 14, c][1, 5] intSet에서는 중복된 요소인 5가 결과에서 하나만 나타남예시 - 가변형 1234567891011fun main() {  // 가변형 Set 정의하기  val animals = mutableSetOf( Lion ,  Dog ,  Cat ,  Python ,  Hippo )  println(animals)  // 요소의 추가  animals. add( Dog ) // 이미 존재하므로 변화 없음  println(animals)  // 요소의 삭제  animals. remove( Phthon )  println(animals)}123[Lion, Dog, Cat, Python, Hippo][Lion, Dog, Cat, Python, Hippo][Lion, Dog, Cat, Hippo] add : 값 추가 remove : 값 제거Set의 여러 가지 자료구조: hashSetOf()  이 헬퍼 함수를 통해 생성하면 해시 테이블에 요소를 저장할 수 있는 자바의 HashSet컬렉션을 만든다.  HashSet은 불변성 선언이 없기 때문에 추가 및 삭제 등의 기능을 수행할 수 있다. 해시 테이블(Hash Table)  해시 테이블이란 내부적으로 키와 인덱스를 이용해 검색과 변경 등을 매우 빠르게 처리할 수 있는 자료구조HashSet의 생성 123456fun main() {  val intsHashSet: HashSet&lt;Int&gt; = hashSetOf(6, 3, 4, 7) // 불변성 기능이 없음  intsHashSet. add(5) // 추가  intsHashSet. remove(6) // 삭제  println(intsHashSet)}1[3, 4, 5, 7] HashSet은 결과와 같이 입력 순서와 중복된 요소는 무시된다.  정렬 기능은 없지만 해시값을 통해 요소를 찾아내므로 검색 속도는 O(1)의 상수 시간     필요한 값을 요청과 즉시 바로 찾아냄   자바의 TreeSet 컬렉션: sortedSetOf()  자바의 TreeSet 컬렉션을 정렬된 상태로 반환 java. util. * 패키지를 import 해야 한다.  TreeSet은 저장된 데이터의 값에 따라 정렬     이진 탐색 트리(binary-search tree)인 RB(red-black) 트리 알고리즘을 사용    HashSet보다 성능이 조금 떨어지고 데이터를 추가하거나 삭제하는 데 시간이 걸리지만 검색과 정렬이 뛰어나다는 장점이 있다. 이진 탐색 트리와 RB 트리  이진 탐색 트리가 한쪽으로 치우친 트리 구조를 가지게 되는 경우 트리 높이만큼 시간이 걸리게 되는 최악의 경우 시간이 만들어 질 수 있다.  RB 트리는 이 단점을 Red와 Black의 색상으로 치우친 결과 없이 구분되도록 해서 최악의 경우에도 검색 등의 처리에서 일정 시간을 보장하는 자료구조sortedSetOf()를 사용한 Set의 생성 1234567891011import java. util. *fun main() {  // 자바의 java. util. TreeSet 선언 즉, 자바는 불변형이 없으므로 모두 가변형!  val intsSortedSet: TreeSet&lt;Int&gt; = sortedSetOf(4, 1, 7, 2)  intsSortedSet. add(6)  intsSortedSet. remove(1)  println( intsSortedSet = ${intsSortedSet} )  intsSortedSet. clear() // 모든 요소 삭제  println( intsSortedSet = ${intsSortedSet} )}12intsSortedSet = [2, 4, 6, 7]intsSortedSet = []자바의 LinkedHashSet: linkedSetOf() 함수  자바의 LinkedHashSet 자료형을 반환하는 헬퍼 함수 자료구조 중 하나인 링크드 리스트(Linked-list)를 사용해 구현된 해시 테이블에 요소를 저장 HashSet, TreeSet보다 느리지만 데이터 구조상 다음 데이터를 가리키는 포인터 연결을 통해 메모리 저장 공간을 조금 더 효율적으로 사용한다. Set Specific Operations: Collection Set에서 제공하는 Operation  union : 합집합 intersection : 교집합 substract : 차집합함수로 사용이 가능하며, infix form으로도 사용이 가능하다. 12345678910val numbers = setOf( one ,  two ,  three )println(numbers. union(setOf( four ,  five )))println(numbers union setOf( four ,  five ))println(setOf( four ,  five ) union numbers)println(numbers intersect setOf( two ,  one ))println(numbers subtract setOf( three ,  four ))println(numbers subtract setOf( four ,  three ))123456[one, two, three, four, five][one, two, three, four, five][four, five, one, two, three][one, two][one, two][one, two]"
    }, {
    "id": 164,
    "url": "/study_Kotlin_30/",
    "title": "Kotlin 객체편 - [20]",
    "body": "2020/08/19 - 가변형 List - arrayListOf(): arrayListOf()  가변형 헬퍼 함수를 사용하면 손쉽게 요소를 추가하거나 삭제할 수 있따.  arrayListOf()는 가변형 List를 생성하지만 반환자료형은 자바의 ArrayList1public fun &lt;T&gt; arrayListOf(vararg elements: T): ArrayList&lt;T&gt;123456789import java. util. *fun main() {  // 가변형 List를 생성하고 자바의 ArrayList로 반환  val stringList: ArrayList&lt;String&gt; = arrayListOf&lt;String&gt;( Hello ,  Kotlin ,  Wow )  stringList. add( Java ) // 추가  stringList. remove( Hello ) // 삭제  println(stringList)}1[Kotlin, wow, Java]MutableList 인터페이스를 이용하는 헬퍼 함수: 가변형 mutableListOf() 함수  요소의 추가, 삭제 또는 교체를 위해 mutablelistOf()를 통해 생성 MutableList 형으로 반환1public fun &lt;T&gt; mutableListOf(varage elements: T): MutableList&lt;T&gt;add()와 removeAt() 메서드를 통해 추가/삭제가 가능하다 123456789101112fun main() {  // 가변형 List의 생성 및 추가, 삭제, 변경  val mutableList: MutableList&lt;String&gt; = mutableListOf&lt;String&gt;( Kildong ,  Dooly ,  Chelsu )  mutableList. add( Ben ) // 추가  mutableList. removeAt(1) // 인덱스 1 삭제  mutableList. removeAt(mutableList. size-1) // 인덱스 마지막 값 삭제  mutableList[0] =  Sean  // 인덱스 0을 변경, set(index: Int, element E)과 같은 역할  println(mutableList)  // 자료형의 혼합  val mutableListMixed = mutableListOf( Android ,  Apple , 5, 6, 'X')}12[Sean, Chelsu, Ben][Android, Apple, 5, 6, X]toMutableList() 1234567fun main{  val name: List&lt;String&gt; = listOf( one ,  two ,  three ) // 불변형 List 초기화  val mutableNames = names. toMutableList() // 새로운 가변형 List가 만들어짐  mutableNames. add( four ) // 가변형 List에 하나의 요소 추가  println(mutableNames)}1[onem two, three, four]List와 배열의 차이:  Array 클래스에 의해 생성되는 배열 객체는 내부 구조상 고정된 크기를 가진다.  코틀린의 List와 MutableList는 인터페이스로 설계되어 있고 이것을 하위에서 특정한 자료구조로 구현     LinkedList, ArrayList   고정된 크기의 메모리가 아니기 때문에 자료구조에 따라 늘리거나 줄이는 것이 가능   12val list1: List&lt;Int&gt; = LinkedList&lt;Int&gt;()val list2: List&lt;Int&gt; = ArrayList&lt;Int&gt;() Array는 제네릭 관점에서 상/하위 자료형 관계가 성립하지 않는 무변성이다.  List는 공변성이기 때문에 하위인 List가 List에List Specific Operations: Collection List에서 제공하는 Operation  Retrieving elements by index : index가 list의 크기를 넘어가는 경우를 대처하는데 도움을 준다.      getOrElse()   getOrNull()   12345val numbers = listOf(1, 2, 3, 4) println(numbers. get(0))println(numbers[0]) //numbers. get(5) // exceptionprintln(numbers. getOrNull(5)) println(numbers. getOrElse(5, {it}))123411null5 Retrieving list parts : List의 부분을 가지고 와준다.      subList   12val numbers = (0. . 13). toList() println(numbers. subList(3, 6))1[3, 4, 5]"
    }, {
    "id": 165,
    "url": "/study_Kotlin_29/",
    "title": "Kotlin 객체편 - [19]",
    "body": "2020/08/19 - Collection:  자주 사용되는 기초적인 자료구조를 모아놓은 일종의 프레임워크로 표준 라이브러리로 제공된다. 코틀린의 컬렉션  컬렉션의 종류로는 List, Set, Map 등이 있으며 자바와는 다르게 불변형(immutable)과 가변형(mutable)으로 나뉘어 컬렉션을 다룰 수 있다.       컬렉션   불변형(읽기 전용)   가변형         List   listOf   mutableListOf, arrayListOf       Set   setOf   mutableSetOf, hashSetOf, linkedSetOf, sortedSetOf       Map   mapOf   mutableMapOf, hashMapOf, linkedMapOf, sortedMapOf    다이어그램의 가장 상위의 Iterable 인터페이스는 컬렉션이 연속적인 요소를 표현 할 수 있게 한다. Collection 인터페이스: Collection 인터페이스의 특징  Iterable로부터 확장 불변형이므로 Collection으로부터 확장된 Set과 List는 읽기 전용의 컬렉션됨Collection 인터페이스의 멤버       멤버   설명         size   컬렉션의 크기를 나타낸다       isEmpty()   컬렉션이 비어 있는 경우 true를 반환한다       contains(element: E)   특정 요소가 있다면 true를 반환한다       containsAll(element: Collection)   인자로 받아들인 Collection이 있다면 true를 반환한다.    MutableIterable과 MutableCollection 인터페이스: 특징  가변형 컬렉션을 지원하기 위해 준비된 인터페이스 요소를 추가하거나 제거하는 등의 기능을 수행할 수 있따. MutableCollection의 멤버       멤버   설명         add(element: E)   인자로 전달반은 요소를 추가하고 true를 반환하며, 이미 요소가 있거나 중복이 허용되지 않으면 false를 반환한다.        remove(element: E)   인자로 받은 요소를 삭제하고 true를 반환하며, 삭제하려는 요소가 없다면 false를 반환한다.        addAll(elements: Collection)   컬렉션을 인자로 전달받아 모든 요소를 추가하고 true를 반환하며, 실패 시 false를 반환한다.        removeAll(elements: Collection)   컬렉션을 인자로 전달받아 모든 요소를 삭제하고 true를 반환하며, 실패 시 false를 반환한다.        retainAll(elements: Collection)   인자로 전달받은 컬렉션의 요소만 보유한다. 성공 시 true를 반환하고 실패 시 false를 반환한다.        clear()   컬렉션의 모든 요소를 삭제한다.    List: List  순서에 따라 정렬된 요소를 가지는 컬렉션 (가장 많이 사용되는 컬렉션 중에 하나) 값을 변경할 수 없는 불변형 List를 만들기 위해 헬퍼 함수인 listOf()를 사용 값을 변경할 수 있는 가변형을 표현하기 위해서는 mutablelistOf()를 사용 인자는 원하는 만큼의 가변 인자를 가지도록 vararg로 선언 가능헬퍼 함수  객체 생성 시 요소를 직접 선언하기 보다 특정 함수의 도움을 통해 생성listOf(): 1public fun &lt;T&gt; listOf(vararg elements: T): List&lt;T&gt; vararg는 가변 인자를 받을 수 있기 때문에 원하는 만큼 요소를 지정 값을 반환할 때는 List를 사용 형식 매개변수 는 필요에 따라 원하는 자료형을 지정해 선언     사용하지 않으면 가 기본값이며 어떤 자료형이든 혼합 사용 가능   123456789101112fun main() {  // 불변형 List의 사용  var numbers: List&lt;Int&gt; = listOf(1, 2, 3, 4, 5)  var names: List&lt;String&gt; = listOf( one ,  two ,  three )  for (name in names) {    println(name)  }  for (num in numbers) print(num) // 한 줄에서 처리하기  println() // 내용이 없을 때는 한 줄내리는 개행}형식 매개변수 생략 예시 1234var mixedTypes = listOf( Hello , 1, 2. 445, 's')/* 아래와 같은 표현이다var mixedTypes: List&lt;Any&gt; = listOf( Hello , 1, 2. 445, 's')*/컬렉션에 접근할 때:  for와 . indices 멤버를 통한 접근12345val fruits = listOf( apple ,  banana ,  kiwi )// for과 in을 사용한 출력for (item in fruits) {  println(item)}123applebananakiwi123for (index in fruits. indices) {  println( fruits[$index] = ${fruits[index]} )}123fruits[0] = applefruits[1] = bananafruits[2] = kiwi기타 List 생성 함수: emptyList()  빈 리스트를 생성1val emptyList: List&lt;String = emptyList&lt;String&gt;&gt;()listOfNotNull()  null을 제외한 요소만 반환123// null이 아닌 요소만 골라 컬렉션을 초기화val nonNullsList: List&lt;Int&gt; = listOfNotNull(2, 45, 2, null, 5, null)println(nonNullsList)1[2, 45, 2, 5]List 추가 멤버 메서드:       멤버 메서드   설명         get(index: Int)   특정 인덱스를 인자로 받아 해당 요소를 반환한다.        indexOf(element: E)   인자로 받은 요소가 첫 번째로 나타나는 인덱스를 반환하며, 없으면 -1을 반환한다.        lastIndexOf(element: E)   인자로 받은 요소가 마지막으로 나타나는 인덱스를 반환하고, 없으면 -1을 반환한다.        listIterator()   목록에 있는 iterator를 반환한다.        subList(fromIndex: Int, toIndex: Int   특정 인덱스의 from과 to 범위에 있는 요소 목록을 반환한다.    practice 12345678910111213141516171819// 자료형 확인 단축기 Ctrl + Shiftfun main() {  var numbers1 = listOf(1, 2, 3, 4, 5)  var numbers2: List&lt;Int&gt; = listOf(1, 2, 3, 4, 5)  var names1 = listOf( one ,  two ,  three )  var names2: List&lt;String&gt; = listOf( one ,  two ,  three )  var mixed1 = listOf( one , 1, 1. 5, 'c')  var mixed2: List&lt;Any&gt; = listOf( one , 1, 1. 5, 'c')  println( numbers $numbers1 ) // [1, 2, 3, 4, 5]  println( names $names1 ) // [one, two, three]  println( mixed $mixed1 ) // [one, 1, 1. 5, c]  println(numbers1. size) // 5  println(numbers1. indexOf(3)) // 2  println(numbers1. get(0)) // 1  println(numbers1[0]) // 1  println(numbers1. contains(1)) // }"
    }, {
    "id": 166,
    "url": "/study_Kotlin_28/",
    "title": "Kotlin 객체편 - [18]",
    "body": "2020/08/18 - 문자열 기본 처리: 문자열은 불변(immutable) 값으로 생성  참조되고 있는 메모리가 변경될 수 없다. 123456val hello: String =  Hello World! println(hello[0]) // H//hello[0] = 'K' // Error!var s =  abcdef s =  xyz  // 새로운 메모리 공간이 생성된다. 기존의 문자열은 GC에 의해 제거됨 문자열 추출하고 병합하기: 문자열에서 특정 범위의 문자열을 추출  substring(), subsequence()12String. substring( 인덱스 범위 지정 ): StringCharSequence. subSequence( 인덱스 범위 지정 ): CharSequence12s =  abcdef println(s. substring(0. . 2)) // abc추출 후 문자열 새로 할당하기 123var s =  abcdef s = s. substring(0. . 1) +  x  + s. substring(3. . s. length-1) // ab를 추출하고 x를 덧붙이고 다시 def를 추출 -&gt; abxdef문자열 비교: a. compareTo(b)를 사용한 비교  a와 b가 같다면 0을 반환하고, a가 b보다 작으면 양수, 그렇지 않으면 음수12345var s1 =  Hello Kotlin var s2 =  Hello KOTLIN // 같으면 0, s1&lt;s2 이면 양수, 반대면 음수를 반환println(s1. compareTo(s2)) // 양수println(s1. compareTo(s2, true)) // 대소문자 무시 결과는 0StringBuilder: 문자열이 사용할 공간을 좀 더 크게 잡아 사용한다.  간단한 요소 변경이 있을 경우 용이하다.  단, 기존의 문자열보다는 처리가 조금 느리며, 만일 단어를 변경하지 않는 경우 불필요한 메모리 낭비를 야기한다.  문자열이 자주 변경되는 경우에 사용한다. 12var s = StringBuilder( Hello )s[2] = 'x' // 허용되지 않았던 요소이 변경이 가능하다. 결과는 HexloStringBuilder 관련 메서드  append(포함), insert(추가), delete(삭제) 등1234var s = StringBuilder( Hello )s. append( World ) // HelloWorlds. insert(10,  Added ) // index 10부터 추가되어 HelloWorldAddeds. delete(5, 10) // index 5부터 10 전까지 삭제되어 HelloAdded기타 문자열 처리: 소문자/ 대문자 변경  toLowerCase(), toUpperCase()특정 문자 단위로 잘라내기  split(“분리문자”) - 분리된 내용은 List로 반환123var deli =  Welcome to Kotlin val sp = deli. split(   )println(sp) // [ Welcome ,  to ,  Kotlin ]앞뒤 공백 제거  trim()리터럴 문자열: 이스케이프(Escape) 문자       종류   의미         \t   탭(tab)       \b   백스페이스(backspace)       \n   개행(newline)       \r   리턴(carriage return)       \uHHHH   유니코드(Unicode) 문자       '   작은따옴표(single quote)           큰따옴표(double quote)       \   슬래시(slash)       $   달러 기호(dollar)   12val str =  \tYou're just Too \ good\  to be true\n\tI can't take my eyes off you.  val uni =  \uAC00  // 한글 코드의 범위 AC00-D7AF123  You're just too  good  to be true  I can't take my eyes off you. 가\r 같은 경우는 운영체제별로 다르게 동작을 할수도 있으니 유의해서 사용하자. 원본 문자열 그대로 나타내기: 3중 따옴표 부호(“”“)의 이용 123456val text =      |Tell me and I forget.   |Teach me and I remember.   |Involve me and I learn.   |(Benjamin Franklin)     . trimMargin() // trim default는 |형식 문자 사용: format()을 사용한 형식 문자 1inline fun String. format(vararg args: Any?): String (source)      종류   의미         %b   참과 거짓의 Boolean 유형       %d   부호있는 정수       %f   10진 실수       %h   해시코드       %o   8진 정수       %t   날짜나 시간       %c   문자       %e   E 표기법의 실수       %g   10진 혹은 E 표기법의 실수       %n   줄 구분       %s   문자열       %x   16진 정수   12345val pi = 3. 1415926val dec = 10val s =  hello println( pi = %. 2f, %3d, %s . format(pi, dec, s)) // 3. 14, 010, hello"
    }, {
    "id": 167,
    "url": "/study_Kotlin_27/",
    "title": "Kotlin 객체편 - [17]",
    "body": "2020/08/18 - 배열의 정렬: 정렬(Sort)  오름차순(ascending)으로 정렬하거나 내림차순(descending) 정렬 Array는 기본적인 정렬 알고리즘을 제공한다. 정렬된 배열을 반환  sortedArray() sortedArrayDescending()원본 배열에 대한 정렬을 진행  sort() sortDescending()1234567891011121314151617181920212223242526fun main() {  val arr = arrayOf(8, 4, 3, 2, 5, 9, 1)  val sortedArr = arr. sortedArray()  println(Array. toString(sortedArr)) // [1, 2, 3, 4, 5, 8, 9]  val sortedArrDesc = arr. sortedArrayDescending()  println(Arrays. toString(sortedArrDesc)) // [9, 8, 5, 4, 3, 2, 1]  arr. sort(1, 3)  println(Arrays. toString(arr)) // [8, . . 3, 4, . . 2, 5, 9, 1]  arr. sortDescending() // parameter 옵션이 없다.   println(Arrays. toString(arr)) // [9, 8, 5, 4, 3, 2, 1]  // 3. List로 반환  val listSorted: List&lt;Int&gt; = arr. sorted()  val listDesc: List&lt;Int&gt; = arr. sortedDescending()  println( LST:   + listSorted)  println( LST:   + listDesc)  // 4. SortBy를 이용한 특정 표현식에 따른 정렬  val items = arrayOf&lt;String&gt;( Dog ,  Cat ,  Lion ,  Kangaroo ,  Po )  items. sortBy { item -&gt; item. length }  println(Arrays. toString(items))}practice 123456789101112131415data class Product(val name: String, val price: DOuble)fun main() {  val products = arrayOf(    Product( Snow Ball , 870. 00),    Product( Smart Phone , 999. 00),    Product( Drone , 240. 00),    Product( Mouse , 333. 55),    Product( Keyboard , 125. 99),    Product( Monitor , 1500. 99),    Product( Tablet , 512. 99))  products. sortBy { it. price }  products. forEach { println(it) }}1234567891011121314151617181920212223242526272829303132333435data class Product(val name: String, val price: DOuble)fun main() {  val products = arrayOf(    Product( Snow Ball , 870. 00),    Product( Smart Phone , 999. 00),    Product( Drone , 240. 00),    Product( Mouse , 333. 55),    Product( Keyboard , 125. 99),    Product( Monitor , 1500. 99),    Product( Tablet , 512. 99))  products. sortWith(    Comparator&lt;Product&gt; { p1, p2 -&gt;      when {        p1. price &gt; p2. price -&gt; 1        p1. price == p2. price -&gt; 0        else -&gt; -1      }    }  )  product. forEach{ println(it) }  println()  // CompareBy를 함께 사용해 두개의 정보 정렬  // varargs(가변인수)로 받고 있으므로 두개 이상 사용 가능  products. sortWith( compareBy( {it. name}, {it. price}))  products. forEach { println(it) }  println()  // 지정된 필드의 가장 작은/큰 값 골라내기  println(products. minBy { it. price })  println(products. maxBy { it. price })}-With, -By:  with : comparator를 이용하여 정렬을 할수 있게 해준다. 123fun &lt;T&gt; Array&lt;out T&gt;. sortedWith(  comparator: Comparator&lt;in T&gt;): List&lt;T&gt; By : 람다식을 이용해 정렬을 도와준다. 123inline fun &lt;T, R : Comparable&lt;R&gt;&gt; Array&lt;out T&gt;. sortedBy(  crossinline selector: (T) -&gt; R?): List&lt;T&gt;여기서 crossinlin selector이기 때문에 매개변수가 없다면 생략 가능 123val list = listOf( aa ,  b ,  bb ,  a )val sorted = list. sortedWith(compareBy { it. length })println(sorted)1[b, a, aa, bb]2개 이상의 람다식도 가능하다. 이때 해당 람다식은 이전 람다식이 같게되면 다음으로 진행하는 것으로 판단된다. 123456val list = listOf( aa ,  b ,  bb ,  a )val sorted = list. sortedWith(compareBy(  { it. length },  { it }))println(sorted)1[a, b, aa, bb]배열 필터링하기: filter() 메서드를 활용하면 원하는 데이터를 골라낼 수 있다. 123456// 0 보다 큰 수 골라내기val arr = arrayOf(1, -2, 3, 4, -5, 0)arr. filter { e -&gt; e &gt; 0 }. forEach { e -&gt; print( $e  )}/* 같은 표현arr. filter { it &gt; 0 }. forEach { print(it +    )}*/체이닝을 통한 필터링 예 123456789fun main() {  val fruits = arrayOf( banana ,  avocado ,  apple ,  kiwi )  fruits  . filter { it. startsWith( a ) }  . sortedBy { it }  . map { it. toUpperCase() }  . forEach { println(it) }}when 문을 사용한 요소 확인 1234when {   apple  in fruits -&gt; println( Apple! )  . . . }큰 값 작은 값 골라내기 123// 지정된 필드의 가장 작은/큰 값 골라내기println(products. minBy { it. price })println(products. maxBy { it. price })배열 평탄화 하기  flatten() : 다차원 배열을 단일 배열 생성12345678910fun main() {  val numbers = arrayOf(1, 2, 3)  val strs = arrayOf( one ,  two ,  three )  val simpleArray = arrayOf(numbers, strs) // 2차원 배열  simpleArray. forEach{ println(it) }  val flattenSimpleArray = simpleArray. flatten() // 단일 배열로 변환하기  println(flattenSimpleArray)}"
    }, {
    "id": 168,
    "url": "/study_Kotlin_26/",
    "title": "Kotlin 객체편 - [16]",
    "body": "2020/08/18 - 배열의 생성: 표현식을 통한 생성 1val|var 변수명 = Array(요소 개수, 초기값) 초기값으로 람다식 함수 init: (Int) -&gt; T와 같이 정의 : 이때 (Int)는 index의 값을 가지고 있다.  예시) 2씩 곱해지는 정수의 짝수 5개(0, 2, 4, 6, 8)의 요소12val arr3 = Array(5, {i -&gt; i * 2})println( arr3: ${Arrays. toString(arr3)} )많은 양의 배열 생성 1var a = arrayOfNulls &lt;Int&gt; (1000) // 1000개의 null로 채워진 정수 배열1var a = Array(1000, { 0 }) // 0으로 채워진 배열특정 클래스 객체로 배열 생성 1var a = Array(1000, { i -&gt; myClass(i) })다차원 배열 생성 12var arr = Array(5) { Array(5) { 0 }}println(Arrays. deepToString(arr))배열에 요소 추가하고 잘라내기배열이 일단 정의되면 고정됨  새로 할당하는 방법으로 추가하거나 잘라낼 수 있음1234val arr1 = int ArrayOf(1, 2, 3, 4, 5) // 다섯개로 고정된 배열(고정된다!)// 하나의 요소를 추가한 새 배열 생성val arr2 = arr1. plus(6)println( arr2: ${Arrays. toString(arr2)} )123// 필요한 범위를 잘라내 새 배열 생성val arr3 = arr1. sliceArray(0. . 2) // 인자에 잘라낼 인덱스의 범위를 지정println( arr3: ${Arrays. toString(arr3)} )기타 배열 관련 API API 사용 예 123456789101112// 첫 번째와 마지막 요소 확인println(arr. first())println(arr. last())// 요소 3의 인덱스 출력println( indexOf(3): ${arr. indexOf(3)} )// 배열의 평균 값 출력println( average: ${arr. average()} )// count에 의한 요소 개수println( count: ${arr. count()} )존재 여부 확인 1operator fun &lt;T&gt; Array&lt;out T&gt;. contains(element: T): Boolean12println(arr. contains(4)) // arr 배열에 요소 4가 포함되었는지 확인하고 true 반환println(4 in arr)123456789101112131415fun main() {  val b = Array(10, { 0 })  // b[0] =  Hello World  // Error! 이미 정수형으로 초기화 되었으므로   // b[1] = 1. 1 // Error! Float도 안된다.   println(Arrays. toString(b)) // [ 0, . . . , 0]  val c = Array&lt;Any&gt;(10, { 0 })  c[0] =  Hello World   c[1] = 1. 1  val d = Array&lt;Number&gt;(10, { 0 })  //d[0] =  Hello World  // Error! Number형의 자료형으로 제한  d[1] = 1. 1}배열의 순환: 순환 메서드의 사용: 123456// forEach에 의한 요소 순환arr. forEach { element -&gt; print( $element  ) }arr. forEach { print(it) }// forEachIndexed에 의한 요소 순환arr. forEachIndexed({i, e -&gt; println( arr[$i] = $e )})forEachindexed  인덱스는 i로, 요소는 e로 받아 화살표 표현식 오른쪽의 구문처리Iterator의 이용: 123456// Iterator를 사용한 요소 순환val iter: Iterator&lt;Int&gt; = arr. iterator()while(iter. hasNext()) {  val e = iter. next()  print( $e  )}순환 방법에 따른 속도차이  정수형을 사용할 경우는 for 문이 빠르다.  List 와 같은 Collection을 사용할 경우 순환 메서드가 빠르다. "
    }, {
    "id": 169,
    "url": "/study_Kotlin_25/",
    "title": "Kotlin 객체편 - [15]",
    "body": "2020/08/18 - 배열 표현하기  arrayOf()나[-헬퍼 함수] Array() 생성자를 사용해 배열을 생성한다 arrayOfNulls() : 빈배열1234567val numbers = arrayOf(4, 5, 7, 3) // 정수형으로 초기화된 배열val animals = arrayOf( Cat ,  Dog ,  Lion ) // 문자열형으로 초기화된 배열. . . for(element in numbers) { // 정수형으로 초기화된 배열 출력하기  println(element)}다차원 배열 12345val array1 = arrayOf(1, 2, 3)val array2 = arrayOf(4, 5, 6)val array3 = arrayOf(7, 8, 9)val arr2d = arrayOf(array1, array2, array3)1val arr2d = arrayOf(arrayOf(1, 2, 3), arrayOf(4, 5, 6), arrayOf(7, 8, 9))123456for (e1 in arr2d) {  for (e2 in e1) {    print(e2)  }  println()}다양한 자료형 1val mixArr = arrayOf(4, 5, 6, 1,  Chike , false) // 정수, 문자열, Boolean 혼합다양한 자료형 혼합 가능 특정 자료형으로 제한하고자 할 경우  arrayOf() 자료형 이름 + ArrayOf()     charArrayOf(), booleanArrayOf(), longArrayOf(), shortArrayOf(), byteArrayOf(), intArrayOf()   ubyteArrayOf(), ushortArrayOf(), uintArrayOf(), ulongArray()   배열 요소에 접근 선언부 12345678// 코틀린 표준 라이브러리의 Array. ktpublic class Array&lt;T&gt; {  public inline constructor(size: Int, init: (int) -&gt; T)  public operator fun get(index: Int): T  public operator fun set(index: Int, value: T): Unit  public val size: Int  public operator fun iterator(): Iterator&lt;T&gt;}연산자를 통한 접근 12arr. get(index) -&gt; value = arr[index]arr. set(index) -&gt; arr[index] = value예시  읽기 접근123val arr = intArrayOf(1, 2, 3, 4, 5)println(arr. get(2)) // 게터를 통한 접근println(arr[2]) // 연산자 오버로딩으로 대괄호를 통한 접근12val arr2d = arrayOf(arrayOf(1, 2, 3), arrayOf(4, 5, 6), arrayOf(7, 8, 9))println(arr2d[2][1]) // 8을 출력 쓰기 접근1234arr. set(2, 7) // 인덱스 2번 요소를 값 7로 교체arr[0] = 8 // 인덱스 0번 요소를 값 8로 교체arr2d[2][1] = 2 // 다차원 배열의 요소를 교체println( size: ${arr. size} arr[0]: ${arr[0]}, arr[2]: ${arr[2]} )practice 123456789101112131415161718192021import java. util. Arrays // Arrays를 사용하기 위해fun main() {  val arr = arrayOf(1, 2, 3, 4, 5)  println(arr. get(2)) // 3  println(arr[2]) // 3  println(arr. size) // 5  for (ele in arr) {    print(ele) // 12345  }  println()  println(Arrays. toString(arr)) // [1, 2, 3, 4, 5]  println(arr. sum()) // 15  arr. set(1, 8)  println(Arrays. toString(arr)) // [1, 8, 3, 4, 5]  arr[1] = 7  println(Arrays. toString(arr)) // [1, 7, 3, 4, 5]}1234567891011121314151617181920212223import java. util. Arrays fun main(args: Array&lt;String&gt;) {  val arr = intArrayOf(1, 2, 3, 4, 5)  println( arr: ${Arrays. toString(arr)} ) // Arrays. toString()은 배열의 내용을 문자열로 변환함  println( size: ${arr. size} ) // size는 배열의 크기를 나타냄  println( sum: ${arr. sum()} ) // sum() 메서드는 배열의 합을 계산해 줌  // 게터에 의한 접근과 대괄호 연산자 표깁ㅂ  println(arr. get(2))  println(arr[2])  // 세터에 의한 값의 설정  arr. set(2, 7)  arr[0] = 8  println( size: ${arr. size} arr[0]: ${arr[0]}, arr[2]: ${arr[2]} )  // 루프를 통한 배열 요소의 접근  for (in in 0. . arr. size - 1) {    println( arr[$i] = ${arr[i]} )  }}배열 출력을 도와주는 함수toString 12val arr = intArrayOf(1, 2, 3, 4, 5)println(Arrays. toString(arr)) // [1, 2, 3, 4, 5]deepToString() [다차원 배열에서 사용!] 12345val array = arrayOf(intArrayOf(1, 2),      intArrayOf(3, 4)      intArrayOf(5, 6, 7))println(Arrays. deepToString(array)) // [[1, 2], [3, 4], [5, 6, 7]]"
    }, {
    "id": 170,
    "url": "/study_Kotlin_24/",
    "title": "Kotlin 객체편 - [14]",
    "body": "2020/08/18 - 자료형 프로젝션: 선언 지점 변성(declaration-site variance)  클래스 자체에 가변성을 지정하는 방식으로 클래스에 in/out을 지정할 수 있다.  선언하면서 지정하면 클래스의 공변성을 전체적으로 지정하는 것     클래스를 사용하는 장소에서는 따로 자료형을 지정해 줄 필요가 없음   1class &lt;Box in T: Animal&gt;(var item: T)사용지점 변성(use-site variance)  매서드 매개변수에서 똗는 제네릭 클래스를 생성할 때와 같이 사용 위치에서 가변성을 지정하는 방식사용지점 변성의 예 1class Box&lt;T&gt;(var item: T)Box의 사용시점에서 box의 item을 얻느냐(get) 설정하느냐(set)에 따라 out/in 결정 12345fun &lt;T&gt; printObj(box: Box&lt;out Animal&gt;) {  val obj: Animal = box. item // item의 값을 얻음(get)  // box. item = Animal() // Error! 설정(set)하려고 할때는 in이 지정되어야 한다.   println(obj)}이러한 방법을 자료형 프로젝션이라고 하며, 지료형 프로젝션을 통해 자료의 안정성을 보장한다. 스타 프로젝션: in/out을 정하지 않고 추후에 결정  어떤 자료형이라도 들어올 수 있으나 구체적으로 자료형이 결정되고 난 후에는 그 자료형과 하위 자료형의 요소만 담을 수 있도록 제한Foo&lt;out T: TUpper&gt;  Foo&lt;*&gt;는 Foo와 동일Foo  Foo&lt;*&gt;는 Foo와 동일1234567891011121314class InOutTesT&lt;in T, out U&gt;(t: T, u: U) {  // val propT: T = t // Error! T는 in 위치기 떄문에 out위치에 사용 불가  val propU: U = u // U는 out위치로 사용 가능  //fun func1(u: U) // Error! U는 out 위치기 때문에 in위치에 사용 불가  fun func2(t: T) { // T는 in 위치에 사용 가능    print(t)  }}fun starTestFunc(v: InOutTest&lt;*, *&gt;) {  // v. func2(1) // Error: Nothing으로 인자를 처리함  print(v. propU)}      종류   예   가변성   제한         out 프로젝션   Box   공변성   형식 매개변수는 세터를 통해 값을 설정하는 것이 제한됨       in 프로젝션   Box   반공변성   형식 매개변수는 게터를 통해 값을 읽거나 반환 가능       스타 프로젝션   Box&lt;*&gt;   모든 인스턴스는 하위타입이 될 수 있음   in과 out은 사용 방법에 따라 결정됨   reified 자료형: reified 자료형이 필요한 이유 1fun&lt; T&gt; myGenericFun(c: Class&lt;T&gt;) T 자료형은 실행 시간에 삭제 컴파일 시간에는 접근 가능하나 함수 내부에서 사용하려면 위의 코드에서 함수의 매개변수를 넣어 c: Class 처럼 지정해야만 실행 시간에 사라지지 않고 접근 가능하다. 1inline fun &lt;reified T&gt; myGenericFun() reified로 형식 매개변수 T를 지정하면 실행 시간에 접근 가능 reified 자료형은 inline 함수에서만 사용할 수 있다.      컴파일러가 복사해 넣을 때 실제 자료형을 알 수 있기 때문에 실행 시간에도 사용할 수 있게 됨   Class  . class 형태로 반환받는 객체 Class라는 클래스는 원본 클래스에 대한 많은 메타 데이터를 가진다     패키지 이름이나 메서드, 필드, 구현된 인터펭스, 각종 검사 변수 등   Object::class  코틀린의 표현 방법으로 KClass를 나타낸다자바의 클래스를 가져오려면 . java를 사용해야 한다 12Object::class // KClassObject::class. java // Classreified를 이용한 결정됮 않은 제네릭 자료형의 처리 12345678910111213141516171819202122fun main() {  val result = getType&lt;Float&gt;(10)  println( result = $result )}inline fun &lt;reified T&gt; getType(value: Int): T {  println(T::class) // 실행 시간에 삭제되지 않고 사용 가능  println(T::class. java)  return when (T::class) { // 받아들인 제네릭 자료형에 따라 반환    Float::class =&gt; value. toFloat() as T    Int::class -&gt; value as T     /*    as는 보통 임의로 캐스팅 하기 위해 사용.     여기서는 T형식으로 캐스팅 하는데는    '안전하지 않은' 캐스팅이로도 불리고    '안전한' 캐스팅을 하려면 as? 와 같이 사용한다    as?는 캐스팅 불가 시 null을 반환한다.     */    else -&gt; throw IllegalStateException( ${T::class} is not supported! )  }}"
    }, {
    "id": 171,
    "url": "/study_Kotlin_23/",
    "title": "Kotlin 객체편 - [13]",
    "body": "2020/08/12 - 제네릭 함수 혹은 메서드:  해당 함수나 메서드 앞쪽에 와 같이 지정 자료형의 결정은 함수가 호출될 때 컴파일러가 자료형 추론 이 자료형은 반환 자료형과 매개변수 자료형에 사용할 수 있다. 1fun &lt;형식 매개변수[, . . . ]&gt; 함수명(매개변수: &lt;매개변수 자료형&gt;[, . . . ]): &lt;반환 자료형&gt;123fun &lt;T&gt; genericFunc(arg: T): T? { . . . } // 매개변수와 반환 자료형에 형식 매개변수 T가 사용된다. fun &lt;K, V&gt; put(key: K, value: V): Unit { . . . } // 형식 매개변수가 여러 개인 경우예시 123456789101112131415fun &lt;T&gt; find(a: Array&lt;T&gt;, Target: T): Int {  for (i in a. indices) {    if (a[i] == Target) return i  }  return -1}fun main() {  val arr1: Array&lt;String&gt; = arrayOf( Apple ,  Banana ,  Cherry ,  Durian )  val arr2: Array&lt;Int&gt; = arrayOf(1, 2, 3, 4)  println( arr. indices ${arr1. indices} ) // indices는 배열의 유효 범위 반환 return =&gt; arr. indices 0. . 3  println(find&lt;String&gt;(arr1,  Cherry )) // 요소 C의 인덱스 찾아내기 return =&gt; 2  println(find(arr2, 2)) // 요소의 인덱스 찾아내기 return =&gt; 1}형식 매개변수로 선언된 함수의 매개변수를 연산하고자 하면 람다식을 사용해야한다. 123fun &lt;T&gt; add(a: T, b: T): T {  // return a + b // 오류! 자료형을 아직 결정할 수 없다. }12345678fun &lt;T&gt; add(a: T, b: T, op: (T, T)-&gt; T): T {  return op(a, b)}fun main() {  val result = add(2, 3, {a, b -&gt; a + b})  val result2 = add(2, 3) {a, b -&gt; a + b} 와 같이 표현 가능  println(result)}형식 매개변수를 특정한 자료형으로 제한  자료형의 사용범위를 좁히기 위해 자료형을 제한한다.  자바에서는 extends나 super를 사용해 자료형을 제한한다.  코틀린은 콜론(:)과 자료형을 기입ㅎ면 형식 매개변수 T의 자료형이 기입한 자료형으로 제한된다. 자료형을 숫자형으로 제한하는 예시 123456789101112131415161718class Calc&lt;T: Number&gt; {  fun plus(arg1: T, arg2: T): Double {    return arg1. toDouble() + arg2. toDouble()  }}fun main(args: Array&lt;String&gt;) {  val calc = Calc&lt;Int&gt;()   println(calc. plus(10, 20))  val calc2 = Calc&lt;Double&gt;()   val calc3 = Calc&lt;Long&gt;()   // val calc4 = Calc&lt;String&gt;() // 에러! 제한된 자료형  println(calc2. plus(2. 5, 3. 5))  println(calc3. plus(5L, 10L))}123456fun &lt;T: Number&gt; addLimit(a: T, b: T, op: (T, T) -&gt; T): T {  return op(a, b)}. . . val result = addLimit( abc ,  def , {a, b -&gt; a + b}) // 제한된 자료형으로 인해 오류 발생! 상ㆍ하위 형식의 가변성: 가변성(variance)이란  형식 매개변수가 클래스 계층에 어떤 영향을 미치는지 정의     형식 A의 값이 필요한 모든 장소에 형식 B의 값을 넣어도 아무 문제가 없다면 B는 A의 하위 형식(subtype)   Int는 Number의 하위 클래스   클래스와 자료형       형태   클래스인가?   자료형인가?         String   네   네       String?   아니오   네       List   네   네       List   아니오   네   하위 크래스는 상위 클래스가 수용한다.  하위 자료형은 상위 자료형으로 자연스럽게 형 변환이 이루어진다. number &lt;- Int 123val integer: Int = 1val number: Number = integer // 하위 자료형 Int를 Number가 수용함 (캐스팅 되어 할당 된다. )Int? &lt;- Int 12val integer: Int = 1;val nullableInteger: Int? - integer; 가변성의 3가지 유형:       용어   의미         공변성(covariance)   T’가 T의 하위 자료형이면, C&lt;T’&gt;는 C의 하위 자료형이다. 생산자 입장의 out 성질       반공변성(contravariance)   T’가 T의 하위 자료형이면, C는 C&lt;T'&gt;의 하위 자료형이다. 소비자 입장의 in 성질       무변성(invariance)   C&lt;T’&gt;는 C는 아무 관계가 없다. 생산자 + 소비자    무변성(invariance):  자료형 사이의 하위 자료형 관계가 성립하지 않음 코틀린에서는 따로 지정해 주지 않으면 기본적으로 무변성Any &lt;- Int &lt;- Nothing 1234567// 무변성(Invariance) 선언class Box&lt;T&gt;&lt;val size: Int&gt;fun main(args: Array&lt;String&gt;) {  // val anys: Box&lt;Any&gt; = Box&lt;Int&gt;(10) // 자료형 불일치 오류  // val nothings: Box&lt;Nothing&gt; = Box&lt;Int&gt;(20) // 자료형 불일치 오류}공변성(covariance):  형식 매개변수 사이의 하위 자료형 관계가 성립 하위 자료형 관계가 그래도 인스턴스 자료형 사이의 관계로 이어지는 경우 out 키워드를 사용해 정의Any &lt;- Int &lt;- Nothing 12345678// 공변성(Covariance) 선언class Box&lt;out T&gt;(val size: Int)fun main(args: Array&lt;String&gt;) {  val anys: Box&lt;Any&gt; = Box&lt;Int&gt;(10) // 관계 성립으로 객체 생성 가능  // val nothings: Box&lt;Nothing&gt; = Box&lt;Int&gt;(20) // 오류! 자료형 불일치  println(anys. size)}반공변성(contravariance):  자료형의 상하 관계가 반대 하위 클래스의 자료형을 상위 클래스의 자료형이 허용Any &lt;- Int &lt;- Nothing 12345678// 반공변성(Contravariance) 선언class Box&lt;in T&gt;(val size: Int)fun main(args: Array&lt;String&gt;) {  // val anys: Box&lt;Any&gt; = Box&lt;Int&gt;(10) // 오류! 자료형 불일치  val nothings: Box&lt;Nothing&gt; = Box&lt;Int&gt;(20) // 관계 성립으로 객체 생성 가능  println(nothings. size)}에시 Cat -&gt; Animal &lt;- Spider 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576open class Animal(val size: Int) {  fun feed() = println( Feeding. . .  )}class Cat(val jump: Int): Animal(50)class Spider(val poison: Boolean): Animal(1)class Box1&lt;T&gt; // 무변성!class Box2&lt;out T&gt; // 공변성!class Box3&lt;in T&gt; // 반공변성!class Box4&lt;out T: Animal&gt; // 공변성에 자료형 제한// 형식 매개변수를 Animal로 제한class Box5&lt;out T: Animal&gt;(val element: T) { // 주 생성자에서 val만 허용  fun getAnimal(): T = element // out은 반환 자료형에만 사용할 수 있음      /* 오류! T는 in 위치에 사용할 수 없음   즉 out이기 때문에 반환 형식으로만 사용할 수 있다.   fun setAnimal(new: T) {    element = new  }  */}fun main() {  val c1 = Cat(10)  val c2: Animal = Cat(10)  val s1 = Spider(true)  val s2: Animal = Spider(true)  val a1 = Animal(20)  val a2 = c1  val a3: Animal = c1  var a3: Animal = c1  a3 = s1  println( a1 ${a1. size} ${a1. poison} ) // a1 1 true  val b1_1 = Box1&lt;Animal&gt;()  val b1_2: Box1&lt;Animal&gt; = Box1&lt;Animal&gt;  // val b1_3: Box1&lt;Cat&gt; = Box1&lt;Animal&gt; // 에러!  val b1_4 = Box1&lt;Cat&gt;()  val b1_5: Box1&lt;Cat&gt; = Box1&lt;Cat&gt;()  // val b1_6: Box1&lt;Animal&gt; = Box1&lt;Cat&gt;() // 에러!  val b1_7 = Box1&lt;Spider&gt;()  val b2_1 = Box2&lt;Animal&gt;()  val b2_2: Box2&lt;Animal&gt; = Box2&lt;Animal&gt;  // val b2_3: Box2&lt;Cat&gt; = Box2&lt;Animal&gt; // 에러!  val b2_4 = Box2&lt;Cat&gt;()  val b2_5: Box2&lt;Cat&gt; = Box2&lt;Cat&gt;()  val b2_6: Box2&lt;Animal&gt; = Box2&lt;Cat&gt;() // 공변성으로 가능!  val b2_7 = Box2&lt;Spider&gt;()  val b2_8 = Box2&lt;Int&gt;() // 자료형이 제한되어 있지 않으므로 어떤 형이든 가능!  val b2_9: Box2&lt;Number&gt; = Box2&lt;Int&gt;() // 상위 자료형이므로 가능!  val b3_1 = Box3&lt;Animal&gt;()  val b3_2: Box3&lt;Animal&gt; = Box3&lt;Animal&gt;  val b3_3: Box3&lt;Cat&gt; = Box3&lt;Animal&gt; // 반공변성으로 가능  val b3_4 = Box3&lt;Cat&gt;()  val b3_5: Box3&lt;Cat&gt; = Box3&lt;Cat&gt;()  // val b3_6: Box3&lt;Animal&gt; = Box3&lt;Cat&gt;() // 에러!  val b3_7 = Box3&lt;Spider&gt;()  val b4_1 = Box4&lt;Animal&gt;()  val 4_2: Box4&lt;Animal&gt; = Box4&lt;Animal&gt;  // val b4_3: Box4&lt;Cat&gt; = Box4&lt;Animal&gt; // 에러!  val b4_4 = Box4&lt;Cat&gt;()  val b4_5: Box4&lt;Cat&gt; = Box4&lt;Cat&gt;()  val b4_6: Box4&lt;Animal&gt; = Box4&lt;Cat&gt;() // 공변성으로 가능!  val b4_7 = Box4&lt;Spider&gt;()  // val b4_8 = Box4&lt;Int&gt;() // 자료형이 제한되어서 불가능!  // val b4_9: Box4&lt;Number&gt; = Box4&lt;Int&gt;() // 자료형 제한으로 불가능!}"
    }, {
    "id": 172,
    "url": "/study_Kotlin_22/",
    "title": "Kotlin 객체편 - [12]",
    "body": "2020/08/12 - 제네릭(generic): 자료형의 객체들을 다루는 메서드나 클래스에서 컴파일 시간에 자료형을 검사해 적당한 자료형을 선택할 수 있도록 하기 위해 만들어진 개념 제네릭의 일반적인 사용  앵글 브래킷(&lt;&gt;) 사이에 형식 매개변수를 사용해 선언한다 형식 매개변수는 자료형을 대표하는 용어로 T와 같이(Type의 약자) 특정 영문의 대문자로 사용한다123456789class Box&lt;T&gt;(a: T) {  var name = a}fun main() {  val box1 = Box(1)  val box1: Box&lt;Int&gt; = Box(1) // 추론이 가능하기 때문에 생략 가능하다  val box2 = Box( kildong )}12345678910class Box&lt;T&gt;(t: T) { // 제네릭을 사용해 형식 매개변수를 받아 name에 저장  var name = t}fun main() {  val box1: Box&lt;Int&gt; = Box&lt;Int&gt;(1)  val box2: Box&lt;String&gt; = Box&lt;String&gt;( Hello )  println(box1. name) // 1  println(box2. name) // Hello}형식 매개변수의 이름: 강제사항은 없으나 일종의 규칙처럼 사용된다       형식 매개변수 이름   의미         E   요쇼(element)       K   키(key)       N   숫자(number)       T   형식(type)       V   값(value)       S, U, V etc.    두 번째, 세 번째, 네 번째 형식(2nd, 3rd, 4th types)   자료형이 추론 가능한 경우는 앵글 브라켓 표현을 생략해도 된다. 12val box3 = Box(1) // 1은 Int형이므로 Box&lt;Int&gt;로 유추한다. val box4 = Box( Hello ) //  Hello 은 String형이므로 Box&lt;String&gt;로 유추한다. 형식 매개변수를 한개 이상 받는 클래스  인스턴스를 생성하는 시점에서 클래스의 자료형을 정하게 된다.  제네릭 클래스 내에 메서드에도 다음과 같이 형식 매개변수를 사용12345class MyClass&lt;T&gt; { // 한 개의 형식 매개변수를 가지는 클래스  fun myMethod(a: T) { // 메서드의 매개변수 자료형에 사용됨    . . .   }} 프로퍼티에 지정하는 경우     주 생성자나 부 생성자에 형식 매개변수를 지정해 사용   주 생성자의 형식 매개변수 1class MyClass&lt;T&gt;(val myProp: T) { } // 주 생성자의 프로퍼티부 생성자의 형식 매개변수 123456class MyClass&lt;T&gt; {  val myProp: T // 프로퍼티  constructor(myProp: T) { // 부 생성자 이용    this. myProp = myProp  }}정수형이 사용된 객체 초기화 예시 123var = MyClass&lt;Int&gt;(12) // 주 생성자 myProp에는 12가 할당되며 정수형으로 결정됨println(a. myProp) // 12println(a. javaClass) // MyClass12345678910111213141516171819open class Parentclass Child : Parent()class Cup&lt;T&gt;fun main() {  val obj1: Parent = Parent()  // val obj2: Child = Parent() // 에러!  val obj3: Child = Child()  val obj4: Parent = Child() // 된다!  val obj5 = Cup&lt;Parent&gt;()  // val obj5: Cup&lt;Parent&gt; = Cup&lt;Parent&gt;() 동일하다.   // val obj6: Cup&lt;Child&gt; = Cup&lt;Parent&gt;() // 에러!  val obj7 = Cup&lt;Child&gt;()  // val obj8: Cup&lt;Parent&gt; = Cup&lt;Child&gt;() // 에러! -  val obj8: Cup&lt;Child&gt; = obj7 // 형식이 일치하므로 가능!}여기서 in 과 out을 이용하면 가변성을 줄수 있다. (나중에 정리) 형식 매개변수의 null 제어: 제네릭의 형식 매개변수는 기본적으로 null 가능한 형태로 선언된다. 12345678910111213class GenericNull&lt;T&gt; { // 기본적으로 null이 허용되는 형식 매개변수  fun EqualityFunc(arg1: T, arg2: T) {    println(arg1?. equals(arg2))  }}fun main(args: Array&lt;String&gt;) {  val obj = GenericNull&lt;String&gt;() // non-null로 선언됨  obj. EqualityFUnc( Hello ,  World ) // null이 허용되지 않음  val obj2 = GenericNull&lt;Int?&gt;() // null이 가능한 형식으로 선언됨  obj2. EqualityFunc(null, 10) // null 사용}null을 허용하지 않으려면 특정 자료형으로 제한하면 된다. -&gt; &lt;T: Any&gt; "
    }, {
    "id": 173,
    "url": "/study_Kotlin_21/",
    "title": "Kotlin 객체편 - [11]",
    "body": "2020/08/12 - 연산자 오버로딩(operator overloading):  연산자에 여러 가지 다른 의미의 작동을 부여 코틀린에서는 특정 연산자의 역할을 함수로 정의 operator 키워드를 사용해 정의수식 연산자: a + b 연산자 관련 메서드 123val a = 5val b = 10print(a. plus(b)) // print( a + b ) 와 동일오버로딩된 plus() 함수의 종류 12345678910111213// 표준 라이브러리의 Primitives. kt 파일의 일부. . . /// + operator for basic typesoperator fun plus(other: Byte): Intoperator fun plus(other: Short): Intoperator fun plus(other: Int): Intoperator fun plus(other: Long): Longoperator fun plus(other: Float): Floatoperator fun plus(other: Double): Double// for string concatenationoperator fun String?. plus(other: Any?): String. . . 오버로딩 예시 123456789101112131415class Point(val x: Int = 0, var y: Int = 10) {  // plus 함수의 연산자 오버로딩  operator fun plus(p: Point) : Point {    return Point(x + p. x, y + p. y)  }}fun main() {  val p1 = Point(3, -8)  val p2 = Point(2, 9)  var point = Point()  point = p1 + p2 // Point 객체의 +(operator plus!) 연산이 가능하게 됨  println( point = (${point. x}, ${point. y}) )}1234567891011// --연산의 오버로딩 추가class Point(var x: Int = 0, var y: Int = 10) {  . . .   operator fun dec() = Point(--x, --y)}fun main() {  . . .   --point // --연산자  println( point = (${point. x}, ${point. y}) )}수식 연산자의 종류       표현식   함수 의미         a + b   a. plus(b)       a - b   a. minus(b)       a * b   a. times(b)       a / b   a. div(b)       a % b   a. rem(b) (Kotlin 1. 1부터, a. mod(b) (지원 중단)       a . . b   a. rangeTo(b)   호출 연산자(invoke operator): 함수 호출을 돕는데 사용한다. 1234567891011class Manager {  operator fun invoke(value: String) {    println(value)  }}fun main() {  val manager = Manager()  manager( Do something for me! ) // manager. invoke( . . .  ) 형태로 호출되며 invoke가 생략 되었다.                   // (invoke를 사용할때 해당 객체만 사용하면 생략 가능하다)}123val sum = { x: Int, y: Int -&gt; x + y}sum. invoke(3, 10) // 13sum(3, 10) // 위와 동일한 결과인덱스 연산자(indexed access operator): 게터/세터를 다루기 위한 대괄호([]) 연산자를 제공       표현식   함수 의미         a[i]   a. get(i)       a[i, j]   a. get(i,j)       a[i_1, …, i_n]   a. get(i+1, …, i_n)       a[i] = b   a. set(i, b)       a[i, j] = b   a. set(i, j, b)       a[i_1, …, i_n] = b   a. set(i_1, …, i_n, b)   단일 연산자: 먼저 a의 자료형을 결정하고 매개변수 없이 각 연산자에 대한 함수를 호출한 다음 연산된 결과를 반환       표현식   함수 의미         +a   a. unaryPlus()       -a   a. unaryMinus()       !a   a. not()   123456data class Point(val x: Int, val y: Int)operator fun Point. unaryMinus() = Point(-x, -y)val point = Point(10, 20)println(-point) // 단일 연산자에 의해 (-10, -20) 값을 바꿈포함 범위 연산자: in 연산자는 반복문에 사용해 특정 객체의 반복에 사용 혹은 포함여부 판단 1234if (i in 1. . 10) { // 1 &lt;= &amp;&amp; i &lt;= 10 와 동일  println(i)}for (i in 1. . 4) print(i) //  1234  출력      표현식   함수 의미         a in b   b. contains(a)       a !in b   !b. contains(a)   할당 연산자(augmented assignment): 예를 들어 a += b는 a + b의 연산 결과를 다시 a에 할당       표현식   함수 의미         a += b   a. plusAssign(b)       a -= b   a. minusAssign(b)       a *= b   a. timesAssign(b)       a /= b   a. divAssign(b)       a %= b   a. remAssign(b), a. modAssign(b)(지원중단)   동등성 연산자(equality and inequality):       표현식   함수 의미         a == b   a?. eqauls(b) ?: (b === null)       a != b   !(a?. eqauls(b) ?: (b === null))   비교 연산자(comparison):       표현식   함수 의미         a &gt; b   a. compareTo(b) &gt; 0       a &lt; b   a. compareTo(b) &lt; 0       a &gt;= b   a. compareTo(b) &gt;= 0       a &lt;= b   a. compareTo(b) &lt;= 0   "
    }, {
    "id": 174,
    "url": "/study_Kotlin_20/",
    "title": "Kotlin 객체편 - [10]",
    "body": "2020/08/12 - 지역 클래스: 특정 메서드의 블록이다 init 블록과 같이 블록 범위에서만 유효한 클래스이며 블록 범위를 벗어나면 더 이상 사용되지 않는다. 123456789101112131415161718192021222324. . . class Smartphone(val model: String) {  private val cpu =  Exynos   . . .   inner class ExternalStorage(val size: Int) {    fun getInfo() =  ${model}: Installed on $cpu with ${size}Gb  // 바깥 클래스의 프로퍼티 접근  }  fun powerOn(): String {    class Led(val color: String) { // 지역 클래스 선언      fun blink(): String =  Blinking $color on $model  // 외부의 프로퍼티는 접근 가능    }    val powerStatus = Led( Red ) // 여기에서 지역 클래스가 사용됨    return powerStatus. blink()  } // powerOn() 블록 끝}fun main() {  . . .   val myphone = Smartphone( Note9 )  myphone. ExternalStorage(128)  println(myphone. powerOn())}익명 객체: 자바에서는 익명 이너 클래스라는 것을 제공해 일회성으로 객체를 생성해 사용한다. 코틀린에서는 object 키워드를 사용하는 익명 객체로 같은 기능을 수행한다. 12345678910111213141516171819202122232425interface Switcher { // 인터페이스의 선언  fun on(): String}class Smartphone(val model: String) {  private val cpu =  Exynos   . . .   inner class ExternalStorage(val size: Int) {    fun getInfo() =  ${model}: Installed on $cpu with ${size}Gb    }  fun powerOn(): String {    class Led(val color: String) {       fun blink(): String =  Blinking $color on $model      }    val powerStatus = Led( Red )     val powerSwitch = object : Switcher { // 익명 객체를 사용해 Switcher의 on()을 구현      override fun on(): String {        return powerStatus. blink()      }    } // 익명(object) 객체 블록의 끝    return powerSwitch. on() // 익명 객체의 메서드 사용  } }실드(Sealed) 클래스:  실드란 ‘봉인된’이라는 의미로 무언가 안전하게 보관하기 위해 묶어 두는 것 sealed 키워드를 class와 함께 사용 실드 클래스 그 자체로는 추상 클래스와 같기 때문에 객체를 만들 수는 없다.  생성자도 기본적으로는 private이며 private이 아닌 생성자는 허용하지 않음 실드 클래스는 같은 파일 안에서는 상속이 가능(다른 파일에서 상속 불가) 블록 안에 선언되는 클래스는 상속이 필요한 경우 open 키워드로 선언실드 클래스는 상태를 정의하고 관리하는데 주로 쓰인다. 12345678// 실드 클래스 선언 첫번째 스타일sealed class Result {  open class Success(val message: String): Result()  class Error(val code: Int, val message: String): Result()}class Status: Result() // 실드 클래스 상속은 같은 파일에서만 가능class Inside: Result. Success( Status ) // 내부 클래스 상속12345678// 실드 클래스 선언 두번째 스타일sealed class Resultopen class Success(val message: String): Result()class Error(val code: Int, val message: String): Result()class Status: Result()class Inside: Success( Status )1234567891011121314fun main() {  /// Success에 대한 객체 생성  val result = Result. Success( Good! )  val msg = eval(result)  println(msg)}// 상태를 검사하기 위한 함수fun eval(result: Result): String = when(result) {  is Status -&gt;  in progress   is Result. Success -&gt; result. message  is Result. Error -&gt; result. message  // 모든 조건을 가지므로 else를 가질 필요가 없음}열거형 클래스:  여러 개의 상수를 선언하고 열거된 값을 조건에 따라 선택할 수 있는 특수한 클래스 자료형이 동일한 상수를 나열할 수 있다(실드 클래스 처럼 다양한 자료형을 다루지 못한다. )1234enum class 클래스이름 [(생성자)] {  상수1[(값)], 상수2[(값)], 상수3[(값)], . . .   [; 프로퍼티 혹은 메서드] // 상수가 끝났음을 의미하는 ; 그 이후 프로퍼티 혹은 메서드를 입력한다. }123enum class Direction {  NORTH, SOUTH, WEST, EAST}1234enum class DayOfWeek(val num: Int) {  MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4),  FRIDAY(5), SATURDAY(6), SUNDAY(7)}12345val day = DayOfWeek. SATURDAY // SATURDAY의 값을 읽기when(day. num) {  1, 2, 3, 4, 5 -&gt; println( Weekday )  6, 7 -&gt; println( Weekend! )}123456789101112// 메서드가 포함되는 경우enum class Color(val r: Int, val g: Int, val b: Int) {  RED(255, 0, 0), ORANGE(255, 165, 0),  YELLOW(255, 255, 0), GREEN(0, 255, 0), BLUE(0, 0, 255),  INDIGO(75, 0, 130), VIOLET(238, 130, 238); // 여기에 세미콜론으로 끝을 알리고  fun rgb() = (r * 250 + g) * 256 + b // 메서드를 포함할 수 있다. }fun main(args: Array) {  println(Color. BLUE. rhb())}열거형 클래스 사용 예시 123456789101112131415interface Score {  fun getScore(): Int}enum class Membertype(var prio: String) : Score { // Score를 구현할 엵형 클래스  NORMAL( Thrid ) {    override fun getScore(): Int = 100  },  SILVER( Second ) {    override fun getScore(): Int = 500  },  GOLD( First ) {    override fun getScore(): Int = 1500  }}12345678910fun main() {  println(MemberType. NORMAL. getScore()) // 100  println(MemberType. GOLD) // GOLD  println(MemberType. valueOf( SILVER )) // SILVER  println(MemberType. SILVER. prio) // Second  for (grade in MemberType. values()) { // 모든 값을 가져오기 위한 반복문    println( grade. name = ${grade. name}, prio = ${grade. prio} )  }}애노테이션 클래스: annotation  코드에 부가 정보를 추가하는 기능 역할 @ 기호와 함꼐 나타내는 표기법으로 주로 컴파일러나 프로그램 실행 시간에서 사전 처리를 위해 사용     @Test 유닛 테스트   @JvmStatic 자바 코드에서 컴패니언 객체를 접근   1annotation class 애노테이션명애노테이션의 속성  @Target: 애노테이션이 지정되어 사용할 종류(클래스, 함수, 프로퍼티 등)를 정의 @Retention: 애노테이션을 컴파일된 클래스 파일에 저장할 것인지 실행 시간에 반영할 것인지 결정 @Repeatable: 애노테이션을 같은 요소에 여러 번 사용 가능하게 할지를 결정 @MustBeDocumented: 애노테이션이 API의 일부분으로 문서화하기 위해 사용속성과 함께 정의된 애노테이션 클래스의 예 12345@Target(AnnotationTarget. CLASS, AnnotationTarget. FUNCTION,    AnnotationTarget. VALUE_PARAMETER, AnnotationTarget. EXPRESSION)@Retention(AnnotationRetention. SOURCE) // 애노테이션의 처리 방법 - SOURCE: 컴파일 시간에 제거됨@MustBeDocumentedannotation class Fancy"
    }, {
    "id": 175,
    "url": "/study_Kotlin_shortCut/",
    "title": "IntelliJ 단축키",
    "body": "2020/08/11 - Ctrl + B: 해당 키워드의 선언부로 이동한다. Ctrl + Shift + F10: 처음 컴파일을 진행하게 될 때 사용한다. Alt + Insert: Package 및 프로젝트 파일을 추가 할 떄 사용한다. Ctrl + D: 한 문장을 복사하여 바로 밑에 붙여넣어 준다. Alt + Shift + ↕: 문장의 순서를 바꿔준다. Alt + Enter: 코드 어시스트! Ctrl + Shift + p: 추론된 타입을 보여준다. "
    }, {
    "id": 176,
    "url": "/study_Kotlin_19/",
    "title": "Kotlin 객체편 - [9]",
    "body": "2020/08/11 - 내부 클래스: 코틀린의 내부 클래스 종류  중첩(Nested) 클래스 이너(Inner) 클래스자바의 내부클래스 종류      종류   역할         정적 클래스(static class)   static 키워드를 가지며 외부 클래스를 인스턴스화 하지않고 바로 사용가능한 클래스(주로 빌더 클래스에 이용)       멤버 클래스(member class)   인스턴스 클래스로도 불리며 외부 클래스의 필드나 메서드와 연동하는 내부 클래스       지역 클래스(local class)   초기화 불록이나 메서드 내의 블록에서만 유효한 클래스       익명 클래스(anonymous class)   이름이 없고 주로 일회용 객체를 인스턴스화 하면서 오버라이드 메서드를 구현하는 내부 클래스. 가독성이 떨어지는 단점이 있다.    익명클래스는 하위클래스로 만들고 객체 생성하지 않아도 바로 인스턴스를 생성할수 있는데, 이를 코틀린에서는 Object가 할수 있다. 자바와 코틀린의 내부 클래스 비교      자바   코틀린         정적 클래스(static class)   중첩 클래스(nested class): 객체 생성 없이 사용 가능       멤버 클래스(member class)   이너 클래스(inner class): 필드나 메서드와 연동하는 내부 클래스로 inner 키워드가 필요하다       지역 클래스(local class)   지역 클래스(local class): 클래스의 선언이 블록에 있다면 지역 클래스이다.        익명 클래스(anonymous class)   익명 객체(ananymous object): 이름이 없고 주로 일회용 객체를 사용하기 위해 object 키워드를 통해 선언된다.    123456789101112131415// 자바의 멤버(이너) 클래스class A {  . . .   class B {    . . . // 외부 클래스 A의 필드에 접근 가능  }}// 자바의 정적 클래스class C {    static class D { // 정적 클래스를 위해 static 키워드 사용    . . .   }}12345678910111213141516// 코틀린의 이너 클래스 (자바의 멤버클래스와 동일!)class A {  . . .   inner class B{ // 자바와 달리 inner 키워드 필요    . . . // 외브 클래스 A의 필드에 접근 가능  }}// 정적 클래스처럼 사용한 코틀린의 중첩 클래스class C{    class D { // 코틀린에서는 아무 키워드가 없는 클래스는 중첩 클래스이며       // 정적 클래스처럼 사용한다.     . . .  // 외부 클래스 A의 프로퍼티, 메서드에 접근 할 수 없다.   }}중첩 클래스(Nested class)는 코틀린에서 기본적으로 정적(static) 클래스 처럼 다뤄진다. 즉 정적클래스로 접근은 static이므로 가능하지만, 해당 정적클래스에서 외부 클래스로는 접근이 불가능하다! 12345678910111213141516171819202122class Outer {  val ov = 5  class Nested {    val nv = 10    fun greeting() =  [Nested] Hello ! $nv  // 외부의 ov에는 접근 불가  }  fun outside() {    val msg = Nested(). greeting() // Outer 객체 생성 없이 중첩 클래스의 메서드 접근    println( [Outer]: $msg, ${Nested(). nv} ) // 중첩 클래스의 프로퍼티 접근  }}fun main() {  //static 처럼 Outer의 객체 생성 없이 Nested객체를 생성 사용할 수 있음  val output = Outer. Nested(). greeting()  println(output)  // Outer. outside() // 에러! Outer 객체 생성 필요  val outer = Outer()  outer. outside()}중첩 클래스에서 바깥 클래스로 접근하는 방법  Outer클래스가 컴패니언 객체를 가지고 있을 때 접근 가능하다12345678910111213class Outer {  class Nested {    . . .     fun accessOuter() { // 컴패니언 객체는 접근할 수 있음      println(country)      getSomething()    }  }  companion object { // 컴패니언 객체는 static처럼 접근 가능    const val country =  Korea     fun getSomething() = println( Get something. . .  )  }}12345678910111213141516171819202122232425262728293031class Outer {  val ov = 5  class Nested {    val nv = 10    fun greeting() =  [Nested] Hello ! $nv  // 외부의 ov에는 접근 불가    fun accessOuter() {      println(country)      getSomething()    }  }  fun outside() {    val msg = Nested(). greeting() // Outer 객체 생성 없이 중첩 클래스의 메서드 접근    println( [Outer]: $msg, ${Nested(). nv} ) // 중첩 클래스의 프로퍼티 접근  }  companion object {    const val country =  Korea     fun getSomething() = println( Get something. . .  )  }}fun main() {  //static 처럼 Outer의 객체 생성 없이 Nested객체를 생성 사용할 수 있음  val output = Outer. Nested(). greeting()  println(output)  Outer. Nested(). accessOuter()  // Outer. outside() // 에러! Outer 객체 생성 필요  val outer = Outer()  outer. outside()}코틀린의 이너 클래스  특별한 키워드인 inner를 사용해 선언된 내부 클래스 이너 클래스는 바깥 클래스의 멤버들에 접근 가능 바깥 클래스의 private 멤버도 접근이 가능12345678910111213class Smartphone(val model: String) {  private val cpu =  Exynos   inner class ExternalStorage(val size: Int) {    fun getInfo() =  ${model}: Installed on $cpu with ${size}Gb  // 바깥 클래스의 프로퍼티 접근  }}fun main() {  val mySdcard = Smartphone( S7 ). ExternalStorage(32)  println(mySdcard. getInfo())}"
    }, {
    "id": 177,
    "url": "/study_Kotlin_18/",
    "title": "Kotlin 객체편 - [8]",
    "body": "2020/08/11 - 데이터 클래스: 데이터 전달을 위한 객체 DTO(Data Transfer Object)  자바에서는 POJO(Plain Old Java Object)라고 불리기도 한다 구현 로직을 가지고 있지 않고 순수한 데이터 객체를 표현한다 데이터를 접근하는 게터/세터를 포함한다 toString(), equals() 등과 같은 데이터 표현 및 비교 메서드를 포함한다자바로 DTO를 포현하면 데이터 필드들, 게터/세터들, 데이터 표현 및 비교 메서드들을 모구 작성해야 한다 코틀린으로 DTO를 표현하면 프로퍼티만 신경 써서 작성하면 나머지는 내부적으로 자동 생성된다. 코틀린의 데이터 클래스(data class)  DTO를 표현하기 적합한 클래스 표현으로 data class 키워드를 사용해 정의한다1코틀린의 프로퍼티 = 필드(변수) + 게터와 세터자동으로 생성되는 메서드들  프로퍼티를 위한 게터/세터 비교를 위한 equals()과 키 사용을 위한 hashCode() 프로퍼티를 문자열로 변환해 순서대로 보여주는 toString() 객체 복사를 위한 copy() 프로퍼티에 상응하는 component1(), component2() 등선언 1data class Customer(var name: String, var email: String)데이터 클래스의 조건  주 생성자는 최소한 하나의 매개변수를 가져야 한다.  주 생성자의 모든 매개변수는 val, var로 지정된 프로퍼티여야 한다.  데이터 클래스는 abstract, open, sealed, inner 키워드를 사용할 수 없다. 데이터 클래스에 간단한 로직을 포함하려면 부 생성자나 init 블록을 넣어 데이터를 위한 간단한 로직을 포함 할 수 있다. 123456789data class Customer(var name: String, var email: String) {  var job: String =  Unknown   constructor(name: String, email: String, _job: String): this(name, email) {    job = _job  }  init {    // 간단한 로직은 여기에  }}자동 생성 메서드들       제공된 메서드   기능         equals()   두 객체의 내용이 같은지 비교하는 연산자로 ==와 동일(고유값은 다르지만 의미값이 같을 떄)       hashCode()   객체를 구별하기 위한 고유한 정수값 생성, 데이터 셋이나 해시테이블을 사용하기 위한 하나의 생성된 인덱스       copys()   빌더 없이 특정 프로퍼티만 변경해서 객체 복사하기       toString()   데이터 객체를 읽기 편한 문자열로 반환하기       componentN()   객체의 선언부 구조를 분해하기 위해 프로퍼티에 상응하는 메서드   메서드 사용 예 equals() &amp; hashCode() 123456val cus1 = Customer( Sean ,  sean@mail. com )val cus2 = Customer( Sean ,  sean@mail. com ). . . println(cus1 == cus2) // trueprintln(cus1. equals(cus2)) // trueprintln( ${cus1. hashCode()}, ${cus2hashCode()} ) // 동일한 고유값 출력copy() &amp; toString() 123var cus3 = cus1. copy(name =  Alice ) // name만 변경하고자 할 때println(cus1. toString()) // Customer(name=Sean, email=sean@mail. com)println(cus3. toString()) //// Customer(name=Alice, email=sean@mail. com)객체 디스트럭처링  객체가 가지고 있는 프로퍼티를 개별 변수로 분해12val (name, email) = cus1println( name = $name, email = $email )특정 프로퍼티를 가져올 필요 없는 경우 1val(_, email) = cus1 // 첫 번째 프로퍼티 제외componentN() 이용 123val name2 = cus1. component1()val email2 = cus1. component2()println( name = $name2, email = $email2 )객체 데이터가 많은 경우 for문의 활용 12345678910val cus1 = Customer( Sean ,  sean@mail. com )val cus2 = Customer( Sean ,  sean@mail. com )val bob = Customer( Bob ,  bob@mail. com )val erica = Customer( Erica ,  erica@mail. com )val customers = listOf(cus1, cus2, bob, erica) // 모든 객체를 컬렉션 List 목록으로 구성. . . for((name, email) in customers) {  println( name = $name, email = $email )}함수로부터 객체가 반환될 경우 12345fun myFunc(): Customer {  return Customer( Mickey ,  mic@abc. com )}. . . val (myNamem myEmail) = myFunc()람다식에서 사용하는 경우 1234567// 람다식 함수로 Destructuring 된 변수 출력해 보기val myLamda = {  (nameLa, emailLa): Customer -&gt;  println(nameLa)  println(emailLa)}myLamda(cus1)"
    }, {
    "id": 178,
    "url": "/study_Kotlin_17/",
    "title": "Kotlin 객체편 - [7]",
    "body": "2020/08/11 - 추상클래스와 인터페이스: 추상클래스(abstract class):  구현 클래스에서 가져야할 명세를 정의한 클래스(프로퍼티 및 메서드 템플릿) abstract라는 키워드와 함꼐 선언하며 추상클래스는 객체 생성 안됨 ‘구체적이지 않는 것’을 나타내기 때문에 하위 파생 클래스에서 구체적으로 구현1abstarct class Vehicle open 키워드를 사용하지 않고도 파생 클래스 작성 가능123456789101112131415161718192021222324252627282930313233343536373839// 주 생성자에 정의된 프로퍼티는 비 추상(non-abstract) 프로퍼티들이다. abstract class Vehicle(val name: String, val color: String, val weight: Double) {  // 추상 프로퍼티 - 하위 클래스에서 반드시 오버라이딩  abstract val maxSpeed: Double  // 비 추상 프로퍼티  var year: String =  2008  // 인터페이스와는 다르게 상태를 저장할 수 있다.     // 추상 메서드  abstract fun start()  abstract fun stop()  //비 추상 메서드  fun displaySpec() {    println( name: $name, color: $color, weight: $weight, year: $tear, maxSpeed: $maxSpeed ) // 추상 프로퍼티도 사용 가능  }}class Car(name: String,      color: String,      weight: Double,      override val maxSpeed: Double) : Vehicle(name, color, weight) {   override fun start() {     println( Car Started )   }   override fun stop() {     println( Car Stopped )   }   fun autoPilotOn() {     println( Auto Pilot ON )   }}fun main() {  var car = Car( Matiz ,  red , 1000. 0, 100. 0)  car. year =  2014  // 추상 클래스의 비 추상 프로퍼티 사용  car. displaySpec()}단일 인스턴스로 객체를 생성: object를 사용한 생성  추상 클래스로부터 하위 클래스를 생성하지 않고 단일 인스턴스로 객체 생성 가능12345678910111213abstract class Printer {  abstract fun print() // 추상 메서드}val myPrinter = object: Printer() { // 객체 인스턴스  override fun print() { // 추상 메서드의 구현    println( 출력합니다.  )  }} // 하위 클래스를 선언해서 상속하고 다시 인스턴스를 만드는 과정을 생략 할 수 있다. 임시적으로 사용할때 유용하다. fun main() {  myPrinter. print()}인터페이스(interface): 계약서의 개념과 비슷하다.  계약서에는 무엇 무엇을 하라는 추상적인 활동들이 적혀 있다.  이것을 어떤 ‘작업자’가 받아들였다면 계약서에 있는 활동에 구체적인 내용을 반드시 실행 해야 한다.  그러나 계약서 자체로는 실행될 수 없다. 추상클래스와는 다른점  클래스가 아니므로 다양한 인터페이스로부터 클래스 구현 가능(다중 상속 지원, 클래스는 상속이 하나만 된다. ) 추상 클래스와는 다르게 강한 연관을 가지지 않는다. 코틀린에서 인터페이스  다른 언어와는 다르게 기본적인 구현 내용이 포함될 수 있다.      자바 버전 8 에서는 default 키워드를 사용해야만 구현 내용을 포함 할 수 있다.     선언하려면 interface 키워드를 사용해 정의 상속한 하위 클래스에서는 override를 사용해 해당 메서드를 구현123456interface 인터페이스명 [: 인터페이스명. . . ] {  추상 프로퍼티 선언  추상 메서드 선언  [일반 메서드 선언 { . . . }] // 이게 가능하다!}1234567891011121314151617181920interface Pet {  var category: String // abstract 키워드가 없어도 기본은 추상 프로퍼티  fun feeding() // 마찬가지로 추상 메서드  fun patting() { // 구현부를 포함하면 일반 메서드로 지정된다.     println( Keep patting! ) // 구현부  }}class Cat(override var category: String) : Pet {  override fun feeding() {    println( Feed the cat a tuna can! )  }  }fun main() {  val obj = Cat( small )  println( Pet Category: ${obj. category} )  obj. feeding() // Cat에서 구현한 메서드  obj. patting() // Pet에서 구현한 일반 메서드}인터페이스에서는 프로퍼티에 값을 저장할 수 없다. (추상클래스는 가능) 그러나 val로 선언된 프로퍼티는 게터를 통해 필요한 내용을 구현할 수 있다. 12345678910111213interface Pet {  var category: String  val msgTags: String // val 선언 시 게터의 구현이 가능    get() =  I'm your lovely pet!   fun feeding()  fun patting() {    println( Keep patting! )  }}. . . println( Pet Message Tags: ${obj. msgTags} ). . . 인터페이스의 상속 예시 123456789101112131415161718192021222324open class Animal(val name: String)// feeding의 구현을 위해 인터페이스 Pet 지정class Dog(name: String, override var category: String) : Animal(name), Pet {  override fun feeding() {    println( Feed the dog a bone )  }}class Master {  fun playWithPet(dog: Dog) { // 각 애완동물 종류에 따라 오버로딩 된다.     println( Enjoy with my dog.  )  }  fun playWithPet(cat: Cat) { // 고양이를 위한 메서드    println( Enjoy with my cat )  }}fun main() {  val master = Master()  val dog = Dog( Toto ,  Small )  val cat = Cat( Coco ,  BigFat )  master. playWithPet(dog)  master. playWithPet(cat)}이 때, 만일 여러 애완동물이 있게되면 playWithPet()은 계속해서 오버로딩 해야 한다. 그렇게 되면 계속해서 동일한 코딩을 중복해서 구현해 줘야 하는 번거로움이 생기게 된다. 이런 번거로움을 해결해 보자. 123456789101112131415161718192021222324252627282930313233interface Pet {  var category: String  var species: String // 추가 구현  val msgTags: String     get() =  I'm your lovely pet!   fun feeding()  fun patting() {    println( Keep patting! )  }}open class Animal(val name: String)class Dog(name: String, override var category: String) : Animal(name), Pet {  override var species: String =  dog   override fun feeding() {    println( Feed the dog a bone )  }}class Master {  fun playWithPet(pet: Pet) { // 인터페이스 객체로 매개변수를 지정한다.     println( Enjoy with my ${pet. species}.  )  }}fun main() {  val master = Master()  val dog = Dog( Toto ,  Small )  val cat = Cat( Coco ,  BigFat )  master. playWithPet(dog)  master. playWithPet(cat)}클래스는 기본적으로 다중 상속을 지원하지 않지만, 인터페이스는 인터페이스 여러개를 하나의 클래스에서 구현하는 것이 가능하므로 다중 상속과 같은 효과를 가진다. 다중 상속 예시 12345678910111213141516171819202122interface Bird {  val wings: Int  fun fly()  fun jump() = println( bird jump! )}interface Horse {  val maxSpeed: Int  fun run()  fun jump() = println( jump!, max speed: $maxSpeed )}class Pegasus: Bird, Horse {  override val wings: Int = 2  override val maxSpeed: Int = 100  override fun fly() = println( Fly! )  override fun run() = println( Run! )  override fun jump() = { // 추가적으로 jump 재정의    super&lt;Horse&gt;. jump()    println( and Jump! )  }}인터페이스의 위임 123456789101112interface A {  fun functionA(){}}interface B {  fun functionB(){}}class C(val a: A, val b: B) {  fun functionC() {    a. functionA()    b. functionB()  }}123456class DelegatedC(a: A, b: B): A by a, B by b {  fun functionC() {    functionA() // A의 위임    functionA() // B의 위임  }}위임을 사용하면 메서드를 쉽게 사용할 수 있다. 위임을 이용한 멤버 접근 123456789101112131415161718192021interface Nameable {  var name: String}class StaffName : Nameable {  override var name: String =  Sean }class Work: Runnable { // 스레드 실행을 위한 인터페이스  override fun run() {    println( work. . .  )  }}// 각 매개변수에 해당 인터페이스를 위임한다. class Person(name: Nameable, work: Runnable): Nameable by name, Runnable by workfun main() {  val person = Person(StaffName(), Work()) // 생성자를 사용해 객체 바로 전달  println(person. name) // 여기서 StaffName 클래스의 name 접근  person. run() // 여기서 Work 클래스의 run 접근}"
    }, {
    "id": 179,
    "url": "/study_Kotlin_16/",
    "title": "Kotlin 객체편 - [6]",
    "body": "2020/08/11 - 정적 변수와 컴페니언 객체: 사용 범위에 따른 분류  지역(local) 전역(global)보통 클래스는 동적으로 객체를 생성하는데 정적으로 고정하는 방법  동적인 초기화 없이 서용할 수 잇는 개념으로 자바에서는 static 변수 또는 객체가 존재하는데, 코틀린에서는 이것을 컴페니언 객체(Companion object)로 사용한다 프로그램 실행 시 고정적으로 가지는 메모리로 객체 생성 없이 사용할 수 있다.  단, 자주 사용되지 않는 변수나 객체를 만들게 되면 메모리 낭비에 대한 이슈가 존재한다. 123456789101112131415161718class Person {  var id: int = 0  var name: String =  Youngdeok   companion object { // 이러한 객체 즉, 컴패니언 객체는 실제 객체의 싱글톤(singleton)으로 정의된다.     var language: String =  Korean     fun work() {      println( working. . .  )    }  }}fun main() {  println(Person. language) // 인스턴스를 생성하지 않고 기본값 사용  Person. language =  English  // 기본값 변경 가능  println(Person. language) // 변경된 내용 출력  Person. work() // 메서드 실행  // println(Person. name) // name은 companion object가 아니므로 에러}코틀린에서 자바의 static 멤버의 사용 1234567// Customer. javapublic class Customer {  public static final String LEVEL =  BASIC ; // static 필드  public static void login() { // static 메서드    System. out. println( Login. . .  );  }}123456// CustomerAccess. kt// 코틀린에서 자바의 static 접근fun main() {  println(Customer. LEVEL)  Customer. login()}자바에서 코틀린 컴패니언 객체 사용 @JvmStatic 애노테이션 표기법 사용 123456class KCustomer {  companioon object {    const val LEVEL =  INTERMEDIATE     @JvmStatic fun login() = println( Login. . .  ) // 애노테이션 표기 사용  }}1234567public class KCustomerAccess {  public static void main(String[] args) }  // 코틀린 클래스의 컴패니언 객체를 접근  System. out. println(KCustomer. LEVEL);  KCustomer. login(); // 애노테이션을 사용할 떄 접근 방법  KCustomer. Companion. login(); // 위와 동일한 결과로 애노테이션을 사용하지 않을 때 접근 방법}최상위 함수(top-level function): 최상위 함수  클래스 없이 만들었던 최상위 함수들은 객체 생성 없이도 어디엣든 실행 패키지 레벨 함수(package-level function) 라고도 함 최상위 함수는 결국 자바에서 static final로 선언된 함수이다. 자바에서 코틀린의 최상위 함수 접근  코틀린의 최상위 함수는 클래스가 없으나 자바와 연동시 내부적으로 파일명에 Kt 접미사가 붙은 클래스를 자동 생성하게 된다.  자동 변환되는 클래스명을 명시적으로 지정하고자 하는 경우 @file:JvmName(“ClassName”)을 코드 상단에 명시한다. 12345678// PackageLevelFUnction. ktfun packageLevelFUnc() {  println( Package-Level Function )}fun main() {  packageLevelFunc()}123456//PackageLevelAccess. javapublic class PackageLevelAccess {  public static void main(String[] args) {    PackageLevelFunctionKt. packageLevelFunc();  }}이름을 명시하여 최상위 함수 접근 12345678910// PackageLevelFUnction. kt@file:JvmName( PKLevel )fun packageLevelFUnc() {  println( Package-Level Function )}fun main() {  packageLevelFunc()}123456//PackageLevelAccess. javapublic class PackageLevelAccess {  public static void main(String[] args) {    PKLevel. packageLevelFunc();  }}object와 싱글톤: 상속할 수 없는 클래스에서 내용이 변경된 객체를 생성할 때  자바의 경우 익명 내부 클래스를 사용해 새로운 클래스 선언 코틀린에서는 object 표현식이나 object 선언으로 이 경우를 좀더 쉽게 처리한다12345678910111213141516171819object OCustomer {  var name =  Kildong   fun greeting() = println( Hello World! )  val HOBBY = Hobby( Basketball )  init {    println( Init! )  }}. . . class Hobby(val name: String)fun main() {  OCustomer. greeting() // 객체의 접근 시점  OCustomer. name =  Dooly   println( name = ${OCustomer. name} )  println(OCustomer. HOBBY. name)  . . . }object 선언 방식은 접근 시점에 객체가 생성된다. 그렇기 때문에 생성자 호출을 하지 않으므로 object 선언에는 주/부 생성자를 사용할 수 없다. 자바에서는 OCustomer. INSTANCE. getName(); 와 같이 접근 해야 한다. object 표현식: object: - object 표현식을 사용할 때  object 선언과 달리 이름이 없으며 싱글톤이 아니다.  따라서 object 표현식이 사용될 때마다 새로운 인스턴스가 생성된다.  이름이 없는 익명 내부 클래스로 불리는 형태를 object 표현식으로 만들수 있다. 1234567891011121314open class Superman() {  fun work() = println( Taking photos )  fun talk() = println( Talking with people.  )  open fun fly() = println( Flying in the air.  )}fun main() {  val pretendedMan = object: Superman() { // object 표현식으로 fly() 구현의 재정의    override fun fly() = println( I'm not a real superman. I can't fly! )  }  pretendedMan. work()  pretendedMan. talk()  pretendedMan. fly()}"
    }, {
    "id": 180,
    "url": "/study_Kotlin_15/",
    "title": "Kotlin 객체편 - [5]",
    "body": "2020/08/05 - 지연 초기화: 변수나 객체의 값은 생성시 초기화가 필요하다. 생성 할때 초기화를 진행하기 보다 해당 정보가 나중에 정해지는 경우가 있으므로 프로그램의 성능측면에서 나중에 초기화를 진행하게 되는데 이때 해당 변수나 객체의 값은 null을 가리키게 된다. 그러나 코틀린에서는 이러한 null 값을 용납하지 못한다. 그래서 lateinit과 lazy를 이용하여 null 값을 가지지 않도록 객체의 정보가 나중에 나타나는 때에 초기화 할수 있도록 도와준다. lateinit: 의존성이 있는 초기화나 unit 테스트를 위한 코드를 작성시  Car 클래스의 초기화 부분에 Engine 클래스와 의존성을 가지는 경우, 다시말해 Engine 객체가 생성되지 않으면 완전하게 초기화 할 수 없는경우 단위(Unit) 테스트를 위해 임시적으로 객체를 생성 시켜야 하는 경우프로퍼티 지연 초기화  클래스를 선언할 때 프로퍼티 선언은 null을 허용하지 않는다.  하지만, 지연 초기화를 위한 lateinit 키워드를 사용하면 프로퍼티에 값이 바로 할당되지 않아도 된다. lateinit의 제한  var로 선언된 프로퍼티만 가능하다.  프로퍼티에 대한 게터와 세터를 사용할 수 없다. 1234567891011121314151617181920class Person {  lateinit var name: String // 늦은 초기화를 위한 선언  fun test() {    if(!::name. isInitialized) { // 프로퍼티의 초기화 여부 판단 (:: -&gt; 참조방식으로 값을 호출)      println( not initialized )     } else {      println( initialized )    }  }}fun main() {  val kildong = Person()  // println( name = ${kildong. name} ) // UninitailizedPropertyAccessException  kildong. test()  kildong. name =  kildong  // 이시점에서 초기화 됨(지연 초기화)  kildong. test()  println( name = ${kildong. name} )}객체 지연 초기화 12345678data class Person(var name:String, var age: Int) lateinit var person1: Person // 객체의 지연 초기화fun main() {  person1 = Person( Kildong , 30) // 생성자 호출 시점에서 초기화 됨  print(person1. name +   is   person1. age. toString())}lazy:  호출 시점에 by lazy {…} 정의에 의해 블록 부분의 초기화를 진행한다. 람다식이라 생각하면 된다.  불변의 변수 선언인 val에서만 사용 가능하다. (읽기 전용) val 이므로 값을 다시 변경 할 수 없다. 12345678910111213141516171819202122class LazyTest {  init {    println( init block )  }  private val subject by lazy {    println( lazy initialized )     Kotlin Programming  // lazy 반환 값 (람다식이라 생각하면 된다)  }  fun flow() {    println( not initialized )    println( subject one: $subject ) // 이떄 초기화가 진행 된다. lazy initialized 출력.     println( subject two: $subject )  }}fun main() {  val test = LazyTest()  test. flow()}lazy 객체 지연 초기화 123456789101112131415161718192021class Person(val name: String, val age: Int)fun main() {  var isPersonInstantiated: Boolean = false // 초기화 용도 확인  val person : Person by lazy {    isPersonInstantiated = true    Person( Kim , 23) // 객첼 반환  }  val personDelegate = lazy { Person( Hong , 40) } // 위임 변수를 사용한 초기화  println( person Init: $isPersonInstantiated )  println( personDelegate Init: ${personDelegate. isInitialized()} )  println( person. name = ${person. name} ) // 이 때 초기화  println( personDelegate. value. name = ${personDelegate. value. name} ) // 이 때 초기화  println( person Init: $isPersonInstantiated )  println( personDelegate Init: ${personDelegate. isInitialized()} )}by laze의 모드 3가지 모드를 지정 가능 하다  SYNCHRONIZED 락을 사용해 단일 스레드만이 사용하는 것을 보장(기본값) PUBLICATION 여러 군데서 호출될 수 있으나 처음 초기화도니 후 반호나 값을 사용 NONE 락을 사용하지 않기 때문에 빠르지만 다중 스레드가 접근할 수 있음(값의 일관성을 보장할 수 없음)123private val model by lazy (mode = LazyThreadSafetyMode. NONE) {  Injector. app(). transactionsModel() // 이 코드는 단일 스레드의 사용이 보장 될 때 사용하는 것이 안전하다 }by를 통한 위임: 위임(delegation)  하나의 클래스가 다른 클래스에 위임하도록 선언 위임된 클래스가 가지는 멤버를 참조없이 호출1&lt; val|var|class &gt; 프로퍼티 혹은 클래스 이름: 자료형 by 위임자1234567interface Animal {  fun eat() {. . . }  . . . }class Cat : Animal { }val cat = Cat()class Robot : Animal by cat // Amimal의 정의된 Cat의 모든 멤버를 Robot에 위임함 cat은 Animal 자료형의 private 멤버로 Robot 클래스 내에 저장 Cat에서 구현된 모든 Animal의 메소드는 정적 메소드로 생성 따라서, Animal에 대한 명시적인 참조를 사용하지 않고도 eat()을 바로 호출위임을 사용하는 이유코틀린의 기본 라이브러리는 open 되지 않은 최종 클래스  표준 라이브러리의 무분별한 상속의 복잡한 문제들을 방지한다.  단, 상속이나 직접 클래스의 기능 확장을 하기 어렵다. 위임을 사용하게 되면  위임을 통해 상속과 비슷하게 최종 클래스의 모든 기능을 사용하면서 동시에 기능을 추가 확장 구현할 수 있다. 12345678910111213141516171819202122interface Car {  fun go(): String}class VanImpl(val power: String): Car{  override fun go() =  는 짐을 적재하며 $power 마력을 가집니다.  }class SportImpl(val power: String): Car {  override fun go() =  는 경주용에 사용되며 $power 마력을 가집니다.  }class CarModel(val model: String, impl: Car): Car by impl {  fun carInfo() {    println( $model ${go()} ) // 참조 없이 각 인ㄴ터페이스 구현 클래스의 go를 접근한다.   }}fun main() {  val myDamas = CarModel( Damas 2010 , VanImpl( 100마력 ))  val my350z = CarModel( 350Z 2008 , SportImpl( 350마력 ))  myDamas. carInfo() // carInfo에 대한 다형성을 나타냄  my350z,carInfo()}by위임을 사용하지 않을 시 1234567891011121314151617181920212223242526interface Car {  fun go(): String}class VanImpl(val power: String): Car{  override fun go() =  는 짐을 적재하며 $power 마력을 가집니다.  }class SportImpl(val power: String): Car {  override fun go() =  는 경주용에 사용되며 $power 마력을 가집니다.  }class CarModel(val model: String, private val impl: Car): Car {  override fun go() : String { // interface이기 때문에 override 해줘야 한다.     return  Test    }    fun carInfo() {    println( $model ${impl. go()} ) // 참조 없이 각 인ㄴ터페이스 구현 클래스의 go를 접근한다.   }}fun main() {  val myDamas = CarModel( Damas 2010 , VanImpl( 100마력 ))  val my350z = CarModel( 350Z 2008 , SportImpl( 350마력 ))  myDamas. carInfo() // carInfo에 대한 다형성을 나타냄  my350z,carInfo()}프로퍼티 위임과 by lazy 다시보기: by lazy {…} 도 위임이다.  사용된 프로퍼티는 람다식 함수에 전달되어(위임되어) 함수에 의해 사용동작분석  lazy 람다식 함수는 람다를 전달받아 저장한 Lazy 인스턴스를 반환한다.  최초 프로퍼티의 게터 실행은 lazy에 넘겨진 람다식 함수를 실행하고 결과를 기록한다.  이후 프로퍼티의 게터 실행은 이미 초기화되어 기록된 값을 반환한다. observable과 vetoable의 위임: observable  프로퍼티를 감시하고 있다가 특정 코드의 로직에서 변경이 일어날 때 호출vetoable  감시보다는 수여한다는 의미로 반환값에 따라 프러포티 변경을 허용하거나 취소123456789101112131415import kotlin. properties. Delegatesclass User {  // observable은 값의 변화를 감시하는 일종의 콜백 루틴  var name: String by Delegates. observable( NONAME ) { // 1. 프로퍼티를 위임    prop, old, new -&gt; // 2. 람다식 매개변수로 프로퍼티, 기존값, 새로운 값    println( $old -&gt; $new) // 3 이 부분은 이벤트가 발생할 때만 실행된다.   } // 마지막 람다식이기 때문에 중괄호를 빼내서 사용하는 것}fun main() {  val user = User()  user. name =  Kildong  // 4. 값이 변경되는 시점에서 첫 이벤트 발생  user. name =  Dooly  // 5 값이 변경되는 시점에서 두번째 이벤트 발생}1234567891011121314151617import kotlin. properties. Delegatesfun main() {  var max: Int by Delegates. vetoable(0) { // 1. 초기값은 0    prop, old, new -&gt;     new &gt; old // 2. 조건에 맞지 않으면 거부권 행사  }  println(max) // 0  max = 10  println(max) // 10  // 여기서는 기존 값이 새 값보다 크므로 false  // 따라서 5를 재할당 하지 않는다.   max = 5  println(max) // 10}"
    }, {
    "id": 181,
    "url": "/study_Kotlin_14/",
    "title": "Kotlin 객체편 - [4]",
    "body": "2020/08/05 - Getter &amp; Setter: 코틀린에서 게터와 세터가 작동하는 방식  접근 매서드는 생략(내부적으로 생성된다)123456class User(_id: Int, _name: String, _age: Int) {  // 프로퍼티들  val id: Int = _id   var name: String = _name  var age: Int = _age}좀더 간략히 1class User(val id: Int, var name: String, var age: Int)1234567891011fun main() {  val user = User(1,  Sean , 30)  // 게터에 의한 값 획득  val name = user. name    // 세터에 의한 값 지정  user. age = 41  println( name: $name, ${user. age} )}Custom: Getter &amp; Setter: 게터와 세터가 포함되는 프로퍼티 선언 구조 123456var 프로퍼티이름[: 프로퍼티자료형] [= 프로퍼티 초기화]  [get() { 게터 본문 } ]  [set(value) { 세터 본문 } ]val 프로퍼티이름[: 프로퍼티자료형] [= 프로퍼티 초기화]  [get() { 게터 본문 } ]불변형인 val은 게터만 설정 가능하다. 12345678910111213141516171819202122232425class User(_id: Int, _name: String, _age: Int) {  // 프로퍼티들  val id: Int = _id     get() = field // 이곳에 id 를 입력해 버리면 코틀린 내부적으로 getter가 동작하여 무한 재귀 호출에 빠지게 된다.   var name: String = _name    get() = field    set(value) {      field = value    }  var age: Int = _age    get() = field    set(value) {      field = value    }}fun main() {  val user = User(1,  Kildong , 30)    // user. id = 2 // 에러! val 프로퍼티는 값 변경 불가  user. age = 41  println( name: $name, ${user. age} ) // 게터 동작}value: 세터의 매개변수로 외부로 부터 값을 가져온다.  외부의 값을 받을 변수가 되므로 value 대신 어떤 이름이든지 상관 없다. feild: 프로퍼티를 참조하는 변수로 보조 필드(backing field)로 불린다.  프로퍼티를 대신할 임시 필드로 만일 프로퍼티를 직접 사용하면 게터나 세터가 무한 호출되는 재귀에 빠지게 된다. 사실 위의 코드는 getter와 setter의 동작 코드이기 때문에 중복이라고 할수 있다. 조금 더 변경해보자 123456789101112131415161718192021222324class User(_id: Int, _name: String, _age: Int) {  // 프로퍼티들  val id: Int = _id     get() = field // 이곳에 id 를 입력해 버리면 코틀린 내부적으로 getter가 동작하여 무한 재귀 호출에 빠지게 된다.   var name: String = _name    get() = field    set(value) {      println( The name was changed )      field = value. toUpperCase()    }  var age: Int = _age    get() = field    set(value) {      field = value + 10    }}fun main() {  val user = User(1,  Kildong , 30)  user. name =  coco  // 여기서 사용자 고유의 출력 코드가 실행  println( name: $name, ${user. age} ) // 게터 동작}임시적인 보조 프로퍼티 123456789101112131415161718192021222324252627class User(_id: Int, _name: String, _age: Int) {  // 프로퍼티들  val id: Int = _id   private var tempName: String? = null  var name: String = _name    get() {      if (tempname == null) tempName =  NONAME       return tempName ?: throw AsertionError( Asserted by others )    }    set(value) {      println( The name was changed )      field = value. toUpperCase()    }  var age: Int = _age    get() = field    set(value) {      field = value + 10    }}fun main() {  val user = User(1,  Kildong , 30)  user. name =     println( name: $name, ${user. age} ) // tempName이 null 이기 떄문에  NONAME 만을 출력하게 된다}프로퍼티의 오버라이딩 12345678910111213141516171819202122232425262728open class First {  open val x: Int = 0 // 오버라이딩 가능    get() {      println( First x )      return field    }  val y: Int = 0 // open 키워드가 없으면 final 프로퍼티}class Second : First() {  override var x: Int = 0 // val -&gt; var 부모와 구현이 다름 (반대의 경우는 불가능)    get() {      println( Second x )      return field + 3    }    set(value) {      field = value + 10    }  //override val y: Int = 0 // 에러 오버라이딩 불가}fun main() {  val second = Second()  println(second. x) // 오버라이딩 된 두번쨰 클래스 객채의 x  second. x = 10  println(second. x) // 23  println(second. y) // 부모로 부터 상속 받은 값}"
    }, {
    "id": 182,
    "url": "/study_Kotlin_13/",
    "title": "Kotlin 객체편 - [3]",
    "body": "2020/08/05 - 캡슐화(encapsulation): 가시성 지시자(visibility modifiers)를 통해 외부 접근 범위를 결정  private : 외부 접근 불가 public : 어디서든 접근 가능(기본값) protected : 외부 접근 불가 그러나 하위 상속 요소에서는 가능 internal : 같은 정의의 모듈 내부에서는 접근이 가능 (자바에서는 package 모듈은 패키지보다 상위 개념이다. )선언 위치 12345678910[가시성 지시자] &lt;val | var&gt; 전역 변수명[가시성 지시자] fun 함수명() { . . . }[가시성 지시자] [특정키워드] class 클래스명 [가시성 지시자] constructor(매개변수들) {   // 주 생성자에 가시성 지시자가 사용되면 constructor키워드를 생략할 수 없다.   [가시성 지시자] constructor() { . . . }  [가시성 지시자] 프로퍼티들  [가시성 지시자] 메서드들}상속 Test: 12345678910111213141516171819202122232425262728293031323334private class PrivateTest {  private var i = 1  private fun privateFunc() {    i += 1    println(i)  }  fun access() {    privateFunc()  }}class OtherClass {  // val pc = PrivateTest() // class 자체가 private하므로 다른 클래스에서 public하게 할당 불가  private val pc = PrivateTest() // 이렇게는 가능!  fun test() { // 함수 내로 들어오게 되면 한번은 가려지게 되므로 할당이 가능하다.     val testPc = PrivateTest()    testPc. access()  }}fun main() {  val pc = PrivateTest()  // pc. i = 3 // private이므로 접근 불가  //pc. privateFunc() // 위와 동일하게 접근 불가  pc. access()}fun topFunction() {  fun localFunction() {    val pc = PrivateTest() // 동일한 페이지 함수 내에서는 private 클래스 할당 가능.     pc. access()  }}protected 1234567891011121314151617181920212223242526272829303132333435363738394041open class Base {  protected var i =1  protected fun protectedFunc() {    i += 1    println(i)  }  fun access() {    protectedFunc()  }  protected class Nested // 내부 클래스에는 지시자 허용}class Derived : Base() {  var j = 1 + i  fun derivedFunc(): Int {    protectedFunc()    return i  }  fun test(base: Base): Int {    protectedFunc()     return i   }}class Other {  fun other() {    val base = Base()    // base. i = 3 // 접근 불가  }}fun main() {  val base = Base()  // base. i // 접근 불가  // base. protectedFunc() // 접근 불가  base. access()  val derived = Derived()  derived. j = 3  derived. derivedFunc()}internal : 모듈 단위 - 프로젝트에 모듈을 만들지 않았다면 프로젝트 자체가 모듈이 된다. 123456789101112131415161718192021222324internal class InternalClass {  internal var i = 1  internal fun icFunc() {    i += 1 // 접근 허용  }  fun access() {    icFunc() // 접근 허용  }}class Other {  internal val ic = InternalClass() // 프로퍼티 지정시 internal로 맞춰야 한다.   // val ic = InternalClass() // 불가능  fun test() {    ic. i // 접근 허용    ic. icFunc() // 접근 허용  }}fun main() {  val mic = InternalClass() // 생성 가능  mic. i // 접근 허용  mic. icFunc() // 접근 허용}12345fun main() { // 파일이 달라져도 접근 가능 (같은 모듈 내에서)  val otheric = InternalClass()  println(otheric. i)  otheric. icFunc()}다이어그램에서 가시성 지시자       기호   가시성 지시자         -   private       #   protected       ~   internal       +   public    123456789101112131415161718192021222324open class Base {  // 이 클래스에서는 a, b, c, d, e 접근 가능  private val a = 1  protected open val b = 2  internal val c = 3  val d = 4 // 가시성 지시자 기본값은 public  protected class Nested {    // 이 클래스 에서는 a, b, c, d, e, f 접근 가능    publiv val e: Int = 5    private val f: Int = 6  }}class Derived : Base() {  // 이 클래스에서는 b, c, d, e 접근 가능  // a 는 접근 불가  oberride val b = 5 // Base의 'b' 는 오버라이딩됨 - 상위와 같은 protected 지시자}class Other(base: Base) {  // base. a, base. b는 접근 불가  // base. c와 base. d는 접근 가능(같은 모듈 안에 있으므로)  // base. Nested는 접근 불가, Nested::e 역시 접근 불가}  123456789101112131415161718192021// Associationclass Patient(val name: String) {  fun doctorList(d: Doctor) {    println( Patient: $name, Doctor: ${d. name} )  }}class Doctor(val name: String) {  fun patientList(p: Patient) {    println( Doctor: $name, Patient: ${p. name} )  }}fun main() {  val doc1 = Doctor( Kim )  val patient1 = Patient( Kildong )  doc1. patientList(patient1)  patient1. doctorList(doc1)}1234567891011121314151617181920212223// Dependencyclass Patient(val name: String, var id: Int) {  fun doctorList(d: Doctor) {    println( Patient: $name, Doctor: ${d. name} )  }}class Doctor(val name: String, val p: Patient) {  val customerId: Int = p. id  fun patientList() {    println( Doctor: $name, Patient: ${p. name} )    println( Patient Id: $customerId )  }}fun main() {  val patient1 = Patient( Kildong , 1234)  val doc1 = Doctor( Kim , patient1)  doc1. patientList()}12345678910111213141516171819202122232425// Aggregation// 여러 마리의 오리를 위한 List 매개변수class Pont(_name: String, _members: MutableList&lt;Duck&gt;) {  val name: String = _name  val members: MutableList&lt;Duck&gt; = _members  constructor(_name: String): this(_name, mutableListOf&lt;Duck&gt;())}class Duck(val name: String)fun main() {  // 두 개체는 서로 생명주기에 영향을 주지 않는다.   val pond = Pond( myFavorite )  val duck1 = Duck( Duck1 )  val duck2 = Duck( Duck2 )  // 연못에 오리를 추가 - 연못에 오리가 집합한다  pond. members. add(duck1)  pond. members. add(duck2)  // 연못에 있는 오리들  for (duck in pond. members) {    println(duck. name)  }}123456789101112131415161718// Compositionclass Car(val name: String, val power: String) {  private var engine = Engine(power) // Engine 클래스 객체는 Car에 의존적  fun startEngine() = engine. start()  fun stopEngine() = engine. stop()}clas Engine(power: String) {  fun start() = println( Engine has been started.  )  fun stop() = println( Engine has been stopped.  )}fun main() {  val car = Car( tico ,  100hp )  car. startEngine()  car. stopEngine()} "
    }, {
    "id": 183,
    "url": "/study_Kotlin_12/",
    "title": "Kotlin 객체편 - [2]",
    "body": "2020/08/05 - this &amp; super:       super   this         super. 프로퍼티명 // 상위 클래스의 프로퍼티 참조   this. 프로퍼티명 // 현재 클래스의 프로퍼티 참조       super. 매서드명() // 상위 클래스의 메서드 참조   this. 메서드명() // 현재 클래스의 메서드 참조       super() // 상위 클래스의 생성자 참조   this() // 현재 클래스의 생성자 참조   123456789101112131415open class Bird(var name: String, var wing: Int, var beak: String, var color: String) {  fun fly() = println( Fly wing: $wing )  open fun sing(vol: Int) = println( Sing vol: $vol )}class Parroy(name: String, wing: Int = 2, beak: String, color: String,       var language: String =  natural ) : Bird(name, wing, beak, color) {  fun speak() = println( Speak! $language )  override fun sing(vol: Int) { // 부모의 내용과 새로 구현된 내용을 가진다.     super. sing(vol) // 상위 클래스의 sing()을 먼저 수행한다.     println( I'm a parrot! the volume level is $vol )    speak()  }}this와 super를 사용하는 부 생성자 예시 123456789101112131415161718192021open class Person {  constructor(firstName: String) {    println( [Person] firstName: $firstName )  }  constructor(firstName: String, age: Int) {    println( [Person] firstName: $firstName, $age ) // 첫번째 실행  }}class Developer : Person {  constructor(firstName: String): this(firstName, 10) { // 아래 constructor를 참조하게 된다. 마지막에 실행    println( [Developer] $firstName )  }  constructor(firstName: String, age: Int): super(firstName, age) {    println( [Developer] $firstName, $age ) // 상위 클래스 constructor 참조. 두번째 실행  }}fun main() {  val sean = Developer( Sean )}1234567891011121314151617class Person(firstName: String, out: Unit = println( [Primary constructor] Parameter )) { // 3  val fName = println( [Property] Person fName: $firstName ) // 4  init { // 5    println( [init] Person init block )  }  constructor(firstName: String, age: Int, // 1        out:Unit = println( [Secondary Constructor] Parameter )) this(firstName) { // 2    println( [Secondary Constructor] Body: $firstName, $age ) // 6  }}fun main() {  val p1 = Person( Kildong , 30)  println()  // val p2 = Person( Dooly )}@ 기호: 이너 클래스에서 바깥 클래스의 상위 클래스를 호출하려면 super 키워드와 함께 @ 기호 옆에 바깥 클래스명을 작성해 호출한다. 123456789101112131415161718192021222324open class Base {  open val x: Int = 1  open fun f() = println( Base Class f() )}class Child : Base() {  override val x: Int = super. x + 1  override fun f() = println( Child Class f() )  inner class Inside {    fun f() = println( Inside Class f() )    fun test() {      f() // 1. 현재 이너 클래스 f() 접근      Child(). f() // 2. 바로 바깥 클래스인 Child 클래스 f() 접근      super@Child. f() // 3. Child의 상위 클래스인 Base 클래스 f() 접근      println( [Inside] super@Child. x: ${super@Child. x} ) // 4. Base의 x 접근    }  }}fun main() {  val c1 = Child()  c1. Inside(). test() // 이너 클래스 Inside의 메서드 test() 실행}&lt;&gt; 을 사용한 이름 중복 해결: 123456789101112131415161718192021open class A {  open fun f() = println( A Class f() )  fun a() = println( A Class a() )}interface B {  fun f() = println( B Interface f() )  fun b() = println( B Interface b() )}class C : A(), B {  override fun f() = println( C Class f() )  fun test(() {    f() // 현재 클래스의 f()    b() // 인터페이스 B의 b()    super&lt;A&gt;. f() // A 클래스의 f()    super&lt;B&gt;. f() // 인터페이스 B의 f()  }}fun main() {  val c = C()  c. test()}"
    }, {
    "id": 184,
    "url": "/study_Kotlin_11/",
    "title": "Kotlin 객체편 - [1]",
    "body": "2020/08/05 - 생성자: 123456789class 클래스명 constructor(필요한 매개변수들. . ) { // 주 생성자의 위치  . . .   constructor(필요한 매개변수들. . ) { // 부 생성자의 위치    // 프로퍼티의 초기화  }  [constructor(필요한 매개변수들. . ) { . . . }] // 추가 부 생성자  . . . } 주 성생자(Primary constructor)클래스명과 함께 기술되며 보통의 경우 constructor 키우드를 생략할 수 있다. 1234567891011121314151617181920212223class Bird (var name: String, val wing: Int, var beak: String) {  /*var name: String = _name  val wing: Int = _wing  var beak: String = _beak*/  /*constructor(_name: String, _wing: Int, _beak: String) {    name = _name    wing = _wing    beak = _beak  }*/  init {    println( -----------init start ------------ )    name = name. capitalize()    println( name: $name, wing: $wing, break: $break )    println( -----------init end  ------------ )  }  fun fly() {    println( Fly )  }}fun main() {  val coco = Bird( coco , 2,  long )  coco. fly()}init{} 초기화 블록: 객체가 생성될 때 자동으로 실행되는 block을 설정할수 있다. 해당 블록의 작업시간이 길어질수록 객체 생성 시간이 늘어나므로 간단한 코드를 사용한다.  부 생성자(Secondary Constructor)클래스 본문에 기술되며 하나 잇아의 부 생성자를 정의할 수 있다. 123456789101112131415161718192021222324252627class Bird {  var name: String  val wing: Int  var beak: String  constructor(_name: String, _wing: Int, _beak: String) {    name = _name    wing = _wing    beak = _beak  }  constructor(_name: String, _beak: String) {    name = _name    wing = 2    beak = _beak  }  fun fly() {    println( Fly )  }}fun main() {  val coco = Bird( coco , 2,  long )  val coco2 = Bird( coco ,  short )  coco. fly()  println( coco2: name: ${coco2. name}, wing: ${coco2. wing}, beak: ${coco2. beak} )}상속: 123456open class 기반 클래스명 { // open으로 파생 가능 (다른 클래스가 상속 가능한 상태가 됨)  . . . }class 파생 클래스명 : 기반 클래스명() { // 기반 클래스로 부터 상속, 최종 클래스로 파생 불가 ( : 사이로 빈칸이 양쪽으로 존재해야 한다!!)  . . . }코틀린의 모든 클래스는 묵시적으로 Any로부터 상속 1234567891011121314151617181920212223242526open class Bird(var name: String, var wing: Int, var beak: String) {  fun fly () {    println( Fly )  }}class Lark(name: String, wing: Int, beak: String) : Bird(name, wing, beak){  fun singHitone() {    println( sing Hitone )  }}class Parrot : Bird {  var language: String  constructor(name: String, wing: Int, beak: String, language: String) : super(name, wing, beak) {    this. language = language  }  fun speak() {    println( Speak: $language )  }}fun main() {  val lark = Lark( myLark , 2,  short )  val parrot = Parrot( myParrot , 2,  long ,  English )}다형성(polymorphism): 같은 이름을 사용하지만 구현 내용이 다르거나 매개변수가 달라서 하나의 이름으로 다양한 기능을 수행할 수 있는 개념 Static Polymorphism  컴파일 타임에 결정되는 다형성 단순하게 보면 메서드 overloding을 사용할 때12fun example(a: Int)fun example(a: Int, b: Int)Dynamic Polymorphism  런타임 다형성 동적으로 구성되는 overrideing된 메서드를 사용할 때123456789101112131415open class Parent (name: Int) {  open fun example()}class Child1(name: Int) : Parent(name) {  override fun example()}class Child2(name: Int) : Parent(name) {  override fun example()}var child1 = Child1(1)var child2 = Child1(1)child1. example()child2. example()overriding  기능을 완전히 다르게 바꿔 재설계 누르다 -&gt; 행위 -&gt; push() push()는 ‘확인’ 혹은 ‘취소’ 용도로 서로 다른 기능을 수행 할 수 있음overloading  기능은 같지만 인자를 다르게 하여 여러 경우를 처리 출력한다 -&gt; 행위 -&gt; print() print(123), print(“Hello”) 인자는 다르지만 출력의 기능은 동일함12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849open class Bird(var name: String, var wing: Int, var beak: String) {  open fun fly () {    println( Fly )  }}class Lark(name: String, wing: Int, beak: String) : Bird(name, wing, beak){  fun singHitone() {    println( sing Hitone )  }  override fun fly () {    println( Quick Fly )  }}class Parrot : Bird {  var language: String  constructor(name: String, wing: Int, beak: String, language: String) : super(name, wing, beak) {    this. language = language  }  fun speak() {    println( Speak: $language )  }  override fun fly () {    println( Slow Fly )  }}fun main() {  var lark = Lark( myLark , 2,  short )  var parrot = Parrot( myParrot , 2,  long ,  English )  lark. fly() // Quick Fly  lark. singHitone()  parrot. fly() // Slow Fly  parrot. speak()  var lark: Bird = Lark( myLark , 2,  short )  var parrot: Bird = Parrot( myParrot , 2,  long ,  English )  lark. fly() // 동일하게 Quick Fly  // lark. singHitone() error  parrot. fly() // 동일하게 Slow Fly  // parrot. speak() error}12345open class Lark() : Bird() { // open! 상위클래스 이다.   final override fun sing() { // 하위 클래스에서 override 금지    /* 구현부를 새롭게 재정의 */  }}"
    }, {
    "id": 185,
    "url": "/study_Kotlin_9/",
    "title": "Kotlin 함수편 - [9]",
    "body": "2020/08/04 - closure:  람다식으로 표현된 내부 함수에서 외부 범위에 선언된 변수에 접근할 수 있는 개념 람다식 안에 있는 외부 변수는 값을 유지하기 위해 람다가 포획(capture)한 변수12345678910111213fun main() {  val calc = Calc()  var result = 0 // 람다식 외부 변수  calc. addNum(2, 3) { x, y -&gt; result = x + y} // closure  println(result) // 값을 유지하여 5가 출력된다!}class Calc {  fun addNum(a: Int, b: Int, add: (Int, Int) -&gt; Unit) {    add(a, b)  }}12345678// 길이가 일치하는 이름만 반환fun filteredNames(length: Int) {  val names = arrayListOf( Kim ,  Hong ,  Go ,  Hwang ,  Jeon )  val filterResult = names. filter {    it. length == length // 바깥의 length에 접근  }  println(filterResult)}let():  함수를 호출하는 객체 T를 이어지는 block의 인자로 넘기고 block의 결과값 R을 반환public inline fun &lt;T, R&gt; T. let(block: (T) -&gt; R):R { . . . return block(this)}  매개변수 block은 T를 매개변수로 받아 R을 반환 let()함수 역시 R을 반환 본문의 this는 객체 T를 가리키는데 람다식 결과 부분을 그대로 반환한다는 뜻 다른 메서드를 실행하거나 연산을 수행해야 하는 경우 사용1234567891011121314151617181920fun main() {  val score: Int? = 32  //var score = null  // 일반적인 null 검사  fun checkScore() {    if (score != null) {      println( Score: $score )    }  }  // let을 사용해 null 검사를 제거  fun checkScoreLet() {    score?. let { println{ Score: $it } }    val str = score. let { it. toString() }    println(str)  }  checkScore()  checkScoreLet()}let 함수의 체이닝(chaining) 123456789101112fun main() {  var a = 1  val b = 2  a = a. let { it + 2 }. let {    println( a = $a )    val i = it + b    i  }  println(a) // 5}let의 중첩 사용 123456var x =  Kotlin!   x. let { outer -&gt;    outer. let { inner -&gt;      print( Inner is $inner and outer is $outer ) // 이떄는 it을 사용하지 않고 명시적 이름을 사용한다.     }  }반환값은 바깥쪽의 람다식에만 적용 12345678var x =  Kotlin!   x. let { outer -&gt;    outer. let { inner -&gt;      print( Inner is $inner and outer is $outer )       Inner String  // 이건 반환 되지 않는다.     }     Outer String  // 이 문자열이 반환되어 x에 할당된다.   }let의 활용 - null 검사 12345var obj: String?. . . if (null != obj) { // 기존 방식  Toast. makeText(applicationContext, obj, Toast. LENGTH_LONG). show()}123var obj?. let { // obj가 null 아닐경우 작업 수행 (Safe calls + let)  Toast. makeText(applicationContext, it, Toast. LENGTH_LONG). show()}12345678val firstName: String?var lastName: String. . . if (null != firstName) { // 기존 방식  print( $firstName $lastName )} else {  print( $lastName )}12var firstName?. let { // obj가 null 아닐경우 작업 수행 (Safe calls + let)  print( $it $lastName ) } ?: print( $lastName )also(): public inline fun &lt;T&gt; T. also(block: (T) -&gt; Unit): T { block(this); return this } 함수를 호출하는 객체 T를 이어지는 block에 전달하고 객체 T 자체를 반환. (let은 블록의 결과값 반환) 123var m = 1m = m. also { it + 3 }println(m) // 1let 과 also 비교 12345678910111213141516171819fun main() {  data class Person(var name: String, var skills: String)  var person = Person( Kildong ,  Kotlin )  val a = person. let {    it. skills =  Anroid      success   }  println(person)  println( a: $a ) // success  val b = person. also {    it. skills =  Java   }  println(person)  println( b: $b ) // person이 실행}also 활용 123456// 기존 함수fun makeDIr(path: String): FIle {  val result = File(path)  result. mkdirs()  return result}12// let과 also 활용fun makeDIr(path: String) = path. let { File(it) }. also{ it. mkdirs() }왜 let을 쓰고 also를 쓰는지 잘 생각해 보자. apply(): public inline fun &lt;T&gt; T. apply(block: T. () -&gt; Unit): T { block(); return this } also() 함수와 동일하게 호출하는 객체 T를 이어지는 block으로 전달하고 객체 자체인 this를 반환. also는 block에서 람다식으로 처리하지만 apply는 확장 함수로 처리한다. (it을 사용하지 않고, this를 사용) 123456789101112131415fun main() {  data class Person(var name: String, var skills: String)  var person = Person( Kildong ,  Kotlin )  person. apply { this. skills =  Swift  }  println(person)  val returnObj = person. apply {    name =  Sean  // this는 생략할수 있음    skills =  Java  // this 없이 객체의 멤버에 여러번 접근 가능  }  println(person)  println(returnObj) // person이 실행}apply 활용 123456// 기존 코드val param = LinearLayout. LayoutParams(0, LinearLayout. LayoutParams. WRAP_CONTENT)param. gravity = Gravity. CENTER_HORIZONTALparam. weight = 1fparam. topMargin = 100param. bottomMargin = 100123456val param = LinearLayout. LayoutParams(0, LinearLayout. LayoutParams. WRAP_CONTENT). apply {  gravity = Gravity. CENTER_HORIZONTAL  weight = 1f  topMargin = 100  bottomMargin = 100}디렉토리 생성 123456// 기존 함수fun makeDIr(path: String): FIle {  val result = File(path)  result. mkdirs()  return result}1File(path). apply { mkdirs() }"
    }, {
    "id": 186,
    "url": "/study_Kotlin_8/",
    "title": "Kotlin 함수편 - [8]",
    "body": "2020/08/04 - try {   예외 발생 가능성 있는 문장 } catch (e: 예외처리 클래스명) {   예외를 처리하기 위한 문장 } finally {   반드시 실행되어야 하는 문장 } try에서 예외로 인해 반드시 실행되어야 하는 문장이 필요할 경우 finally를 이용한다. 없다면 생략 가능. ### 특정 예외 처리 산술 연산에 대한 예외를 따로 특정해서 잡고자 한다면 12345 . . . } catch (e: ArithmeticException) {   println( Exception is handled. ${e. message}  ) // 0으로 나눌경우   //Exception is handled. / by zero 를 리턴. }스택의 추적 12345678 . . . } catch (e: Exception) {   e. printStackTrace() // 0으로 나눌 경우  /**  java. lang. ArithmeticException : / bt zero    at . . . (패키지 및 주소). main  */}특정 조건에 따른 예외 발생 1throw Exception(message: String)12345678910111213141516fun main() {  var amount = 600  try {    amount -= 100    checkAmount(amount)  } catch (e : Exception) {    println(e. message)  }  println( amount: $amount )}fun checkAmount(amount: Int) {  if (amount &lt; 1000)    throw Exception( 잔고가 $amount 으로 1000 이하입니다.  )}"
    }, {
    "id": 187,
    "url": "/study_Kotlin_7/",
    "title": "Kotlin 함수편 - [7]",
    "body": "2020/08/04 - for문: 자바와 같은 세미콜론을 이용한 for문은 사용할 수 없다. 12345for (x in 1. . 5) { // 1-&gt;5  println(x)}for (x in 1. . 5) println(x) // if문과 동일하게 한줄 표현도 가능하행 반복 12// for (x in 5. . 1) println(x) // 잘못된 사용! 아무것도 출력되지 않는다. for (x in 5 downTo 1) println(x)필요한 단계 증가 12for (x in 1. . 5 step 2) println(x) // 1 3 5for (x in 5 downTo 1 step 2) println(x) // 5 3 1until 1for (x in 1 until 6) println(x) // 6 전까지만 간다. 흐름 제어: return:  return으로 Unit 이 가능하다. (기억해두자. )람다식에서 return 사용하기 우선 inline으로 선언되지 않는 람다식 함수에서는 그냥 return은 사용이 가능하지 않다. 람다식 특성상 마지막 식이 반환되기 때문이다. 그렇지만 흐름제어를 하다보면 return이 필요한 순간이 찾아온다. inline으로 람다식을 구성하면 return이 가능하지만, 비지역 반환이 일어나게 되어 람다식 함수가 끝남과 동시에 람다식 함수를 가지고 있는 함수까지도 return이 이루어지게된다. 1234567891011121314151617fun main() {  retFunc()}inline fun inlineLambda(a: Int, b: Int, out: (Int, Int) -&gt; Unit) {  out(a, b)}fun retFunc() {  println( start of retFunc )  inlineLambda(13, 3) { a, b -&gt;     val result = a + b    if(result &gt; 10) return // retFunc자체가 return    println( result: $result )  }  println( end of retFunc ) // 10 을 초과하면 해당 println도 실행되지 않는다. }람다식 함수 내에서만 return이 이루어 질 수 있도록 해보자. 람다식에서 라벨 사용(물론 inline함수에서도 사용 가능하다) 람다식 함수명 라벨이름@ {  …  return@라벨이름} 1234567891011121314151617fun main() {  retFunc()}fun lambda(a: Int, b: Int, out: (Int, Int) -&gt; Unit) {  out(a, b)}fun retFunc() {  println( start of retFunc )  lambda(13, 3) lit@{ a, b -&gt;     val result = a + b    if(result &gt; 10) return@lit //람다식 내부에서 return이 실행됨. (지역 반환)    println( result: $result )  }  println( end of retFunc ) // result가 10이 넘더라도 해당 구문 실행됨. }암묵적 라벨라벨에 이름을 붙여주는 대신 함수이름을 사용할 수 있다. 1234567891011121314151617fun main() {  retFunc()}fun lambda(a: Int, b: Int, out: (Int, Int) -&gt; Unit) {  out(a, b)}fun retFunc() {  println( start of retFunc )  lambda(13, 3) { a, b -&gt;     val result = a + b    if(result &gt; 10) return@lambda //람다식 내부에서 return이 실행됨. (지역 반환)    println( result: $result )  }  println( end of retFunc ) // result가 10이 넘더라도 해당 구문 실행됨. }사실 익명 함수를 사용해서 해결할 수 있다. 123456789fun retFunc() {  println( start of retFunc )  lambda(13, 3, fun (a, b) {     val result = a + b    if(result &gt; 10) return    println( result: $result )  })  println( end of retFunc ) // result가 10이 넘더라도 해당 구문 실행됨. }익명 함수를 사용하게 되면 코딩의 직관성이 떨어져서, 주의해서 사용하자. 람다식과 익명 함수 비교 123456val getmessage = lambda@ { num: Int -&gt;  if(num !in 1. . 100) {    return@lambda  Error   }   Sucess // 마지막 식이 반환}12345678val getmessage = fun(num: Int): String {  if(num !in 1. . 100) {    return  Error   }  return  Sucess }val result = getMessage(99)break &amp; continue with label: 1234567891011fun labelBreak() {  first@ println( labelBreak )  for(i in 1. . 5) {    second@ for (j in 1. . 5) {      if (j == 3) break // @second에서 break.       println( i: $i, j:$j )    }    println( after for j )  }  println( after for i )}1234567891011fun labelBreak() {  first@ println( labelBreak )  for(i in 1. . 5) {    second@ for (j in 1. . 5) {      if (j == 3) break@first // @first에서 break. !!      println( i: $i, j:$j )    }    println( after for j )  }  println( after for i )}continue도 동일하다! "
    }, {
    "id": 188,
    "url": "/study_Kotlin_10/",
    "title": "Kotlin 함수편 - [10]",
    "body": "2020/08/04 - run(): run() 함수는 두 가지 형태이다.  public inline fun &lt;R&gt; run(block: () -&gt; R):R = return block() public inline fun &lt;T, R&gt; T. run(block: T. () -&gt; R):R = return block()123456789var skills =  Kotlin println(skills) // Kotlinval a = 10skills = run {  val level =  Kotlin Level:  + a  level //마지막 표현식이 반환됨}println(skills) // Kotlin Level: 10apply 와 run 비교 123456789101112131415161718192021fun main() {  data class Person(var name: String, var skills: String)  var person = Person( Kildong ,  Kotlin )  val returnObj = person. apply {    this. name =  Sean     skills =  java      success  //사용되지 않는다.   }  println(person)  println( returnObj: $returnObj ) // person  val returnObj2 = person. run {    this. name =  Dooly     this. skills =  C#      success   }    println(person)  println( returnObj2: $returnObj2 ) // success}with(): run()함수와 기능이 거의 동일한데, with()에서는 receiver로 전달할 객체를 처리한다. public inline fun &lt;T, R&gt; with(receiver: T, block: T. () -&gt; R): R = receiver. block() with는 세이프 콜(?. )을 지원하지 않기 떄문에 let과 같이 사용된다. 123456supportActionBar?. let {  with(it) {    setDisplayHomeAsUpEnabled(true)    setHomeAsUpIndicator(R. drawable. ic_clear_white)  }}아래와 동일하다. 1234supportActionBar?. run {  setDisplayHomeAsUpEnabled(true)  setHomeAsUpIndicator(R. drawable. ic_clear_white)}123456789101112fun main() {  data class User(var name: String, var skills: String, var email: String? = null)  var user = User( Kildong ,  default )  val result = with (user) {    this. skills =  Kotlin     email =  kildong@example. com   }  println(user) // User  println( result: $result ) // result: kotlin. Unit (Unit을 반환한다. )}use(): use()를 사용하면 객체를 사용한 후 close() 등을 자동적으로 호출해 닫아준다. public inline fun &lt;T : Closeable?, R&gt; T. use(block: (T) -&gt; R) : R Or public inline fun &lt;T : AutoCloseable?, R&gt; T. use(block: (T) -&gt; R) : R  T의 제한된 자료형을 보면 Closeable?로 block은 닫힐 수 있는 객체를 지정해야 함 Java 7 이후는 AutoCloseable?로 사용됨12345678910111213141516//기존 자바 코드private String readFirstLine() throws FileNotFoundException {  BufferedReader reader = new BufferedReader(new FileReader( test. file ));  try {    return reader. readLine();  } catch (IOException e) {    e. printStackTrace();  } finally {    try {      reader. close();    } catch (IOException e) {      e. printStackTrace();    }  }  return null;}123private fun readFirstLine(): String {  BufferedReader(FileReader( test. file )). use { return it. readLine() }}파일 닫기에 대한 처리 12345fun main() {  PrintWriter(FileOutputStream( . . . . . \output. txt )). use {    it. println( hello )  }}takeIf() &amp; takeUnless():  takeIf(): 람다식이 true이면 객체 T를 반환하고 그렇지 않으면 null 반환 take Unless(): 람다식이 false이면 객체 T를 반환하고 그렇지 않으면 null 반환public inline fun &lt;T&gt; T. takeIf(predicate: (T) -&gt; Boolean): T? = if (predicate(this)) this else null 12345678910// 기존 코드if (someObject != null &amp;&amp; someObject. status) {  doThis()}// safe call 사용if (someObject?. status == true) {  doThis()}// takeIf 사용someObject?. takeIf { it. status }?. apply { doThis() }elvis 연산자와 함께 사용 예제 1234567val input =  kotlin val keyword =  in // 입력 문자열에 키워드가 있으면 인덱스를 반환하는 함수를 takeIf를 사용하여 구현input. indexOf(keyword). takeIf { it &gt;= 0 } ?: error( keyword not found )// takeUnless 사용input. indexOf(keyword). takeUnless { it &lt; 0 } ?: error( keyword not found )시간 측정 하기:  measureTimeMillis() &amp; measureNanoTime()1234567891011public inline fun measureTimeMillis(block: () -&gt; Unit): Long {  val start = System. currentTimeMillis()  block()  return System. currentTimeMillis() - start}public inline fun measureNanoTime(block: () -&gt; Unit): Long {  val start = System. nanoTime()  block()  return System. nanoTime() - start}사용 예 1234val executionTime = measureTimeMillis {  // 측정할 작업 코드}printnl( Execution Time = $executionTime ms )난수 생성: 자바의 java. util. Random을 이용할 수도 있지만, JVM에만 특화된 난수를 생성한다. 때문에 코틀린에서는 멀티플랫폼에서도 사용 가능한 kotlin. random. Random을 제공한다. 1234import kotlin. random. Random. . . val number = Random. nextInt(21) // 숫자는 난수 발생 범위println(number)"
    }, {
    "id": 189,
    "url": "/study_Kotlin_6/",
    "title": "Kotlin 함수편 - [6]",
    "body": "2020/08/01 - if~else 문의 간략화: 12345var max: Intif (a &gt; b)   max = aelse   max = b1var max = if (a &gt; b) a else b블록과 함께 사용할 경우 1234567891011121314fun main() {  val a = 12  val b = 7  val max = if (a &gt; b) {    println( a 선택 )    a // 블럭의 마지막 식이 반환되어 max에 할당.   }  else {    println( b 선택 )    b // 블럭의 마지막 식이 반환되어 max에 할당.   }  println(max)readLine()콘솔로부터 입력 받는 함수: 1val score = readLine()!!. toDouble() // readLine은 Null이 될수도 있으므로 Null값 처리를 해줘야 한다. 여기선 잠깐 테스트를 위한 것이라 !!로 처리. 범위 연산자: 변수명 in 시작값. . 마지막값 1if(score in 80. . 89) // score가 80~89 사이에 있는 값인지 확인(마지막 값은 포함!)when문(switch … case과 비슷): 범위 연산자, is 키워드 사용 가능. 1234567891011121314151617when(x) {  1 -&gt; print( x == 1 ) //break 필요없이 빠져나온다.   2 -&gt; print( x == 2 )  3, 4 -&gt; print( x == 3, 4 ) //일치되는 여러 조건 사용 가능  parseInt(s) -&gt; print( 일치함! ) // 함수의 반환값 사용 가능  in 10. . 20 -&gt; print( x는 10이상 20이하입니다.  ) //범위 연산자 사용 가능  !in 10. . 20 -&gt; print( x는 10이상 20이하의 범위에 포함되지 않습니다.  )  else -&gt; { // 블록 구문 사용 가능.     print( else )  }}val str =  안녕하세요.  val result = when(str) {  is String -&gt;  문자열입니다.    else -&gt; false}인자가 없는 when 123456when {  score &lt;= 90. 0 -&gt; grade = 'A'  score in 80. 0. . 89. 9 -&gt; grade = 'B'  score in 70. 0. . 79. 9 -&gt; grade = 'C'  score &lt; 70. 0 -&gt; grade = 'F'}"
    }, {
    "id": 190,
    "url": "/study_Kotlin_5/",
    "title": "Kotlin 함수편 - [5]",
    "body": "2020/07/31 - 익명 함수: 1fun (x: Int, y; Int): Int = x + y // 함수의 이름이 생략되어 있다. 12val add: (Int, Int) -&gt; Int = fun(x, y) = x + yval result = add(10, 2) // 임시적으로 function이 필요할 경우 저런식으로 사용한다. 1val add = fun(x: int, y: Int) = x + y // 아래의 람다식과 매우 흡사하다. 그러나 return, break, continue는 람다식에서 사용불가능 하지만 일반 익명 함수에서는 사용이 가능하다. 1val add = {x: Int, y: Int -&gt; x + y } 인라인 함수: 함수가 호출되는 곳에 내용을 모두 복사함수의 분기 없이 처리 -&gt; 성능 증가 그러나 인라인 되는 함수의 코드가 많아질수록 복사된 전체 코드량이 증가하게 되므로 오히려 성능이 줄어들게 된다. 성능 향상 측면에서 람다식 함수에 사용될 것을 권장하고 있다. 123456789inline fun shortFunc(a: Int, out: (Int) -&gt; Unit) {  println( Hello )  out(a)}fun main() {  shortFunc(3) {    println( a: $it )  }}noinline일부 람다식 함수를 인라인 되지 않게 하기 위함. 123inline fun sub(out1: () -&gt; Unit, noinline out2 () -&gt; Unit) {  . . . }crossinline 1234567891011inline fun shortFunc(a: Int, out: (Int) -&gt; Unit) {  println( Hello )  out(a)  println( Goodbye )}fun main() {  shortFunc(3) {    println( a: $it )    return // return에 의해 Goodbye가 실행되지 않는다.   }}crossinline을 사용하므로써 비지역반환을 금지하게 한다. 1234567891011inline fun shortFunc(a: Int, crossinline out: (Int) -&gt; Unit) {  println( Hello )  out(a)  println( Goodbye )}fun main() {  shortFunc(3) {    println( a: $it )    //return 사용시 error  }}확장 함수(extension function): 클래스의 멤버 함수를 외부에서 더 추가할 수 있다. 적절히 사용하면 유용하지만 남발하면 호환성이 떨어지게 된다. fun 확장대상. 함수명(매개변수, …): 반환값 {  …  return 값} 12345678fun main() {  val source =  Hello World!   var target =  Kotlin   println(source. getLongString(target))}fun String. getLongString(target: String): String =   if (this. length &gt; target. length) this else target중위 표현법(infix notation): 클래스의 멤버 호출 시 사용하는 점(. )을 생략하고 함수 이름 뒤에 소괄호를 생략해 직관적인 이름을 사용할 수 있는 표현법 조건  멤버 메서드 또는 확장 함수여야 한다.  하나의 매개변수를 가져야 한다.  infix 키워드를 사용하여 정의한다. 123456789101112fun main() {  // 일반 표현법  // val multi = 3. multiply(10)    // 중위 표현법  val multi = 3 multiply 10  println( multi: $multi )}infix fun Int. multiply(x: Int): Int {   return this * x}꼬리 재귀 함수(tail recursive function): 스택에 계속 쌓이는 방식이 함수가 계속 씌워지는 꼬리를 무는 형태코틀린 고유의 tailrec 키워드를 사용해 선언 123456789101112//일반 재귀fun main() {  val number = 4  val result: Long  result = factorial(number)  println( Factorial: $number -&gt; $result )}fun factorial(n: Int): Long {  return if(n == 1) n. toLong() else n * factorial(n-1)}123456789//꼬리 재귀fun main() {  val number = 5    println( Factorial: $number -&gt; ${factorial(number)} )}tailrec fun factorial(n: Int, run: Int = 1): Long {  return if(n == 1) run. toLong() else factorial(n-1, run*n) //값을 꼬리물며 들어가기 때문에 스택을 사용하지 않는다. }"
    }, {
    "id": 191,
    "url": "/study_Kotlin_4/",
    "title": "Kotlin 함수편 - [4]",
    "body": "2020/07/31 - 코틀린은 다중 패러다임 언어:  함수형 프로그래밍(FP: Functional Programming) 객체 지향 프로그래밍(OOP: Object-Oriented Programming)함수형 프로그래밍:  코드 간략, 테스트나 재사용성 증가 람다식, 고차 함수를 사용해 구성 순수 함수순수 함수(pure function):  부작용(side-effect)이 없는 함수     동일한 입력 인자에 대해서는 항상 같은 결과를 출력 혹은 반환 한다.    값이 예측 가능해 결정적(deterministic)이다.    123 fun sum(a: Int, b: Int): Int {   return a + b //도일한 인자인 a, b를 입력 받아 항상 a + b를 출력(부작용이 없음) } 순수함수의 조건     같은 인자에 대하여 항상 같은 값을 반환   함수 외부의 어떤 상태도 바꾸지 않는다.     순수함수가 아닌 예  1234 fun check() {  val test = User. grade() // check() 함수에 없는 외부의 User 객체를 사용  if (test != null) process(test) // 변수 test는 User. grade()의 실행 결과에 따라 달라짐 }   123456789101112const val global = 10fun main() {  val num1 = 10  val num2 = 3  val result = noPureFunction(num1, num2)  println(result)}fun noPureFunction(a: Int, b: Int): Int {  return a + b + global // global 값이 바뀔 때 마다 return 값이 달라진다. no Pure} 순수 함수가 필요한 이유     입력과 내용을 분리하고 모듈화 하므로 재사용성이 높아진다.          여러가지 함수들과 조합해도 부작용이 없다.           특정 상태에 영향을 주지 않으므로 병행 작업 시 안전하다.    함수의 값을 추적하고 예측 할 수 있기 떄문에 테스트, 디버깅 등이 유리하다.     함수형 프로그래밍에 적용     함수를 매개변수, 인자에 혹은 반환값에 적용(고차 함수)   함수를 변수나 데이터 구조에 저장   유연성 증가   람다식: 람다식(Lambda Expression)이란?:  익명 함수의 하나의 형태로 이름 없이 사용 및 실행이 가능 람다 대수(Lambda calculus)로 부터 유래{ x, y -&gt; x + y } // 람다식의 예 (이름이 없는 함수 형태) 람다식의 이용:  람다식은 고차 함수에서 인자로 넘기거나 결과값으로 반환 등을 할 수 있다. 일급 객체: 일급 객체(First Class Citizen)란?:  일급 객체는 함수의 인자로 전단할 수 있다.  일급 객체는 함수의 반환값에 사용할 수 있다.  일급 객체는 변수에 담을 수 있다. 코틀린에서는 함수는 1급 객체로 다룬다. (1급 함수라고도 한다. ) 고차 함수: 고차 함수(high-order function)란?: 12345fun main() {  println(highFunc({ x, y -&gt; x + y}, 10, 20))}fun highFunc(sum: (Int, Int) -&gt; Int, a: Int, b: Int): Int = sum(a, b)// sum 매개변수는 함수차례로higntFunc =&gt; 고차함수sum =&gt; 람다식 매개변수(Int, Int) -&gt; Int =&gt; 자료형이 람다식으로 선언 되어 { x, y -&gt; x + y } 형태로 인자를 받는 것이 가능a: Int, b: Int) : Int =&gt; 매개 변수와 반환 자료형sum(a, b) =&gt; return 값. 람다식 표현문에 따라 a + b 아래와 같이 바꿀 수 있다. 12345fun main() {  val result = highFunc(1, 3, {x, y -&gt; x + y})}fun highFunc(a: Int, b: Int, sum: (Int, Int) -&gt; Int): Int = sum(a, b)// sum 매개변수는 함수1234567fun main() {  val result = highFunc(1, 3) {x, y -&gt;     x + y  }}fun highFunc(a: Int, b: Int, sum: (Int, Int) -&gt; Int): Int = sum(a, b)// sum 매개변수는 함수 자바스크립트 함수형!?람다의 parameter가 하나인 경우 컴파일러가 추론이 가능하여 해당 값을 it으로 사용이 가능하다. 123456fun more(out: (String) -&gt; String): Unit {  println(out( Hello ))}fun main() {  more{ $it Kotlin } //Hello Kotlin}람다식으로 변수 선언 또한 가능하다. 이때. 선언된 변수는 함수처럼 사용이 가능하다. 123456789val result: Intval multi = { a: Int, b: Int -&gt; a * b}/** 아래는 모두 동일한 표현 방법이다. val multi: (Int, Int) -&gt; Int = { a: Int, b: Int -&gt; a * b}val multi = { a: Int, b: Int -&gt; a * b}val multi: (Int, Int) -&gt; Int = { a, b -&gt; a * b} 물론 모두 생략하는 것은 추론이 가능하지 않아서 안된다. */result = multi(10, 20) //함수 처럼 사용이 가능하다. 표현식이 2줄 이상일 경우는 마지막 표현식이 반환된다. 123456val result: Intval multi: (Int, Int) -&gt; Int = { a, b -&gt;   println( a*b )  a * b // 만일 반환값이 Int로 설정 되어 있는데 a * b가 생략된다면 Error}result = multi(10, 20) //200반환 자료형이 없거나 매개변수가 하나 있을 경우 1234val greet: ()-&gt;Unit = { println( Hello World! ) } // 추론이 가능하므로 자료형 생략val square: (Int)-&gt;Int = { x -&gt; x * x } // 선언부 생략하고 싶다면 x의 자료형 명시val square = { x: Int -&gt; x * x } 람다식 안에 람다식 12val nestedLambda: ()-&gt;()-&gt;Unit = { { println( nested ) } } // 추론 가능하므로 생략 가능하다. val nestedLambda = { { println( nested ) } }고차함수 이용: 다음과 같은 예시를 살펴보자. 12345678910111213fun sum(a: Int, b: Int) = a + bfun mul(a: Int, b: Int): Int {  return a * b}fun funcFunc(a: Int, b: Int) = sum(a, b) // 함수를 returnfun main() {  val result = sum(10, 10)  val result2 = mul( sum(10, 5), 10) // 매개변수에 함수 사용  val result3 = funcFunc(2,3)}람다식을 이용 함수 호출: CallByValue 1234567891011121314fun main() {  val result = callByValue(lambda())  println(result)}fun callByValue(b: Bollean): Boolean {  println( callByValue function )  return b // b는 람다식함수의 결과값}val lambda: () -&gt; Boolean = {  println( lambda function )   true}순서: lambda 바로 실행 결과 값 반환, 반환된 결과값을 callByValue 매개변수에 복사, return. CallByName 1234567891011121314fun main() {  val result = callByName(otherLambda)  println(result)}fun callByName(b: () -&gt; Bollean): Boolean { //b는 람다식 함수  println( callByName function )  return b() // b는 람다식함수}val otherLambda: () -&gt; Boolean = {  println( lambda function )   true}순서: otherLambda가 callByName 매개변수에 복사, return에서 b()로 람다식 함수가 호출. 람다식 true return, callByname return. callByReference 12345678fun sum(x: Int, y: Int) = x + y//funcParam(3, 2, sum) =&gt; errorfun funcParam(a: Int, b: int, c: (Int, int) -&gt; Int): Int {  return c(a, b)}funcParam(3, 2, ::sum) //일반함수의 내용물이 참조하고자 하는 람다식과 완전히 일치하는 경우 사용 가능. 매개변수 개수에 따라 람다식 구성 방법: 매개변수 없는 경우 1234567fun main() {  // 매개변수 없는 람다식 함수  noParam( {  Hello World!  } )  noParam {  Hello World!  } //위와 동일한 결과. }fun noParam( out: () -&gt; String) = println(out())매개변수 한 개 12345678fun main() {  oneParam( { a -&gt;  Hello World! $a  } )  oneParam { a -&gt;  Hello World! $a  }   oneParam {  Hello World! $it  } // 매개변수가 하나 일 경우 $it을 사용함으로써 화살표 식을 줄일수 있다. 여러 개일 경우 사용 불가능  //전체 동일한 결과}fun oneParam( out: (String) -&gt; String) = println(out( OneParam ))매개변수 두 개 이상 12345fun main() {  moreParam{ a, b -&gt;  Hello World! $a $b  }}fun moreParam( out: (String, String) -&gt; String) = println(out( OneParam ,  TwoParam ))만일 앞선 매개변수를 사용하지 않을 예정이라 생략하고 싶다면, 언더바를 사용하면 된다. 123fun main() {  moreParam{ _, b -&gt;  Hello World! $b  }}일반 매개변수와 람다식 매개변수를 같이 사용 1234567891011121314151617fun main() {  withArgs( Arg1 ,  Arg2 , { a, b -&gt;  Hello World! $a $b } )  withArgs( Arg1 ,  Arg2 ) { a, b -&gt;  Hello World! $a $b }   //동일한 표현, 인자와 람다식을 분리해서 보게 할 수 있다. }fun withArgs(a: String, b: String, out: (String, String) -&gt; String) {  println(out(a, b))}/**람다식이 매개변수 중 앞에 위치할 경우 불가능. withArgs { a, b -&gt;  Hello World! $a $b } ( Arg1 ,  Arg2 ) fun withArgs(out: (String, String) -&gt; String, a: String, b: String) {  println(out(a, b))} 안됨!*/두 개 이상의 람다식을 가질 때 123456789fun main() {  twoLambda({ a, b -&gt;  First $a $b  }, { Second $it })  twoLambda({ a, b -&gt;  First $a $b  }) { Second $it } // 두 개 이상일 경우 마지막 람다식에 한에서 중괄호로 빼낼수 있다. }fun twoLambda(first: (String, String) -&gt; String, second: (String) -&gt; String) {  println(first( OneParam ,  TwoParam ))  println(second( OneParam ))}"
    }, {
    "id": 192,
    "url": "/study_Kotlin_3/",
    "title": "Kotlin 함수편 - [3]",
    "body": "2020/07/31 - 함수의 선언: 1234fun sum(a: Int, b: Int): Int { var sum = a + b return sum}fun 함수이름([변수 이름: 자료형, 변수 이름: 자료형. . ]) : [반환값의 자료형] { … [return 반환값]} 반환값이 없는 함수일 경우 반환값의 자료형으로 unit을 사용한다. 이 함수는 반환값이 없다는 unit값을 반환한다. (자바에서 void와 비슷하지만 void는 변환값이 전혀 없다. ) 그리고 Unit은 생략이 가능하다. 1234fun outName(name: String): Unit { println( Name: $name ) return Unit}123fun outName(name: String) { println( Name: $name )} 최상위 함수(Top-level): 소스코드 상위에 있는 함수. 어느 곳에서 선언하든 사용가능하다.  지역 함수 : 소스코드 내에 선언 된 함수. 해당 함수를 사용하기 전에는 무조건 선언되어야 한다. 간략화된 함수: 함수는 아래와 같이 간략화 하여 사용할 수 있다. 1fun sum(a: Int, b: Int): Int = a + b 이때 반환값이 추론이 가능할 경우 반환값의 자료형은 생략 가능하다. (간략화 하지 않을 경우는 불가능) 1fun sum(a: Int, b: Int) = a + b 1fun outName(name: String) = println( Name: $name )Default 매개변수: 매개변수에 Default 값을 설정할 수 있다. 매개변수 중 특정 매개변수 만 값을 설정할 경우 함수의 매개변수에 값을 직접 넣는다. 12fun sum(a: Int, b: Int = 5): Int = a + b println(sum(2)) // 712fun sum(a: Int = 2, b: Int = 5): Int = a + b println(sum(b=2)) // 4가변변수: 매개변수가 가변적일 경우 동일한 자료형에 대해 vararg를 이용하여 사용이 가능하다. 1234567891011fun normalVarargs(vararg a: Int) {  for (num in a) {    print( $num  )  }}fun main() {  normalVarargs(1) // 1  println()  normalVarargs(1, 2, 3, 4, 5) // 1 2 3 4}"
    }, {
    "id": 193,
    "url": "/study_Kotlin_2/",
    "title": "Kotlin 함수편 - [2]",
    "body": "2020/07/31 - 자료형 변환:  변환 메서드 사용12var a: Int = 1var b: Double = a. toDouble() 표현식에서 자동 변환1var result = 1L + 3// Long + Int =&gt; result: Long이중 등호와 삼중 등호: 12345var a: Int = 128var b: Int = 128println(a == b) // trueprintln(a === b) // false12345var a: Int = 128var b: Int? = 128println(a == b) // trueprintln(a === b) // false12345var a: Int = 128var b: Int? = 128println(a == b) // trueprintln(a === b) // false1234567891011var a: Int = 128var c: Int? = avar d: Int? = avar e: Int? = cprintln(c == d) // trueprintln(c === d) // false println(c == e) // trueprintln(c === e) // true스마트 캐스드 Number: Number로 선언함으로써 Int, Long, Float 등 숫자 자료형을 자동으로 변환해준다. 1234var a: Number = 12. 2a = 12a = 120La += 12. 0f스마트 캐스트 Any: 자료형이 정해지지 않는 경우 사용. 언제든 필요한 자료형으로 자동 변환 1234var a: Any = 1a =  Hello a = 120Lprintln( a: $a type: ${a. javaClass} ) // a: 120 type: longis 키워드: 1234567var num = 256if (num is Int) { print(num) } else if(num !is Int) { // !(num is Int)와 동일 print( Not a Int )}비트 연산을 위한 비트 매서드:       표현식   설명         4. shl(bits)   4를 표현하는 비트를 bits만큼 왼쪽으로 이동(부호 있음)       7. shr(bits)   7를 표현하는 비트를 bits만큼 오른쪽으로 이동(부호 있음)       12. ushr(bits)   12를 표현하는 비트를 bits만큼 오른쪽으로 이동(부호 없음)       9. and(bits)   9를 표현하는 비트를 bits를 표현하는 비트로 논리곱 연산       4. or(bits)   4를 표현하는 비트를 bits를 표현하는 비트로 논리곱 연산       24. xor(bits)   24를 표현하는 비트를 bits를 표현하는 비트로 배타적 연산       78. inv( )   78를 표현하는 비트를 모두 뒤집음   "
    }, {
    "id": 194,
    "url": "/study_Kotlin_1/",
    "title": "Kotlin 함수편 - [1]",
    "body": "2020/07/30 - 변수: val(value) - 불변형 (immutable) var(variable) - 가변형 (mutable) val username(: String - 컴파일에서 추론 가능할 경우 생략 가능) = “Eon” 따라서 단순 선언 같은 경우 추론이 불가능하므로 생략 불가 자료형: 기본형(primitive data type):  보통 코틀린에서는 사용하지 않으나 자바에서 사용하므로 알아두자 int, long, float, double참조형(reference type):  동적 공간에 데이터를 둔 다음 이것을 참조하는 자료형 Int, Long, Float, Double자료형 추론: 123 =&gt; Int123L =&gt; Long (접미사 L)123F =&gt; Float (접미사 F)0x0F =&gt; 16진수 Int (접두사 0x)0b00001011 =&gt; 2진수 Int (접두사 0b) 작은 값을 사용하고자 하면 자료형을 명시적으로 지정해주자. 숫자 자료형을 경우 사이에 언더바는 아무런 영향을 주지 않는다. 그냥 자릿수 확인으로 사용 가능 큰수일 경우 3. 14E + 16 이런식으로 사용 코틀린에서는 부동 소수점을 표현할 때, 지수부와 가수부로 나뉘어 저장된다. 이러한 부동 소수점에 대해 연산을 하게 될 경우 공간 제약으로 인해 정확한 값을 return하지 않는다. 유념해서 설계하자. 123456789fun main() { var num: Double = 0. 1 for(x in 0. . . 999) {  num += 0. 1 } println(num) //100. 09999. . . }문자열 자료형: 문자열은 String으로 선언되며 String Pool 이라는 공간에 구성된다. 이때 참조형 변수이기 때문에, 변수를 선언할 경우 Heap에 값은 String Pool 저장되게 되며 이 값은 변경되지 않는다. 즉, 만일 값이 같은 변수를 선언할 경우 똑같은 참조이게 된다. 코틀린에서 [== : 값만 비교] === : 값과 참조 주소 비교 12345678fun main() { var str1: String =  Hello  var str2 =  World  var str3 =  Hello   println( str1 === str2: ${str1 === str2} ) // false println( str1 === str3: ${str1 === str3} ) // true}표현식에서 문자열: 1234567fun main() { var a = 1 var str1 =  a = $a  var str2 =  a = ${a +2}   println( str1: \ $str1\ , str2: \ $str2\  ) //  를 print하고 싶다면 [\ ] 이렇게 쓰면 된다. }nullable: 코틀린에서는 기본적으로 null을 허용하지 않는다. (프로그램이 NPE에서 자유롭게 구동하려는 의도로 이해하고 있다. ) 그러나 상황에 따라 null이 필요하게 될 경우 자료형에 물음표를 붙임으로써 사용이 가능하다. 그리고 코틀린에서는 nullable 변수를 사용하더라도, 사용할 때 NPE에서 자유롭도록 코딩을 유도한다. 주의할 점은 자료형 과 자료형? 은 다른 Type이다. 1234fun main() { var str1: String println( str1 ) // error null을 허용하지 않는다. }12345fun main() { var str1: String str1 = null println( str1 ) // error null을 허용하지 않는다. }12345fun main() { var str1: String? str1 = null println( str1 ) // return : null}12345fun main() { var str1: String? str1 = null println( str1: $str1, length: ${str1. length ) // error null값의 길이를 참조할 수 있게 된다. }이때 추가적으로 코딩을 하지 않고 해결할 수 있는 방법은 2가지 이다.  세이프콜(?. )을 사용한다.  혹시라도 Null일 경우 ?. 의 뒷부분을 실행하지 않도록 해준다. 12345fun main() { var str1: String? str1 = null println( str1: $str1, length: ${str1?. length ) // error null값의 길이를 참조할 수 있게 된다. } NonNull 단정 기호(!!. )를 사용한다. Null이 아닐것임을 단정해서 컴파일러가 오류를 무시하고 넘어간다. 되도록이면 사용하지 말자. 12345fun main() { var str1: String? str1 = null println( str1: $str1, length: ${str1!!. length ) // NPE 발생. . }물론 if문을 통해 걸러주는 방법을 사용해도 된다. 123456fun main() { var str1: String? str1 =  Hello  var len = if (str1 != null) str. length else -1 println( str1: $str1, length: $len )}?: - elvis 연산자: Null 값을 혀용하지 않는 변수에 Null 값이 들어올때, Null 값 대신 다른 값을 반환토록 해준다. 123456fun main() { var str1: String? str1 =  Hello  var len = str1?. length ?: -1 println( str1: $str1, length: $len )}또한 함수형으로 이렇게도 표현이 가능하다. 123456fun main() { var str1: String? str1 =  Hello  var len = if (str1 != null) str1. length else -1 println( str1: $str1, length: $len )}"
    }, {
    "id": 195,
    "url": "/study_aboutintellij/",
    "title": "IntelliJ",
    "body": "2020/07/29 - font : D2coding(네이버 제공)ctrl + Mouse : font 크기 조절 활성화 도구 창의 단축키 : 윈도우(맥):  Messages Alt + 0 (Cmd + 0) Project Alt + 1 (Cmd + 1) Favorites  Alt + 2 (Cmd + 2) Run Alt + 4 (Cmd + 4) Debug  Alt + 5 (Cmd + 5) TODO Alt + 6 (Cmd + 6) Structure  Alt + 7 (Cmd + 7)   Terminal Alt + F12 (Option + F12)   자동 줄 복사 Ctrl + D 실행 Ctrl + Shift + F10 새 파일 생성 Alt + Insert 추론 타입 확인 : Ctrl + Shift + P함수의 console Library 확인: 함수위에서 Ctrl + B * 2 =&gt; 자바 라이브러리 java로 변환: Tools -&gt; Kotlin -&gt; Show Kotlin Bytecode 매뉴에서 Decomplie 클릭. 인자를 받는 main문에 인자 넣기: 우측 상단에 Run 좌측 배너를 클릭하여 Edit Configuration 클릭 Program Argument가 넣을 인자. "
    }, {
    "id": 196,
    "url": "/study_Kotlin_start/",
    "title": "Kotlin 시작",
    "body": "2020/07/29 - 코틀린을 배워보자. : 코틀린이란 언어에 대해 알아보게 되어서야 현재 java의 status를 알수 있었다. 단순히 학업의 목적으로 java를 이해하고 있었을 적엔 jdk에 대하여 별다른 신경을 쓰지 않았으나, 공부를 좀 더 해가면서 jdk이는 더 이상 무료가 아니게 되었으며, 이에 대한 나비효과로 kotlin은 더욱 각광을 받고 있음을 알게 되었다. 개인적으로 앱개발에 대해 호기심을 가지고 있었으며, 함수형 프로그래밍이 가능함과 동시에 레거시 java 프로그램들도 전체 커버가 가능하다는 장점이 현재 코틀린을 배우려는 생각을 갖게 하는데 결정적이었다. 부스트코스 코틀린 프로그래밍: 이런 생각을 가질즈음 부스트 코스에서도 코틀린 프로그래밍 강의가 새로 열렸다. 단순히 언어를 배우는데 끝나는 것이 아닌 3단계로 나뉘어서 함수형 - 객체지향형 - 응용(앱 만들기) 강의가 진행하고 있다. 해당 강의에서는 azul에서 제공하는 zulu builds of openJDK를 사용하고, 개발 환경으로는 Intellij를 사용한다. 모두 처음해보는 생소한 것이나, 이클립스와 비교를 해보는 등의 재미가 있을것으로 생각 되어 즐거운 마음으로 진행하고자 한다. 이후 코틀린에 대해 공부하며, 기억해야 할 것들을 정리해서 포스팅 할 예정이다. 모두 배우고 나면 코틀린으로 알고리즘 문제를 풀수 있기를 희망한다. "
    }, {
    "id": 197,
    "url": "/web_malgeon_blog/",
    "title": "Malg:eon Blog",
    "body": "2020/07/27 - "
    }, {
    "id": 198,
    "url": "/study_FE_Syn&ASyn/",
    "title": "웹 : 동기 그리고 비동기",
    "body": "2020/07/11 - 싱글 스레드갑자기 싱글 스레드? 동기, 비동기라며!?: 프로그래밍 입문을 C, 자바로 해온 나는 자바스크립트를 배우는 지금 자바스크립트에 대한 첫 인상은 forEach에 대한 의아함 이었다. for 문이 잘 돌아가는데 굳이. . ? 최근 동기, 비동기 이슈에 대한 공부를 한 후 해당 의아함을 어느정도 풀 수 있었다. 웹에서 버튼을 눌렀는데, 웹이 멈췄다. 그래서 버튼을 여러번 눌렀다. 답답한 시간이 지나고 난 뒤 버튼이 동작한다. 근데 여러번 동작한다. 그러면 안된다.  답답하니까… 사실 이 문제는 여러 프로그램을 동작시키는 운영체제를 보면 금세 해결할수 있다. 즉 멀티스레드를 통해서 말이다. 그런데 자바스크립트는 싱글 스레드 기반 언어이다. 그렇다면 문제를 해결 할수 없는 것일까? 콜백, 동기 비동기: 아니다. 현재 웹 전체가 멈추는 현상에 대한 기억 없이 잘 쓰고 있는 걸 보면 말이다. 아마도 위의 문제를 해결하기 위해 콜백함수와 비동기식 개발이 나온것 으로 이해했다. 그러고나니 처음 forEach에 대한 의아함은 해결 되었다. 비동기그래서 비동기식 개발이란게 무엇일까? 함수를 만들고 동작 대한 해당 정보를 어떤 곳에 보내버린다. 그리고 하나의 콜스택을 가지고 있는 자바스크립트에서 해당 함수는 보냄으로써 동작을 다 했기 때문에 콜스택에서 사라진다. 보내진 어떤 곳에서 처리를 한 후 다시 자바스크립트에 보낸다. 자바스크립트는 콜백 큐에 해당 정보를 받아서 콜 스택이 비워져 있을 떄(!) event loop는 콜스택에 보낸다. 위의 일련의 과정이 비동식이라 한다. 여기서 끝나지 않는다. 사실 브라우저는 개발된 자바스크립트를 가지고 렌더링을 해야 하는데, 이 repaint 하는 동작 또한 콜백 큐와 같이 동작 한다. 콜 스택이 비워져 있을 때(!) repaint 하는 것이다. 결론위와 같은 내용을 숙지하여 웹 개발을 진행하며 UI를 만들 때, event loop를 막아 버려서 브라우저가 할일을 못하게 되지 않도록, 유동적인 UI를 만들어 보자. "
    }, {
    "id": 199,
    "url": "/study_FE_slide/",
    "title": "슬라이드 효과",
    "body": "2020/07/10 - 이미지 슬라이드FE를 구성하다보면 가장 대표적으로 필요한 기능이 바로 슬라이드다. 버튼식 슬라이드, 무한 슬라이드 등등. 찾아보니 역시 방법은 천차만별이어서 공부한 바를 작성해 둔다. width : Calc(): 사용하고자 할 자식노드들의(이미지) width를 모두 25%로 맞춘다음 해당 부모노드에서 width를 4배한 값 calc(400%)으로 맞추면 이미지들은 100%가 되게 된다. 이때 margin-left를 -100 * n % 순서대로 바꾸게 되면 각 이미지들을 가리키게 된다. 아주 간편하다. 기준점이 설정되어 있기 때문에 한번은 초기화를 해줘야 한다. translate3d() 이용: width :Calc와 같은 매커니즘이다. transform의 translate3d(x축, y축, z축) 에서 조절하고 싶은 축을 조절하면 된다. "
    }, {
    "id": 200,
    "url": "/study_FE_FadeOut/",
    "title": "Fade Out",
    "body": "2020/07/09 - 사라지기단순히 hover시 사라지는 것보다, className 변경에 따른 fade out 효과를 공부해 보자. CSS에서 제공한다. : 123456-webkit-transition: opacity 3s ease-in-out;-moz-transition: opacity 3s ease-in-out;-ms-transition: opacity 3s ease-in-out;-o-transition: opacity 3s ease-in-out;opacity: 0;"
    }, {
    "id": 201,
    "url": "/study_FE_CORS&JSONP/",
    "title": "CORS와 JSONP",
    "body": "2020/07/08 - JSON연습 프로젝트 작업 중 다음과 같은 경고문을 보았다. Access to XMLHttpRequest at 'http://#' from origin 'http://@' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource. CORS 정책에 block 되었다는 건데, #의 도메인에서 XMLHttpRequest로 @도메인에 접근을 하게되면 보안상의 이유로 접근을 못하게 된다. Rest한 API을 만드는 작업 중 url에서 Json 파싱을 가능하게 하는 작업이 있다. 이때 해당 url은 database 객체 자료이기 때문에, 누구나 url을 요청하게 되면 해당 database를 public으로 이용하는 것이나 다름없게 된다. 이 같은 이유가 아마도 보안상의 이유라고 생각한다. 내 경우는 파일 Http에서 작업하면서 XMLHttpRequest를 로컬 서버에 요청을 하다 보니 block 된 것이다. 물론 로컬 서버에서 작업을 해도 되지만, 여러가지 이유로 도메인간 접근을 가능하게 해야할 경우가 많다. 때문에 당연히 알아야 할 내용이므로 공부하기로 한다. 그렇다면 도메인간 XMLHttpRequest를 사용하려면 어떻게 해야 할까. // 공부하다보니 너무 어려워서 일단 보류 CORS경고문에서 설명하 듯 block 하는 CORS 정책을 해제해주는 방법이 존재한다. 우선, 단순히 서버에서 CORS 정책을 해제하는 것으로 이해하고, 프레임워크에서 도와주는 것이 존재한다. 정도로 넘어가자. ## @CrossOrigin Spring에서는 @RequestMapping 위에 @CrossOrigin(origins = “도메인 주소, 도메인 주소 … “) 로 사용하여 도와준다. JSONPjson 값을 js를 통해 주고 받게 만드는 방법이다. 우회의 일종이랄까. "
    }, {
    "id": 202,
    "url": "/study_FE_Cookie&Session/",
    "title": "쿠키와 세션",
    "body": "2020/07/07 - 쿠키와 세션Http는 한번 연결하고 나면 끊어진다. 그러나 웹동작에서 상태유지는 필수적인데 이를 위해 쿠키와 세션이 존재한다. 쿠키 : 사용자 컴퓨터에 저장(정보 유출 우려) 세션 : 서버에 저장 "
    }, {
    "id": 203,
    "url": "/study_Programming_Stack,Queue.Tree/",
    "title": "Queue, Stack, Tree",
    "body": "2020/07/06 - 큐, 스택, 트리자바스크립트로 Queue, Stack, Tree를 구현해보자. ## 큐 (Queue)  큐(queue)는 다음과 같은 성질을 갖는 자료형입니다. 123데이터를 집어넣을 수 있는 선형(linear) 자료형입니다. 먼저 집어넣은 데이터가 먼저 나옵니다. 이 특징을 줄여서 FIFO(First In First Out)라고 부릅니다. 데이터를 집어넣는 enqueue, 데이터를 추출하는 dequeue 등의 작업을 할 수 있습니다. 1234567891011121314151617class Queue { constructor() {  this. _arr = []; } enqueue(item) {  this. _arr. push(item); } dequeue() {  return this. _arr. shift(); }}const queue = new Queue();queue. enqueue(1);queue. enqueue(2);queue. enqueue(3);queue. dequeue(); // 1## 스택 (Stack)  스택(stack) 다음과 같은 성질을 갖는 자료형입니다. 123데이터를 집어넣을 수 있는 선형(linear) 자료형입니다. 나중에 집어넣은 데이터가 먼저 나옵니다. 이 특징을 줄여서 LIFO(Last In First Out)라고 부릅니다. 데이터를 집어넣는 push, 데이터를 추출하는 pop, 맨 나중에 집어넣은 데이터를 확인하는 peek 등의 작업을 할 수 있습니다. 1234567891011121314151617181920class Stack { constructor() {  this. _arr = []; } push(item) {  this. _arr. push(item); } pop() {  return this. _arr. pop(); } peek() {  return this. _arr[this. _arr. length - 1]; }}const stack = new Stack();stack. push(1);stack. push(2);stack. push(3);stack. pop(); // 3## 트리 (Tree) 12345678910111213트리(tree)는 여러 데이터가 계층 구조 안에서 서로 연결된 형태를 나타낼 때 사용됩니다. 트리를 다룰 때 사용되는 몇 가지 용어를 살펴보겠습니다. 노드(node) - 트리 안에 들어있는 각 항목을 말합니다. 자식 노드(child node) - 노드는 여러 자식 노드를 가질 수 있습니다. 부모 노드(parent node) - 노드 A가 노드 B를 자식으로 갖고 있다면, 노드 A를 노드 B의 '부모 노드'라고 부릅니다. 뿌리 노드(root node) - 트리의 가장 상층부에 있는 노드를 말합니다. 잎 노드(leaf node) - 자식 노드가 없는 노드를 말합니다. 조상 노드(ancestor node) - 노드 A의 자식을 따라 내려갔을 때 노드 B에 도달할 수 있다면, 노드 A를 노드 B의 조상 노드라고 부릅니다. 자손 노드(descendant node) - 노드 A가 노드 B의 조상 노드일 때, 노드 B를 노드 A의 자손 노드라고 부릅니다. 형제 노드(sibling node) - 같은 부모 노드를 갖는 다른 노드를 보고 형제 노드라고 부릅니다. 123456789101112131415161718192021222324class Node { constructor(content, children = []) {  this. content = content;  this. children = children; }}const tree = new Node('hello', [ new Node('world'), new Node('and'), new Node('fun', [  new Node('javascript!') ])]);function traverse(node) { console. log(node. content); for (let child of node. children) {  traverse(child); }}traverse(tree);// hello world and fun javascript!"
    }, {
    "id": 204,
    "url": "/study_CODE_stack_1/",
    "title": "스택 : 크레인 인형뽑기 게임",
    "body": "2020/07/05 - category: 2019 카카오 개발자 겨울 인턴십 문제 설명게임개발자인 죠르디는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.  죠르디는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다. 게임 화면은 1 x 1 크기의 칸들로 이루어진 N x N 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 5 x 5 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 1 x 1 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 !!바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. 게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.  제한사항     board 배열은 2차원 배열로 크기는 5 x 5 이상 30 x 30 이하입니다.    board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.    0은 빈 칸을 나타냅니다.    1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.    moves 배열의 크기는 1 이상 1,000 이하입니다.    moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.    문제풀이단순 스택문제 풀이이다. 이걸 자바로 풀 생각해보니 스택 imort하고, 선언하고. . 어휴 상상만으로 머리가 아프다. 이래서 파이썬 자바스크립트 하는듯 하다.  자바스크립트는 push &amp; pop을 기본 지원하지만 peek은 지원하지 않아서 Stack을 함수로 만들어줘야하는것 같다. 1234567891011121314151617181920212223242526272829303132333435function solution(board, moves) {  var answer = 0;  const stack = new Stack();  moves. forEach( idx =&gt; {    var target = board. find(_ =&gt; _[idx-1]);    if (!(target === undefined)) {      var moveItem = target. splice(idx-1, 1, 0);      if (stack. peek() === moveItem[0]) {        stack. pop();        answer++;      } else {        stack. push(moveItem[0]);      }    }    })  return answer*2;}class Stack {  constructor() {    this. _arr = [];  }  push(item) {    this. _arr. push(item);  }  pop() {    return this. _arr. pop();  }  peek() {    return this. _arr[this. _arr. length -1];  }}더 좋은 풀이역시 단순한 문제여도 좋은 테크닉은 계속 나오는 것 같다… (물론 아주 작은 차이라고 생각은 되지만 그 차이가 쌓이면 큰 차이가 되겠지. ) 앞서 한 말 취소. .  기존 문제 풀이 같은 경우. moves에서 나온 idx를 기준으로 row별 Serch하여 0이 아닌값을 찾으며 해당 값을 없애는 방식으로 사용했다. 그러면 undefined이 나올 때까지 매번 find를 해야 하는 반복 이슈를 해결하기 위해 0이 아닌값을 찾아 아예 스택(peek이 필요없는)에 쌓아둔다.  그러면 moves에서 나온 idx에 해당하는 stack row를 pop만 해주면 되는 것 아닌가! 테크닉 : matric의 row를 colunm으로 전체 전환-&gt; 전환 row의 0값을 없애주고 순서 보정(반대 정렬) -&gt; 사용 12345678910111213141516171819202122232425262728293031323334353637383940414243444546const transpose = (matrix) =&gt; matrix. reduce( (result, row) =&gt; row. map((_, i) =&gt; [. . . (result[i] || []), row[i]]), []);function solution(board, moves) {  var answer = 0;  const boardStacks = transpose(board). map(row =&gt;    row. reverse(). filter(el =&gt; el !== 0)  );  debugger;  const stack = new Stack();  moves. forEach( idx =&gt; {    var target = boardStacks[idx-1]. pop();    if (target !== undefined) {      if (stack. peek() === target) {        stack. pop();        answer++;      } else {        stack. push(target);      }    }    })  return answer*2;}class Stack { constructor() {  this. _arr = []; } push(item) {  this. _arr. push(item); } pop() {  return this. _arr. pop(); } peek() {  return this. _arr[this. _arr. length -1]; }}"
    }, {
    "id": 205,
    "url": "/study_CODE_sort_3/",
    "title": "정렬 : 튜플",
    "body": "2020/07/04 - category: 2019 카카오 개발자 겨울 인턴십 문제 설명셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다. (a1, a2, a3, …, an) 튜플은 다음과 같은 성질을 가지고 있습니다. 중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2) 원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2) 튜플의 원소 개수는 유한합니다.  원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 (a1, a2, a3, …, an)이 주어질 때(단, a1, a2, …, an은 자연수), 이는 다음과 같이 집합 기호 ‘{‘, ‘}’를 이용해 표현할 수 있습니다. 예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는 와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로 는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다. 특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.  제한사항 s의 길이는 5 이상 1,000,000 이하입니다.  s는 숫자와 ‘{‘, ‘}’, ‘,’ 로만 이루어져 있습니다.  숫자가 0으로 시작하는 경우는 없습니다.  s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다.  s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다.  return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다. 문제풀이제한조건으로 부터 문제해결방향을 잘 파악해야 하는 것 같다.  여기서 중요하게 생각해야 할 제한 조건은 1. 주어진 s가 가리키는 튜플은 중복되는 원소가 없다. 2. 주어진 s는 하나의 튜플을 올바르게 표현한다. 그렇다면 s를 배열로 바꾸고, 배열의 크기에 따라 정렬한 뒤 Set에 넣어주면 해결 해결 난항 요소 - sort()에서 length 간 비교가 가능하다. 매개변수가 없을시 문자열 비교이다. ( 문자열 비교시 : 10 &lt; 2 ) 1234567891011121314151617181920function solution(s) {  var answer = [];  let len = s. length;  const caliValue = s. substr(2,len-4);  let tupleSet = caliValue. split( },{ ). reduce( (list,item) =&gt; {    list. push(item. split( , ));    return list;  }, []). sort((a,b) =&gt; a. length - b. length);  var tuple = new Set();  tupleSet. forEach( i =&gt; {    i. forEach( k =&gt; {      tuple. add(Number(k));    })  });  answer = [. . . tuple];  return answer;}더 좋은 풀이배열로 바꿀수 있는 문자열을 바꾸고자 할떄, 조건을 잘 살펴봐야 한다.  여기선 객체 문자열로 바꿀수 있다.  replace를 사용하여 객체 문자열로 바꿔준 다음 해당 data를 JSON. parse에 집어넣으면 배열로 완성된다. 12345678910111213141516function solution(s) {  var answer = [];  let tupleSet = JSON. parse(s. replace(/{/g, '['). replace(/}/g, ']'))  . sort((a, b) =&gt; a. length - b. length);  var tuple = new Set();  tupleSet. forEach( i =&gt; {    i. forEach( k =&gt; {      tuple. add(Number(k));    })  });  answer = [. . . tuple];  return answer;}"
    }, {
    "id": 206,
    "url": "/study_CODE_sort_2/",
    "title": "정렬 : H-Index",
    "body": "2020/07/03 - 문제 설명H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다. 어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h의 최댓값이 이 과학자의 H-Index입니다. 어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요.  제한사항     과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다.    논문별 인용 횟수는 0회 이상 10,000회 이하입니다.    입출력 예 | participant | return | | — | — | | [3, 0, 6, 1, 5] | 3 | 문제풀이정렬은 수학적 사고력이 더 중요한것 같다. 수능 수학 푼 느낌. 문제 해결을 위한 조건  h는 결국에는 논문 개수.  생각해 볼때, 논문 인용수가 가장 많은 순서대로 논문 개수를 늘려나가며, 개수보다 논문 인용수가 적어지는 때 그때 의 값의 H가 된다. (논문 인용수가 아무리 많더라도 하나밖에 없다면 h는 1. )12345678910function solution(citations) { citations = citations. sort( (a,b) =&gt; b-a); let idx = 0; while( idx+1 &lt;= citations[idx] ){  idx++; } return idx;}정렬 문제는 이런 식이 많을 것 같다. 이래서 이산수학을 배우는 듯. "
    }, {
    "id": 207,
    "url": "/study_CODE_sort_1/",
    "title": "정렬 : 가장 큰 수",
    "body": "2020/06/29 - 문제 설명0 또는 양의 정수가 주어졌을 때, 정수를 이어 붙여 만들 수 있는 가장 큰 수를 알아내 주세요. 예를 들어, 주어진 정수가 [6, 10, 2]라면 [6102, 6210, 1062, 1026, 2610, 2106]를 만들 수 있고, 이중 가장 큰 수는 6210입니다. 0 또는 양의 정수가 담긴 배열 numbers가 매개변수로 주어질 때, 순서를 재배치하여 만들 수 있는 가장 큰 수를 문자열로 바꾸어 return 하도록 solution 함수를 작성해주세요.  제한 사항     numbers의 길이는 1 이상 100,000 이하입니다.    numbers의 원소는 0 이상 1,000 이하입니다.    정답이 너무 클 수 있으니 문자열로 바꾸어 return 합니다.    입출력 예 | participant | return | | — | — | | [6, 10, 2] | 6210 | | [3, 30, 34, 5, 9] | 9534330 | 문제풀이정렬의 기준을 어떻게 효과적으로 생각할 수 있는 여부를 판단하는 문제인거 같다. 내가 처음 생각한 기준은, 모든 값을 전체적으로 동일하게 규정을 해버리는 것이었다.  모든 숫자를 끝의 숫자를 증가하는 방식을 이용해 자릿수를 맞춤으로써 값이 동일하게 규정되었다고 판단했다. 1234567891011 var data = numbers. map( i =&gt; {	let changeData = String(i);  let point;  for(let j=1; j&lt;3; j++) {    if(changeData[j] == undefined) {       point = changeData[j-1];      changeData = changeData. concat(point);    }  }  return changeData;})하지만 30, 301을 기준으로 하면 30 -&gt; 300, 301  ==&gt; 30130 &lt; 30301 으로써 동일하게 규정을 할 수가 없음을 확인 하였다. 동일한 규정을 찾으려면 너무 끝도 없었고 차라리 다른 기준을 생각해야 했다. 찾아본 결과 1:1 정렬을 하되 기준을 a와 b가 아닌 ab, ba로 삼아 진행하면 해결이 되었다. 1 var data = numbers. map( i =&gt; i+''). sort((a,b)=&gt; (b+a)-(a+b));데이터에서 0000이 나올수 있으니 방지 차원에서 1 return data[0] === '0' ? '0' : data;이번 문제를 통해 본 정렬 문제 테크닉은 최대한 작게 볼수 있어야 하는 것 같다. "
    }, {
    "id": 208,
    "url": "/study_CODE_recursive_1/",
    "title": "재귀 : 괄호 변환",
    "body": "2020/06/28 - category: 2020 KAKAO BLIND RECRUITMENT 문제 설명카카오에 신입 개발자로 입사한 콘은 선배 개발자로부터 개발역량 강화를 위해 다른 개발자가 작성한 소스 코드를 분석하여 문제점을 발견하고 수정하라는 업무 과제를 받았습니다. 소스를 컴파일하여 로그를 보니 대부분 소스 코드 내 작성된 괄호가 개수는 맞지만 짝이 맞지 않은 형태로 작성되어 오류가 나는 것을 알게 되었습니다. 수정해야 할 소스 파일이 너무 많아서 고민하던 콘은 소스 코드에 작성된 모든 괄호를 뽑아서 올바른 순서대로 배치된 괄호 문자열을 알려주는 프로그램을 다음과 같이 개발하려고 합니다. 용어의 정의‘(‘ 와 ‘)’ 로만 이루어진 문자열이 있을 경우, ‘(‘ 의 개수와 ‘)’ 의 개수가 같다면 이를 균형잡힌 괄호 문자열이라고 부릅니다. 그리고 여기에 ‘(‘와 ‘)’의 괄호의 짝도 모두 맞을 경우에는 이를 올바른 괄호 문자열이라고 부릅니다. 예를 들어, “(()))(“와 같은 문자열은 균형잡힌 괄호 문자열 이지만 올바른 괄호 문자열은 아닙니다. 반면에 “(())()”와 같은 문자열은 균형잡힌 괄호 문자열 이면서 동시에 올바른 괄호 문자열 입니다. ’(‘ 와 ‘)’ 로만 이루어진 문자열 w가 균형잡힌 괄호 문자열 이라면 다음과 같은 과정을 통해 올바른 괄호 문자열로 변환할 수 있습니다.  입력이 빈 문자열인 경우, 빈 문자열을 반환합니다.  문자열 w를 두 “균형잡힌 괄호 문자열” u, v로 분리합니다. 단, u는 “균형잡힌 괄호 문자열”로 더 이상 분리할 수 없어야 하며, v는 빈 문자열이 될 수 있습니다.  문자열 u가 “올바른 괄호 문자열” 이라면 문자열 v에 대해 1단계부터 다시 수행합니다.  3-1. 수행한 결과 문자열을 u에 이어 붙인 후 반환합니다.  문자열 u가 “올바른 괄호 문자열”이 아니라면 아래 과정을 수행합니다.  4-1. 빈 문자열에 첫 번째 문자로 ‘(‘를 붙입니다.  4-2. 문자열 v에 대해 1단계부터 재귀적으로 수행한 결과 문자열을 이어 붙입니다.  4-3. ‘)’를 다시 붙입니다.  4-4. u의 첫 번째와 마지막 문자를 제거하고, 나머지 문자열의 괄호 방향을 뒤집어서 뒤에 붙입니다.  4-5. 생성된 문자열을 반환합니다. 균형잡힌 괄호 문자열 p가 매개변수로 주어질 때, 주어진 알고리즘을 수행해 올바른 괄호 문자열로 변환한 결과를 return 하도록 solution 함수를 완성해 주세요.    매개변수 설명 p는 ‘(‘ 와 ‘)’ 로만 이루어진 문자열이며 길이는 2 이상 1,000 이하인 짝수입니다. 문자열 p를 이루는 ‘(‘ 와 ‘)’ 의 개수는 항상 같습니다. 만약 p가 이미 올바른 괄호 문자열이라면 그대로 return 하면 됩니다.     입출력 예 | p | result | | “(()())()” | “(()())()” | | “)(“ | “()” | | “()))((()” | “()(())() |  문제풀이단순히 설명한 그대로 구현할수 있느냐 이다. 이 문제의 정답률은 1번보다 오히려 적은 23%인데, 아마도 1번을 풀고나서 시간이 없어서 그랬지 않았나 라고 추측해본다.  개인적으로 1번 문제보단 짜기 쉬웠다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109class Stack { //stack의 peek이 필요해서 구현했다. 사용하기 편하다.   constructor() {   this. _arr = [];  }  push(item) {   this. _arr. push(item);  }   pop() {   return this. _arr. pop();  }   peek() {   return this. _arr[this. _arr. length -1];  }}function solution(p) {  const makeCollect = (str) =&gt; {    if(str==='') {      return '';    }    var idx = checkBalance(str)    if(idx&gt;=0) {      var sub = str. substring(0,idx);      if(checkCollect(sub)) {        return sub + makeCollect(str. slice(idx));      } else {        return  (  + makeCollect(str. slice(idx))+ )  + reverse(sub);      }    }  }  var answer = makeCollect(p);  console. log(answer);  return answer;}function checkBalance(str) {  if(str === '') {    return -1  }  const stack = new Stack();  stack. push(str. substring(0,1));  let target = str. slice(1);  let count = 1;    while(target !==   ) {    var compare = stack. peek();    if(compare === undefined) {      return count;    }    var compareItem = target. substring(0,1)    if(compare === compareItem) {      stack. push(compareItem);    } else {      stack. pop();    }    target = target. slice(1);    count++;  }  return count;}function checkCollect(str) {  const stack = new Stack();  var firstElement = str. substring(0,1)    if(firstElement !==  ( ) {    return false;  }  stack. push(firstElement);  let target = str. slice(1);  let flag = true;    while(target !==   ) {    var compare = stack. peek();    var compareItem = target. substring(0,1)    if(compare === undefined) {      if(firstElement !==  ( ) {        return false;      }    } else if(compare === compareItem) {      stack. push(compareItem);    } else {      stack. pop();    }    target = target. slice(1);  }  return true;}function reverse(str) {  if(str. length &lt;=2) {    return '';  }  let target = str. substr(1, str. length-2);  let reverseTarget = '';  while(target !==   ) {    var compare = target. substring(0,1)    if(compare ===  ( ) {      reverseTarget +=  ) ;    } else {      reverseTarget +=  ( ;    }    target = target. slice(1);  }  return reverseTarget;}"
    }, {
    "id": 209,
    "url": "/study_CODE_practice_6/",
    "title": "연습문제 : 2 x n 타일링",
    "body": "2020/06/28 - category: url: https://programmers. co. kr/learn/courses/30/lessons/12900# 문제풀이문제가 동적 프로그래밍을 보기 위해서 만든 문제이다.  그렇다 보니, return 값이 너무나도 커져야 하는 문제가 존재하는데, 이를 해결하기 위한 방법을 제대로 이해하지 못했다. 물론 그전에 동적 프로그래밍인지를 아는 것도 수학적인 문제라 쉽게 파악하지 못했다. 이 문제를 풀기 위해선  타일이 놓일 조건이 가로일 때 1개, 세로일 떄 2개가 깔릴 경우 각각의 경우의 수를 깔리지 않을 값에 더해주는 점화식을 이끌어 낼수 있느냐. n = [n-1] + [n-2] 각각의 조합을 구해보면, 파스칼 삼각형을 통해 피보나치 수열임을 이끌어 낼수 있느냐. 두가지로 나뉠 수 있다.  올림피아드 문제를 그냥 프로그래밍으로 옮겨 놓은 듯한 문제.  따지고 보면 결국 피보나치 동적 프로그래밍을 할수 있느냐인데, 이는 동적 프로그래밍을 배우면 가장 먼저 알게되는 사항이라, 솔직히 상당히 별로인 문제. 그런데 거기서 끝나지 않는다! 문제의 효율성을 파악하기 위해 커져버린 return 값을 해결하기 위해, 출제자는 동적 프로그래밍으로만 풀도록 제한 해야 하는 만큼, limit값이 넘어버리면 다음 피보나치 값은 제한이 걸린 채로 움직인다. 만일 각각의 조합을 직접 구하고 마지막 return에만 제한을 걸어버리면 답이 다르게 된다. 여러모로 신경써야 할 부분이 많았던 문제이다. 1234567function solution1(n) {  let arr = [1, 2];  for (let i = 2; i &lt; n; i++) {    arr[i] = (arr[i - 1] + arr[i - 2])%1000000007; // 제한이 걸린채 값이 정해진다.   }  return arr[n-1];}12345678910111213141516171819202122232425262728293031323334function solution(n) {  var answer = 0;  let twoCount = 0;  let oneCount = n;  answer += getCombination(oneCount, twoCount);  while(n&gt;1) {    n -= 2;    oneCount -= 2;    twoCount++;    answer += getCombination(oneCount, twoCount);  }    return answer%1000000007; //마지막 값에서만 제한을 걸다 보니, 값이 다르다. 그렇다고 아래 total값에 제한을 걸기도 애매하다. }function getCombination(oneCount, twoCount) {  if(oneCount === 0 || twoCount === 0) {    return 1;  }  let total = oneCount+twoCount;  let top = 1;  let bottom = 1;    for(let i=0; i&lt;total; i++) {    top *= total-i;  }  for(let j=0; j&lt;oneCount; j++) {    bottom *= oneCount-j;  }  for(let k=0; k&lt;twoCount; k++) {    bottom *= twoCount-k;  }  return top/bottom}"
    }, {
    "id": 210,
    "url": "/study_CODE_practice_5/",
    "title": "연습문제 : 카펫",
    "body": "2020/06/28 - category: url: https://programmers. co. kr/learn/courses/30/lessons/42842?language=javascript 문제풀이우선 yellow의 약수를 x, y라고 하자.  제한조건에서 brown이 정확하게 들어온다고 가정할 시, brwon은 2(x+y)+4가 될 것이다. 이때 주어진 brown과 값이 같다면 끝. 테스트 케이스에 yellow가 1개인 경우가 있어서 다행히 yellow에 +1를 할 수 있었다. 없을 경우도 생각해서 제출할 때, 테스크 케이스를 확인하고 제출하자. 1234567891011121314151617function solution(brown, yellow) {  var answer = [];  let x, y;  for(let i=1; i&lt;yellow+1; i++) {    if(yellow%i === 0 ) {      x = i;      y = yellow/i;      var brownNum = 2*(x+y)+4;      if(brownNum === brown) {        break;      }    }  }  answer. push(y+2);  answer. push(x+2);  return answer;}"
    }, {
    "id": 211,
    "url": "/study_CODE_practice_4/",
    "title": "연습문제 : 스킬트리",
    "body": "2020/06/27 - category: url: https://programmers. co. kr/learn/courses/30/lessons/49993 문제풀이주어진 조건에 맞춰 구현을 할수 있는지를 묻는 문제이다.  문자열을 다루는 문제라고도 할수 있다. 문제 해결의 방향을 입력에서 오는 문자열을 하나씩 빼면서 검사하도록 잡았는데, 처음 문제를 인식할 때 스킬은 입력한 스킬이며 해당 입력 스킬을 스킬트리 내에서 가능한 개수를 파악하는 것으로 이해했었다. 첫단추부터 잘못 꿰었어서 문제 해결하는 데 시간이 꽤 오래 걸렸다. 또한, 하나씩 빼면서 하는 검사다 보니 반복조건을 문자열이 비었을 경우로 생각을 해야 했다. 그렇게 되면 마지막에 가지게 되는 문자열은 검사를 해보지 못하게 된다. 그래서 마지막에 추가 검사를 해줌으로 해결하였다. 12345678910111213141516171819202122232425262728function enableSkill(skill, skill_tree) {  let compare = skill. slice();  let forUse = skill_tree. slice();    let tree = forUse[0];  forUse = forUse. substring(1);  let target = compare[0];  compare = compare. substring(1);  while(forUse != '') {    if(compare. includes(target)) {      return false;    } else if (target === tree) {      target = forUse[0];      forUse = forUse. substring(1);      tree = compare[0];       compare = compare. substring(1);    } else {      target = forUse[0];      forUse = forUse. substring(1);    }  }  if(compare. includes(target)) {    return false;  }  return true;} for문을 사용하여 더 깔끔하게 코드 작성. ```javascriptfunction solution(skill, skill_trees) { var answer = 0; skill_trees. forEach( i =&gt; {   if(enableSkill(skill, i)) {     console. log(i);     answer++;   }  }) return answer;}function enableSkill(skill, skill_tree) {  let compare = skill. slice();  let forUse = skill_tree. slice();  let tree = compare[0];  compare = compare. substring(1); 1234567891011for(let i=0, len=forUse. length; i&lt;len; i++) {  if(compare. includes(forUse[i])) {    return false;  }  else if(tree === forUse[i]) {    tree = compare[0];    compare = compare. substring(1);  }}return true; } ``` # 다른 풀이  내가 생각한 방법은, false 조건을 만들어서 구현했다. 그런데 아래 풀이는 true 조건을 만들고 구현한 방법이다. 123456789101112function solution(skill, skill_trees) {  function isCorrect(n) {    let test = skill. split('');    for (var i = 0; i &lt; n. length; i++) {      if (!skill. includes(n[i])) continue;      if (n[i] === test. shift()) continue;      return false;    }    return true;  }    return skill_trees. filter(isCorrect). length;}"
    }, {
    "id": 212,
    "url": "/study_CODE_practice_3/",
    "title": "연습문제 : 멀쩡한 사각형",
    "body": "2020/06/27 - category: url: https://programmers. co. kr/learn/courses/30/lessons/62048 문제풀이수학문제를 풀어야 한다. 대각선이 지나는 단위 정사각형.  물론 조금만 더 생각해 보면, 수학적 사고력으로 해결할 수 있는 문제이나, 제한시간이 주어지고 갑자기 수학적 사고를 하도록 한다면 문제를 해결할 수 있을지 부정적이다. 마지막으로 미뤄두고 풀어보도록 해야지. 우선 서로소인 사각형의 대각선을 생각해 보자.  서로소인 관계를 설정하는 이유는, 그렇지 않을 때 대각선은 나뉘어지는 부분이 있기 때문.  예를들어 5X4인 사각형(서로소인 관계의 사각형)의 대각선이 칠해진 개수는 1234567891011121314151617181920212223□□□■■□□■■□□■■□□■■□□□□□□□■□□□■■□□■■□■■■□□ □□□□■□□□□■□□□■■■■■■□□□□□■□□□□■□□□□■■■■■■5+4-1 = 8개가로 + 세로 -1 이 대각선에 의해 칠해진 개수가 된다. mn 사각형에서 m과 n의 최대공약수가 a라고 할 떄, m = ab, n = ac 라고 할 수 있다. (b와 c는 서로소) 그렇게 되면 mn의 사각형의 넓이는 a^2bc이며  이는 bc의 사각형이 a^2개가 있다고 생각할 수 있다. 이때 잘 생각해 보면 대각선이 지나가는 bc의 사각형은 a개가 될수 있다.  따라서 bc의 대각선에 의해 칠해진 사각형 개수는 b+c-1 m*n의 사각형의 경우 a(b+c-1) = ab+ac-a = 가로 + 세로 - 가로와 세로의 최대공약수 이렇게 해결. 123456789101112131415161718192021222324  function solution(n) {  var answer = '';  let value = n;  while(value&gt;3) {    var div = parseInt(value/3);    var rest = value%3;    if(rest === 0) {      value = div-1;      answer = '4' + answer; //먼저 오게 함으로써 자릿수 보정    } else {      value = div;      answer = rest + answer;    }  }  if(value === 3) {    answer = '4' + answer;  } else {    answer = value + answer;  }  return answer;}"
    }, {
    "id": 213,
    "url": "/study_CODE_practice_2/",
    "title": "연습문제 : 124 나라의 숫자",
    "body": "2020/06/27 - category: url: https://programmers. co. kr/learn/courses/30/lessons/12899 문제풀이규칙성을 찾고, 해당 규칙을 구현할 수 있는지 알아보는 문제.  규칙을 구현하기에 걸림이 되었던 부분은 0이 존재하지 않으며, 3진수이지만 자릿수가 올라 갈 경우 올라가지 않고 4가 붙는다는 사실이다. 해당 경우에 대한 대처를 해 놓은다면 문제 풀기는 수월했다. 123456789101112131415161718192021222324  function solution(n) {  var answer = '';  let value = n;  while(value&gt;3) {    var div = parseInt(value/3);    var rest = value%3;    if(rest === 0) {      value = div-1;      answer = '4' + answer; //먼저 오게 함으로써 자릿수 보정    } else {      value = div;      answer = rest + answer;    }  }  if(value === 3) {    answer = '4' + answer;  } else {    answer = value + answer;  }  return answer;}"
    }, {
    "id": 214,
    "url": "/study_CODE_practice_1/",
    "title": "연습문제 : 소수찾기",
    "body": "2020/06/27 - category: 문제 설명1부터 입력받은 숫자 n 사이에 있는 소수의 개수를 반환하는 함수, solution을 만들어 보세요. 소수는 1과 자기 자신으로만 나누어지는 수를 의미합니다.  (1은 소수가 아닙니다. )  제한사항 n은 2이상 1000000이하의 자연수입니다. 입출력 예 | n | result | | — | — | | 10 | 4 | | 5 | 3 | 문제풀이단순 수학 문제이다.  수학시간에 배운 어떤 체… 를 이용하면 쉽게 해결할 수 있다. 12345678910111213141516  let answer = 0;  let arr = [];  for (let i = 2; i &lt;= n; i++) {    arr[i] = i; // 순서를 맞추기 위함. 2번자리에 2가 들어가게끔 조정.   }  for (let i = 2; i &lt;= n; i++) {    if (arr[i] === 0)       continue;    for (let j = i + i; j &lt;= n; j += i) {      arr[j] = 0;    }  }    return arr. filter( i =&gt; i !== 0). length;(번외) 소수판단12345678910function isPrimeNumber(number) { const notPrime = [0, 1]; if (notPrime. includes(number)) return false; for (let i = 2; i * i &lt;= number; i++) {    //number의 제곱근만 판단해도 소수판단 가능  if (number % i === 0) return false; } return true;}"
    }, {
    "id": 215,
    "url": "/study_Programming_powerSet/",
    "title": "멱집합",
    "body": "2020/06/26 - 멱집합탐색 문제에서 멱집합을 이용해야 하는 경우가 종종 있다. 이해하고 사용하자. ## 부분집합 부분집합을 구성하는 방법은 원소를 사용여부(O/X)로 구분된다. 이는 이진트리로 구현할수 있는데.  단계를 구성하고 각 이진트리에 들어갈때마다 flag에 O,X를 기록한다.  마지막 단계에 들어가게 되면 해당 flag를 바탕으로 해당하는 set을 Array에서 찾고 powerSet에 push한다. 12345678910111213141516171819202122232425const getPowerSet = function (arr) {  let flag = new Array(arr. length). fill(false);  const powerSet = [];  let len = arr. length;  const makePowerSet = (depth) =&gt; {    if (depth === len) {     const subSet = arr. filter((value, idx) =&gt; flag[idx]);     powerSet. push(subSet);     return;   }    flag[depth] = true;    makePowerSet(depth+1);    flag[depth] = false;   makePowerSet(depth+1);  }    makePowerSet(0);  return powerSet; }  const example = [1,2,3]; const result = getPowerSet(example); console. log(result);잘 생각해야 하는건 어차피 각 단계별로 flag를 새로 기입해야 하므로, 함수에 flag를 매개로 넣어줄 필요가 없다. "
    }, {
    "id": 216,
    "url": "/study_Programming_permutation&combination/",
    "title": "순열과 조합",
    "body": "2020/06/26 - 순열과 조합순열과 조합은 여러 군데에서 쓰인다.  쓰이는 방식도 다양한데,  각각의 배열의 값으로써 조합된 숫자로써1하지만 설계하는게 쉬운일이 아니기 때문에, 배열로 사용할수 있는 그리고 조합된 숫자를 사용하도록 String으로 사용하는 각각의 함수를 만들어 놓고자 한다. nPr, nCr 값수학이다.  nPr =&gt; n개의 경우를 r번 사용할경우.  nCr =&gt; nPr에서 중복 제외 123456789101112131415161718192021function combination(n, r) { let top = 1; let bottom = 1; for(let i=0; i&lt;r; i++) {  top *= n-i;  bottom *= r-i; } return top/bottom;}function permutation(n, r) { let value = 1; for(let i=0; i&lt;r; i++) {  value *= n-i; } return value;}배열의 원소로 만들수 있는 가능한 모든 조합자주 나오는 문제이다. 기능을 추가해서 해결해야할 문제들이니 잘 알아두자. 12345678910111213141516171819202122//list 값은 문자열!/*** input은 배열, output은 배열의 순열조합으로 이루어진 String*/var myList = [1, 2, 3, 4];var test = findAllPermutation(myList);function findAllPermutation(list, prevValue) { const frontPaddingValue = prevValue || ''; return list. reduce((listNumbers, value, index) =&gt; {  listNumbers. push(frontPaddingValue+value);  const nextNumberList = [. . . list];  nextNumberList. splice(index, 1);  const result = findAllPermutation(   nextNumberList, frontPaddingValue + value  );  listNumbers. push(. . . result);  return listNumbers; }, []);}잘 생각해 보자. 배열 내 각각의 요소를 저장한 그 전값과 합쳐주면 된다. 단 각각의 요소를 연산할 때 동일한 조건을 가지도록 해야 한다. (reduce의 강점. ) ex [1, 2, 3]  1을 가지고 들어가서 [2, 3]의 요소와 합쳐준다. 그런 행위를 할때마다 push 123456789101112131415161718192021222324/** * output : 배열 * @param {*} inputArr : Input 배열이다.  * 전반적인 매커니즘은 pick에서 하나씩 가지고 재귀함수로 들어간다. */function permutator(inputArr, rValue) { var results = []; var r = inputArr. length-rValue;  function permute(arr, pick) {  var cur, pick = pick || [];  for (var i = 0; i &lt; arr. length; i++) {   cur = arr. splice(i, 1);   results. push(pick. concat(cur));   permute(arr. slice(), pick. concat(cur));   arr. splice(i, 0, cur[0]);  }  return results; } return permute(inputArr);}Permutation12345678910111213141516171819202122232425262728293031/*** 만일 해당 조합을 숫자로 사용할 경우에 쓰도록 output이 String값. */var myList = [1, 2, 3, 4];var test = findAllPermutation(myList, 4); //4개 조합 ex 1234function findPermutation(stringList, rValue) {   const len = stringList. length;  const startCount = 1; //현재 조합을 뽑은 숫자. 재귀로 하나씩 뽑아갈때마다. count가 증가.   function makePermutation(stringList, count, rValue, prevValue) {    const frontPaddingValue = prevValue || ''; //값이 없을 경우 빈 문자로 초기화    let pivotCount = count; //재귀로 들어올때마다 기준 Count를 정함.     //reduce 과정에서 count값이 변경되므로 list의 요소가 끝날때 마다 다시 기준 Count를 잡아줌.     return stringList. reduce( (listNumbers, value, idx) =&gt; {      count = pivotCount;      if(count === rValue) {        listNumbers. push(frontPaddingValue+value);        return listNumbers;      }      const nextNumberList = [. . . stringList];      nextNumberList. splice(idx, 1);      count++; //아래와 동일      //count = 1+len-nextNumberList. length;       const result = makePermutation(nextNumberList, count, rValue, frontPaddingValue + value);      listNumbers. push(. . . result);      return listNumbers;    }, []);  }  return makePermutation(stringList, startCount, rValue);}findAllPermutation에 pivotCount를 지정하여 해당 Count일때의 집합을 저장. 123456789101112131415161718192021222324252627282930/** * * @param {*} inputArr : Input 배열이다.  * @param {*} rValue : nPr에서 r이며, 배열의 길이보다 적게 들어와야한다. * * 전반적인 매커니즘은 pick에서 하나씩 가지고 재귀함수로 들어간다. */function permutator(inputArr, rValue) { var results = []; var r = inputArr. length-rValue; // 정확히는 arr의 length가 남는 개수에 따라 result값에 push를 한다. 즉 1개를 썼으면 3개가 남았으니까 1개 result.   function permute(arr, pick) {   var cur, pick = pick || [];  for (var i = 0; i &lt; arr. length; i++) {   cur = arr. splice(i, 1);   if (arr. length === r) {    results. push(pick. concat(cur));   }   permute(arr. slice(), pick. concat(cur));   arr. splice(i, 0, cur[0]);  }  return results; } return permute(inputArr);}Combination## 하나의 집합 내에서 조합 123456789101112131415161718192021222324const getCombinations = (arr, m) =&gt; {  const combinations = [];  const picked = [];  function find(picked) {    if (picked. length === m) {      const rst = [];      for (let i of picked) {        rst. push(arr[i]);      }      combinations. push(rst);      return;    } else {      let start = picked. length ? picked[picked. length - 1] + 1 : 0;      for (let i = start; i &lt; arr. length; i++) {        picked. push(i);        find(picked);        picked. pop();      }    }  }  find(picked);  return combinations;}하나의 집합 중 같은 값이 있을 경우 ([1, 2, 2, 3] 과 같은 숫자에서 combination을 뽑고자 할떄) 123456789101112131415161718192021222324252627282930const getCombinations = (arr, m) =&gt; { arr. sort(); //같은 값이 연속으로 들어오도록 강제 const combinations = []; const picked = []; const used = new Array(arr. length). fill(false);  function find(picked) {  if (picked. length === m) {   const rst = [];   for (let i of picked) {    rst. push(arr[i]);   }   combinations. push(rst);   return;  } else {   let start = picked. length ? picked[picked. length-1] + 1 : 0;   for (let i = start; i &lt; arr. length; i++) {    if (i === 0 || arr[i] !== arr[i-1] || used[i-1]) {     picked. push(i);     used[i] = 1;     find(picked);     picked. pop();     used[i] = 0;    }   }  } } find(picked); return combinations;}## 두개의 집합간 조합 ### 독립된 두개의 집합 12345678910  function getCombination(arr_a, arr_b) {  var answer = 0;  const combination = [];  arr_a. forEach( a =&gt; {    arr_b. forEach( b =&gt; {      combination. push([a, b]);    })  })  return combination;  } ### 종속적인 두개의 집합  아래의 문제해결은 하나의 배열안에 2개배열을 넣을 경우에 해당하고,  만일 특정 조건으로 2개 배열을 구성할수 있다면 기존 하나의 배열에서의 조합 문제 해결방식을 따른다. (조합문제_1 참고) 12  // parentSet = [0, 1, 2, 3, 4]  var arraySet = [[0, 2], [1, 2], [3, 4]];1234567891011121314151617181920212223242526272829303132333435363738 function getCombination(arrays) {  var answer = {};  function makeCombination(i = 0, selected = []) {    if (!arrays[i]) {      selected. sort(); //당연히 조합이기 때문에 순서가 다른 같은 값은 중복처리해줘야 한다.       answer[selected. join('')] = true;      return;    }    arrays[i]. filter(e =&gt; !selected. includes(e)). forEach(e =&gt; {      makeCombination(i + 1, selected. concat([e]));    });  }    makeCombination();  return answer;}/** 순서가 같은 다른 값 ex) arraySet = [[0, 2], [1, 2], [3, 4], [3, 4]]; 일 경우   [0, 1, 4, 3] , [0, 1, 3, 4] 를 튜플로서 처리하자면 아래와 같다. */ function getCombination(arrays) {  var answer = [];    function makeCombination(i = 0, selected = []) {    if (!arrays[i]) {      answer. push(selected);      return;    }    arrays[i]. filter(e =&gt; !selected. includes(e)). forEach(e =&gt; {      makeCombination(i + 1, selected. concat([e]));    });  }    makeCombination();  return answer;}"
    }, {
    "id": 217,
    "url": "/study_CODE_permutation_1/",
    "title": "순열 : 외벽 점검",
    "body": "2020/06/25 - category: 2020 KAKAO BLIND RECRUITMENT 문제 설명레스토랑을 운영하고 있는 스카피는 레스토랑 내부가 너무 낡아 친구들과 함께 직접 리모델링 하기로 했습니다. 레스토랑이 있는 곳은 스노우타운으로 매우 추운 지역이어서 내부 공사를 하는 도중에 주기적으로 외벽의 상태를 점검해야 할 필요가 있습니다. 레스토랑의 구조는 완전히 동그란 모양이고 외벽의 총 둘레는 n미터이며, 외벽의 몇몇 지점은 추위가 심할 경우 손상될 수도 있는 취약한 지점들이 있습니다. 따라서 내부 공사 도중에도 외벽의 취약 지점들이 손상되지 않았는 지, 주기적으로 친구들을 보내서 점검을 하기로 했습니다. 다만, 빠른 공사 진행을 위해 점검 시간을 1시간으로 제한했습니다. 친구들이 1시간 동안 이동할 수 있는 거리는 제각각이기 때문에, 최소한의 친구들을 투입해 취약 지점을 점검하고 나머지 친구들은 내부 공사를 돕도록 하려고 합니다. 편의 상 레스토랑의 정북 방향 지점을 0으로 나타내며, 취약 지점의 위치는 정북 방향 지점으로부터 시계 방향으로 떨어진 거리로 나타냅니다. 또, 친구들은 출발 지점부터 시계, 혹은 반시계 방향으로 외벽을 따라서만 이동합니다. 외벽의 길이 n, 취약 지점의 위치가 담긴 배열 weak, 각 친구가 1시간 동안 이동할 수 있는 거리가 담긴 배열 dist가 매개변수로 주어질 때, 취약 지점을 점검하기 위해 보내야 하는 친구 수의 최소값을 return 하도록 solution 함수를 완성해주세요.  제한사항 n은 1 이상 200 이하인 자연수입니다.  weak의 길이는 1 이상 15 이하입니다.  서로 다른 두 취약점의 위치가 같은 경우는 주어지지 않습니다.  취약 지점의 위치는 오름차순으로 정렬되어 주어집니다.  weak의 원소는 0 이상 n - 1 이하인 정수입니다.  dist의 길이는 1 이상 8 이하입니다.  dist의 원소는 1 이상 100 이하인 자연수입니다.    친구들을 모두 투입해도 취약 지점을 전부 점검할 수 없는 경우에는 -1을 return 해주세요.   입출력 예 | n | weak | dist | result | | 12 | [1, 5, 6, 10] | [1, 2, 3, 4] | 2 | | 12 | [1, 3, 4, 9, 10] | [3, 5, 7] | 1 |문제풀이문제의 해결 방안을 전혀 생각하지 못하였다.  dist가 큰 값부터 하는 방법으로 생각을 해봤지만, 도저히 방도가 생각이 안났다.  이런 경우는 대부분 완전탐색이라는 것을 기억하자. 우선 dist가 오는 순서를 정할수 있으며, 해당 순서에 맞게 weak값을 지정하는 방법으로 문제를 풀어 나갈 수 있다. dist의 순서는 dist 전체 값으로 하는 순열으로 만들수 있다. 그러면 해결 가능하다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879var n = 12;var weak = [1, 3, 4, 9, 10]; //[1, 3, 4, 9, 10]var dist = 	[3, 5, 7]; //[3, 5, 7]var test = solution(n, weak, dist);function solution(n, weak, dist) { const distLen = dist. length; const distSet = permutator(dist, distLen); let testWeak = weak. slice(); const weakLen = weak. length; let count = -1;  for(let i=0; i&lt;weakLen; i++) {  distSet. forEach( item =&gt; {   var result = check(item, testWeak);   if (result &gt; 0) {    if(count&lt;0) {     count = result    } else{     if(count &gt; result) {      count = result;     }    }   }  })  let change = testWeak. splice(0,1);  testWeak. splice(weakLen, 0, change[0]+n); }  return count;}function check(item, weak) { let weakIdx = 0; let weakLen = weak. length; let count = 0; for(let i=0, len=item. length; i&lt;len; i++) {  var canRepair = item[i] + weak[weakIdx];  count++;  weakIdx++;  while(weakIdx&lt;weakLen){   if(canRepair &gt;= weak[weakIdx]) {    weakIdx++;   } else {    break;   }  }  if(weakIdx === weakLen) {   break;  } }  if(weakIdx === weakLen) {  return count; } else {  return -1; }}function permutator(inputArr, rValue) { var results = []; var r = inputArr. length-rValue; // 정확히는 arr의 length가 남는 개수에 따라 result값에 push를 한다. 즉 1개를 썼으면 3개가 남았으니까 1개 result.   function permute(arr, pick) {   var cur, pick = pick || [];  for (var i = 0; i &lt; arr. length; i++) {   cur = arr. splice(i, 1);   if (arr. length === r) {    results. push(pick. concat(cur));   }   permute(arr. slice(), pick. concat(cur));   arr. splice(i, 0, cur[0]);  }  return results; } return permute(inputArr);}"
    }, {
    "id": 218,
    "url": "/study_Programming_javaScriptTemplet/",
    "title": "자바스크립트",
    "body": "2020/06/24 - 숫자 -&gt; 문자 값을 String으로 변환. 12 var numValue = 1; String(numValue); 값에 ‘‘를 추가  12 var numValue = 1; numValue = numValue + '';   배열에 객체 넣기123 var data = []; var key =  key  //이때 key값의 숫자로 구성되어 있을경우 data는 숫자로 판단한다.  data[key] = anyValue;prototype. sort();매개변수가 없으면 문자열로 정렬. 1 prototype. sort( (a, b) =&gt; a-b );객체를 이용할 경우 1234567891011121314151617181920 var items = [ { name: 'Edward', value: 21 }, { name: 'Sharpe', value: 37 }, { name: 'And', value: 45 }, { name: 'The', value: -12 }, { name: 'Magnetic', value: 13 }, { name: 'Zeros', value: 37 } ];// value 기준으로 정렬items. sort(function (a, b) { if (a. value &gt; b. value) {  return 1; } if (a. value &lt; b. value) {  return -1; } // a must be equal to b return 0;});sort의 return 값이 1이면 바꿈, -1이면 바꾸지 않는다. # sort() sort를 그냥 두면 문자열 정렬이다 (10 &lt; 2)  따라서 숫자 정렬시 무조건 sort((a,b) =&gt; a-b); 꼭 쓰자 # forEach, reduce, filter, map  forEach =&gt; return x  reduce =&gt; return o (한줄시 생략)  map =&gt; return o (한줄시 생략) filter =&gt; return true 이면 가지고 옴. # … 문법  배열 할당 12345678910[a1, a2, . . . rest_a] = [1, 2, 3, 4, 5, 6, 7, 8, 9];console. log(a1); // 1console. log(a2); // 2console. log(rest_a); // [3, 4, 5, 6, 7, 8, 9]var { a1, a2, . . . rest_a } = { a1 : 10, a2 : 20, a3 : 30, a4 : 40 };console. log(a1); // 10console. log(a2); // 20console. log(rest_a); // { a3: 30, a4: 40 }Number()문자열을 숫자로 -&gt; 바꿀수 없을경우 NaN Set()12345678910 const foo = new Set(); foo. add({}); // 빈 객체 추가 foo. add({}); // 또 다른 빈 객체 추가 console. log(foo. size); // 2 console. log(foo) // Set { {}, {} } foo. add(10); // 숫자 10 추가 foo. add('10'); // 문자열  10  추가 foo. add(10); // 이미 10이 있기때문에 무시됩니다 console. log(foo. size); // 4 console. log(set); // Set { {}, {}, 10, '10' }prototype. has(값) — set에 값 존재 확인. true 또는 false를 반환.  prototype. delete(값) — set에서 값을 제거.  prototype. clear() — set에서 모든 값을 제거. 123 const foo = new Set([ '아이폰XR', '갤노트9' ]); const fooInArray = [ . . . foo ]; console. log(fooInArray) // [ '아이폰XR', '갤노트9' ];Array. splice();배열의 기존 요소를 삭제 또는 교체 12345678const months = ['Jan', 'March', 'April', 'June'];months. splice(1, 0, 'Feb'); //1번 index에 삭제 없이 값 추가console. log(months); // expected output: Array [ Jan ,  Feb ,  March ,  April ,  June ]months. splice(4, 1, 'May'); // 4번 index에 1개 삭제 후 값 추가console. log(months);// expected output: Array [ Jan ,  Feb ,  March ,  April ,  May ]or 연산자값이 들어오지 않을 경우 초기값을 설정하고자 할때 다음과 같이 해보자. 1const initValue = (value) =&gt; theTitle ||  initial Vlaue ; 문자열 합치기단순히 더해주면 합쳐진다. 1 1  +  2  //  12 배열 합치기1234const alpha = ['a', 'b', 'c'];alpha. concat(1, [2, 3]);// 결과: ['a', 'b', 'c', 1, 2, 3]중복 값 제거하기 Set() 이용  123prototype = new Set();prototype. add( key );[. . . prototype. keys()];    객체 이용  12prototype[ key ] = true;Object. keys( prototype );   # JSON. parse(text[, reviver]) 배열 및 객체문법에 속한 Text문을 배열 및 객체로 변환해준다. 1234const json1 = '{ result :true,  count :42}';const json2 =  [[1,2,3],[2,1],[1,2,4,3],[2]] ;const obj1 = JSON. parse(json1);const obj2 = JSON. parse(json2); # String. prototype. replace()  String 안에 있는 값을 찾아 원하는 값으로 바꿔준다.  문자열 리턴! 12g : 발생할 모든 pattern에 대한 전역 검색i : 대/소문자 구분 안함12345678910const p = 'The quick brown fox jumps over the lazy dog. If the dog reacted, was it really lazy?';const regex = /dog/gi;console. log(p. replace(regex, 'ferret'));// expected output:  The quick brown fox jumps over the lazy ferret. If the ferret reacted, was it really lazy? console. log(p. replace('dog', 'monkey'));// expected output:  The quick brown fox jumps over the lazy monkey. If the dog reacted, was it really lazy? # 배열 n개로 나누기 123456789101112Array. prototype. division = function (n) { var arr = this; var len = arr. length; var cnt = Math. floor(len / n); var tmp = []; for (var i = 0; i &lt;= cnt; i++) {  tmp. push(arr. splice(0, n)); } return tmp;}12345678910const division = (arr, n) =&gt; { var len = arr. length; var cnt = Math. floor(len / n); var tmp = []; for (var i = 0; i &lt;= cnt; i++) {  tmp. push(arr. splice(0, n)); } return tmp;}matrix row -&gt; column 전환 한줄 전환```javascriptvar row = [0, 0, 0, 4, 3];var result = [];result = row. map( (_, i) =&gt; […(result[i] || []), row[i]]);/*row -&gt; column [0,       0,       0,       4,       3]*/12345678 - 전체 시계반대방향 전환```javascriptconst transpose = (matrix) =&gt; matrix. reduce( (result, row) =&gt; row. map((_, i) =&gt; [. . . (result[i] || []), row[i]]), []); 전체 시계방향 전환  12345678function rotation(key) { let result = []; debugger; for(let i=key. length-1; i&gt;=0; i--) {   result = key[i]. map( (_, $) =&gt; [. . . (result[$] || []), key[i][$]]); } return result; }   디폴트 매개변수디폴트 매개변수를 설정함으로써 함수 밖에서 일부로 설정을 안해줘도 되게 한다. 123456function multiply(a, b = 1) { return a*b;}multiply(5); // 5multiply(5, 2); // 10# nXn matrix 생성 1 new Array(n). fill(0). map( () =&gt; Array(n). fill(0));문자열 빼기str은 변경되지 않는다. 12 var str =  abcd ; var removeFirst = str. substring(1);"
    }, {
    "id": 219,
    "url": "/study_CODE_hashCollision/",
    "title": "해시충돌문제 : 호텔 방 배정",
    "body": "2020/06/23 - category: 2019 카카오 개발자 겨울 인턴십 문제 4문제 설명정확성 &amp; 효율성 테스트 스노우타운에서 호텔을 운영하고 있는 스카피는 호텔에 투숙하려는 고객들에게 방을 배정하려 합니다. 호텔에는 방이 총 k개 있으며, 각각의 방은 1번부터 k번까지 번호로 구분하고 있습니다. 처음에는 모든 방이 비어 있으며 스카피는 다음과 같은 규칙에 따라 고객에게 방을 배정하려고 합니다. 한 번에 한 명씩 신청한 순서대로 방을 배정합니다.  고객은 투숙하기 원하는 방 번호를 제출합니다.  고객이 원하는 방이 비어 있다면 즉시 배정합니다.  고객이 원하는 방이 이미 배정되어 있으면 원하는 방보다 번호가 크면서 비어있는 방 중 가장 번호가 작은 방을 배정합니다.  예를 들어, 방이 총 10개이고, 고객들이 원하는 방 번호가 순서대로 [1, 3, 4, 1, 3, 1] 일 경우 다음과 같이 방을 배정받게 됩니다. 원하는 방 번호	배정된 방 번호   1	1   3	3   4	4   1	2   3	5   1	6 전체 방 개수 k와 고객들이 원하는 방 번호가 순서대로 들어있는 배열 room_number가 매개변수로 주어질 때, 각 고객에게 배정되는 방 번호를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.  제한사항     k는 1 이상 1012 이하인 자연수입니다.    room_number 배열의 크기는 1 이상 200,000 이하입니다.    room_number 배열 각 원소들의 값은 1 이상 k 이하인 자연수입니다.    room_number 배열은 모든 고객이 방을 배정받을 수 있는 경우만 입력으로 주어집니다.    예를 들어, k = 5, room_number = [5, 5] 와 같은 경우는 방을 배정받지 못하는 고객이 발생하므로 이런 경우는 입력으로 주어지지 않습니다.    문제풀이해시를 이용해 값을 저장할 때, 충돌 문제를 얼마나 효율적으로(빠르면서, 공간을 적게쓰도록) 생각보다 재귀함수는 느리지 않았다. (어차피 for문을 도는 거라서 도는 거만큼 함수를 return 하니까. ) 더욱 빠르게 하기 위해 추가로 설정하면 설정한 만큼 동작을 더해야하기 때문에 가장 최소화 하는게 좋다.  그리고 공간 이슈는 [재귀 함수 발생 수 + flag 배열 생성시 차지하는 공간] 을 중점적으로 살펴봐야 한다.  1차 시도 - 정확도 100%, 속도 100%, 공간활용 0%  해시 충돌 문제 해결에서 배운 단순히 flag 설정하여 하나씩 찾아가며 해결했다.   최대속도는 1000ms 최소속도는 10ms 편차가 큰 편12345678910111213141516171819202122function solution(k, room_number) {  var answer = [];  let used = new Array(k+1). fill(false);  function searchRoom(idx) {    if(idx === used. length){      return;    }    if(!used[idx]) {      used[idx] = true;      answer. push(idx);    } else {      searchRoom(idx+1);    }    return;  }    room_number. forEach( i =&gt; {    searchRoom(i);  })  return answer;} 재귀를 이용하지 않고 for문을 통해 다음 index를 찾아 문제 해결 시간 초과…1234567891011121314151617181920212223242526272829function solution(k, room_number) {  var answer = [];  let used = new Array(k+1). fill(false);  function searchRoom(idx) {    if(idx === used. length){      return;    }    if(!used[idx]) {      used[idx] = true;      answer. push(idx);    } else {      var isNext = used. indexOf(false,idx+1)      if(isNext&gt;0){        used[isNext] = true;        answer. push(isNext);      }      else {        return;      }    }    return;  }    room_number. forEach( i =&gt; {    searchRoom(i);  })  return answer;} 재귀를 이용, 찾을때 만 1을 더해주는 것이 아닌 찾지 못할때도 1을 더해준다. 속도와 공간활용에서 향상되긴하는데, 이것밖에 생각 못했나. . 라고 생각이 드는 답안. 12345678910111213141516171819202122232425function solution(k, room_number) {  var answer = [];  let used = new Array(k+1). fill(-1);  function searchRoom(idx) {    debugger;    if(idx === used. length){      return;    }    if(used[idx]&lt;0) {      used[idx] = idx+1;      answer. push(idx);    } else {      searchRoom(used[idx]);      used[idx]++;    }    return;  }    room_number. forEach( i =&gt; {    searchRoom(i);  })  return answer;} 해결 찾을 경우 : 처음 노드의 값이 찾은 노드 다음 위치저장   찾지 못할 경우 : 직전 노드의 값을 다음 노드가 가리키는 위치로 저장.  또한, 위치 저장값은 해시로 저장. 1234567891011121314151617181920212223242526272829function solution(k, room_number) {  var answer = [];  let testUsed = new Map();  function searchRoom(idx) {    if (!testUsed. has(idx)) {      testUsed. set(idx, idx + 1);      answer. push(idx);    } else {      var target = testUsed. get(idx);      while (target &lt;= k) {        if (!testUsed. has(target)) {          testUsed. set(target, target+1);          testUsed. set(idx, target+1);          answer. push(target);          return;        } else {          var nextTarget = testUsed. get(target);          testUsed. set(target, nextTarget+1);          target = nextTarget;        }      }    }  }  room_number. forEach( i =&gt; {    searchRoom(i);  })  return answer;}더 나은 문제풀이위의 해결 방법에서는 값에 따른 속도의 편차가 일정하지 않았다. 아래의 방법은 비교적 일정했다.  재귀로 이동하며 값을 찾아나갈 때, 재귀함수의 return 값이 위치 값을 줌으로써 확인했던 모든 노드의 값을 최종 찾은 값의 다음값으로 저장해준다. (이런 방법이!) 1234567891011121314const solution = (k, roomNumbers) =&gt; { const used = new Map(); return roomNumbers. map((number) =&gt; findRoom(number, used));};function findRoom(room, used) { if (used. get(room) == undefined) {  used. set(room, room + 1);  return room; } let next = findRoom(used. get(room), used); used. set(room, next + 1); return next;}"
    }, {
    "id": 220,
    "url": "/study_CODE_hash_2/",
    "title": "해시 : 완주하지 못한 선수",
    "body": "2020/06/22 - 문제 설명수많은 마라톤 선수들이 마라톤에 참여하였습니다. 단 한 명의 선수를 제외하고는 모든 선수가 마라톤을 완주하였습니다. 마라톤에 참여한 선수들의 이름이 담긴 배열 participant와 완주한 선수들의 이름이 담긴 배열 completion이 주어질 때, 완주하지 못한 선수의 이름을 return 하도록 solution 함수를 작성해주세요.  제한사항 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다.  completion의 길이는 participant의 길이보다 1 작습니다.  참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다.  참가자 중에는 동명이인이 있을 수 있습니다. 입출력 예 | participant | completion | return | | — | — | — | | [leo, kiki, eden] | [eden, kiki] | leo | | [marina, josipa, nikola, vinko, filipa] | [josipa, filipa, marina, nikola] | vinko | | [mislav, stanko, mislav, ana] | [stanko, ana, mislav] | mislav | 문제풀이해시를 이용해 풀수 있다.  각 data를 Key, data의 개수를 value로 HashMap을 만들어 중복 시 map의 값을 줄여나가며, 0 일경우 지운다.  Key들의 집합이 답이겠으나, 들어오지 못한 인원은 1명이라는 제한 조건으로 인해 단순히 key를 return 하면 된다. 해시를 사용하는 방법은 아래와 같이 2가지이다.  Map()을 이용한 방법.    객체를 사용한 방법   ```javascriptfunction solution(participant, completion) { var answer = ‘’; let comMap = new Map();participant. forEach( (i) =&gt; {  var value = comMap. get(i);  if((value == undefined)) {   comMap. set(i, 1);  } else {   value += 1;   comMap. set(i, value);  } }) completion. forEach( (i) =&gt; {  var value = comMap. get(i);  value -= 1;  if (value === 0 ) {   comMap. delete(i);  }  else {   comMap. set(i, value);  } }) for(let key of comMap. keys()) {  answer = key; } return answer;} 12345672. 객체를 사용하는 방법이다. ```javascriptfunction solution(participant, completion) { return participant. find( i =&gt; !completion[i]--, completion. map( i=&gt; completion[i] = (completion[i]|0)+1));}하나씩 이해해보자. 전체적인 매커니즘은 다음과 같다. completion에 배열의 값을 프로퍼티로 하는 key, 해당 멤버의 값을 value로 하여 값을 추가한다. participant의 값을 통해 completion 프로퍼티로 조사하여 value를 줄여가며, 해당 프로퍼티의 value의 값이 =&lt; 0 또는 undefine 값을 찾아내는 것이다.  arr. map()  map을 통해 completion의 배열 값으로 하는 프로퍼티를 생성하며, 해당 프로퍼티의 값을 0과 or 처리 함으로써 값의 존재유무를 판단한다. (없다면 undefined|0 ==&gt; 0, 있다면 숫자|0 ==&gt; 숫자 Wow!) arr. find(callback[, thisArg])  제한조건상 1개만이 return 값이기 때문에 find 사용. reduce로 대체 가능  callback 함수에 thisArg값으로 1번에서 만든 값을 넣어 줌으로써 하나씩 찾아보도록 한다.  정확환 순서는 (!completion[i]) 값을 찾고 해당값을 – 하고 넘겨준다. map과 객체리터럴이 꽤 강력함을 여기서 확인한다. 또 함수형 프로그래밍으로 매개변수만 받도록 하면 아래와 같다. 1var solution=(_,$)=&gt;_. find(_=&gt;!$[_]--,$. map(_=&gt;$[_]=($[_]|0)+1))!? "
    }, {
    "id": 221,
    "url": "/study_CODE_hash_1/",
    "title": "해시 : 소수 찾기",
    "body": "2020/06/21 - 문제 설명한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다. 각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요. 입출력 예 | n | result | | — | — | | “17” | 3 | | “011” | 2 | 문제풀이전체 순열 조합을 구하고, 그 중 primeNumber를 걸러낸다. 그 개수가 정답. 1234567891011121314151617181920212223242526272829303132333435363738function solution(numbers) {  const numberList = numbers. split('');  const findPrimeNumbers = (stringList, prevNumber) =&gt; {    const caliPrevNumber = prevNumber || '';    return stringList. reduce((list, value, idx) =&gt; {      if (isPrimeNumber(Number(caliPrevNumber + value))) {        list. push(Number(caliPrevNumber + value));      }      const nextList = [. . . stringList];      nextList. splice(idx, 1);      const result = findPrimeNumbers(      nextList,      caliPrevNumber + value,      );      list. push(. . . result);      return list;    }, []);  }  const answers = findPrimeNumbers(numberList);  return [. . . new Set(answers)]. length; //중복값 제거. }function isPrimeNumber(number) {  const notPrime = [0, 1];  if (notPrime. includes(number)) return false;  for (let i = 2; i * i &lt;= number; i++) {    if (number % i === 0) return false;  }  return true;}"
    }, {
    "id": 222,
    "url": "/study_CODE_Graph_1/",
    "title": "그래프 : 가장 먼 노드",
    "body": "2020/06/20 - 문제설명n개의 노드가 있는 그래프가 있습니다. 각 노드는 1부터 n까지 번호가 적혀있습니다. 1번 노드에서 가장 멀리 떨어진 노드의 갯수를 구하려고 합니다. 가장 멀리 떨어진 노드란 최단경로로 이동했을 때 간선의 개수가 가장 많은 노드들을 의미합니다. 노드의 개수 n, 간선에 대한 정보가 담긴 2차원 배열 vertex가 매개변수로  주어질 때, 1번 노드로부터 가장 멀리 떨어진 노드가 몇 개인지를 return 하도록 solution 함수를 작성해주세요. 제한사항  - 노드의 개수 n은 2 이상 20,000 이하입니다.   - 간선은 양방향이며 총 1개 이상 50,000개 이하의 간선이 있습니다.   - vertex 배열 각 행 [a, b]는 a번 노드와 b번 노드 사이에 간선이 있다는 의미입니다.       Vertex   Edge   return         6   [[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]]   3   풀이우선 V,E 를 그래프를 표현한다.  행렬과 리스트 둘다 가능하나, 여기선 리스트로 만든다. 1234567var v = 6;var edge = [[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]];const arr = Array(+1). fill(null). map(() =&gt; Array());for(let i of edge) {    arr[i[0]]. push(i[1]);    arr[i[1]]. push(i[0]);  }해당 그래프를 BFS 또는 DFS를 통해 순회를 할 수 있는데, 여기선 노드간 거리를 측정하므로 BFS를 이용한다. Queue를 이용해 순회를 하며 해당 거리를 추가로 입력해준다. 1234567891011121314151617const queue = [[1,0]]; //Node, Distanceconst dist = []; //Node 별 Distance 값 저장. function inputQueue(i, weight) { const arrLeng = arr[i]. length; for(let j=0; j&lt;arrLeng; j++) {  const num = arr[i]. shift();  queue. push([num, weight]);  for(let k=1; k&lt;=n; k++) {   const index = arr[k]. indexOf(num);  if(index != -1)    arr[k]. splice(index, 1);  } }}그렇게 되면 Max 거리를 알수 있게 되며, max거리를 가진 값의 개수만 return해주면 된다. 1234567891011121314151617181920212223inputQueue(1, 1); while(queue. length &gt; 0) {  const shifted = queue. shift();  if(dist[shifted[0]] == null || dist[shifted[0]]&gt;shifted[1])   dist[shifted[0]] = shifted[1];  inputQueue(shifted[0], dist[shifted[0]]+1); } let max = 0; let answer = 0; for(let i=1; i&lt;=n; i++) {   if(dist[i]&gt;max) {     max = dist[i];     answer = 1;   } else if(dist[i] == max) {     answer++;   } }  return answer;해결 Point: 그래프 표현으로 전환 -&gt; BFS 순회하며 거리측정 -&gt; Max 거리 count "
    }, {
    "id": 223,
    "url": "/study_Programming_Graph-BFS,DFS/",
    "title": "Graph [BFS, DFS]",
    "body": "2020/06/20 - Graph [DFS, BFS]자바 스크립트를 이용한 개념 구현 Graph: 위와 같은 Graph를 구현해 보자.       Vertex   Edge         8   [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [5, 8], [6, 8], [7, 8]]    Vertex는 1부터 n까지 이며, Weight가 없는 경우1234567 var edge = [[1, 2], [1, 3], [2, 4], [2, 5], [3, 6], [3, 7], [4, 8], [5, 8], [6, 8], [7, 8]]; var v = 8; const arr = Array(v+1). fill(null). map(() =&gt; Array()); for(let i of edge) {  arr[i[0]]. push(i[1]);  arr[i[1]]. push(i[0]); } Vertex, Edge, Weight 전체 관리123456789101112131415class UndirectGraph { edge = {}; addVertex(vertex) {  this. edge[vertex] = {}; } addEdge(vertex1, vertex2, weight) {  this. edge[vertex1][vertex2] = weight;  this. edge[vertex2][vertex1] = weight; }}const graph = new UndirectGraph();graph. addVertex(1);graph. addVertex(2);graph. addEdge(1, 2, 5);그래프를 구현하였으니 이제 DFS와 BFS를 이용해 탐색을 해보자. ## DFS  노드를 설정한 방향대로 끝까지 간 뒤 가장 최근으로 backtacking을 진행하여 해당 방향 끝까지 보내며 전체 탐색을 하는 방법 재귀 호출 방법과 스택을 사용한 방법이 있다. 1→2→4→8→5→(8)→6→3→(6)→(8)→7→(8)→(4)→(2)→(1)  재귀1234567891011121314151617const graph = (arr, start) =&gt; {  let visited = new Array(arr. length). fill(false);  const recDFS = (idx) =&gt; {     visited[idx] = true;    console. log(idx +    );    arr[idx]. forEach( i =&gt; {      if(visited[i] == false) {        recDFS(i);      }    })        return;  }  return recDFS(start); // idx start 부터 시작}graph(arr,1); 스택12345678910111213141516171819202122232425262728293031323334353637383940414243444546const graph = (arr, start) =&gt; {    class Stack {    constructor() {     this. _arr = [];    }    push(item) {     this. _arr. push(item);    }    pop() {     return this. _arr. pop();    }    peek() {     return this. _arr[this. _arr. length - 1];    }  }  const stack = new Stack();  let visited = new Array(arr. length). fill(false);  const recDFS = (idx) =&gt; {     stack. push(idx);    let flag;    visited[idx] = true;    console. log(idx);    let value = stack. peek();    while(!(value === undefined)) {      flag = false;      for( i of arr[value]) {        if(visited[i] === false) {          stack. push(i);          console. log(i);          visited[i] = true;          flag = true;          break;        }      }      if(!flag) {        stack. pop();      }      value = stack. peek();    }    return;  }  return recDFS(start); // idx start 부터 시작}BFS:  한 노드에 연결된 노드를 전체 탐색한 뒤 설정한 방향대로 차례로 진행하며 전체를 탐색 하는 방법 큐를 사용한다. 1→(1)→2→3→(2)→4→5→(3)→6→7→(4)→8→(5)→(6)→(7)→(8) 1234567891011121314151617181920212223242526272829303132333435363738394041424344const graph = (arr, start) =&gt; {    class Queue {    constructor() {     this. _arr = [];    }    enqueue(item) {     this. _arr. push(item);    }    dequeue() {     return this. _arr. shift();    }    peek() {      return this. _arr[0];    }  }  const queue = new Queue();  let visited = new Array(arr. length). fill(false);  const recBFS = (idx) =&gt; {     queue. enqueue(idx);    let flag;    visited[idx] = true;    console. log(idx);    let value = queue. peek();    while(!(value === undefined)) {      flag = false;      for( i of arr[value]) {        if(visited[i] === false) {          queue. enqueue(i);          console. log(i);          visited[i] = true;          flag = true;        }      }      if(!flag) {        queue. dequeue();      }      value = queue. peek();    }    return;  }  return recBFS(start); // idx start 부터 시작}DFS, BFS의 컨셉을 이용해 문제를 해결해야 하는 것들이 있음을 인지하자. "
    }, {
    "id": 224,
    "url": "/study_CODE_design_1/",
    "title": "설계 : 기둥과 보 설치",
    "body": "2020/06/19 - category: 2020 KAKAO BLIND RECRUITMENT 문제 설명빙하가 깨지면서 스노우타운에 떠내려 온 죠르디는 인생 2막을 위해 주택 건축사업에 뛰어들기로 결심하였습니다. 죠르디는 기둥과 보를 이용하여 벽면 구조물을 자동으로 세우는 로봇을 개발할 계획인데, 그에 앞서 로봇의 동작을 시뮬레이션 할 수 있는 프로그램을 만들고 있습니다. 프로그램은 2차원 가상 벽면에 기둥과 보를 이용한 구조물을 설치할 수 있는데, 기둥과 보는 길이가 1인 선분으로 표현되며 다음과 같은 규칙을 가지고 있습니다. 기둥은 바닥 위에 있거나 보의 한쪽 끝 부분 위에 있거나, 또는 다른 기둥 위에 있어야 합니다. 보는 한쪽 끝 부분이 기둥 위에 있거나, 또는 양쪽 끝 부분이 다른 보와 동시에 연결되어 있어야 합니다. 단, 바닥은 벽면의 맨 아래 지면을 말합니다. 2차원 벽면은 n x n 크기 정사각 격자 형태이며, 각 격자는 1 x 1 크기입니다. 맨 처음 벽면은 비어있는 상태입니다. 기둥과 보는 격자선의 교차점에 걸치지 않고, 격자 칸의 각 변에 정확히 일치하도록 설치할 수 있습니다. 예를 들어, 다음 순서에 따라 구조물을 만들었습니다. (1, 0)에서 위쪽으로 기둥을 하나 설치 후, (1, 1)에서 오른쪽으로 보를 하나 만듭니다. (2, 1)에서 위쪽으로 기둥을 하나 설치 후, (2, 2)에서 오른쪽으로 보를 하나 만듭니다. (5, 0)에서 위쪽으로 기둥을 하나 설치 후, (5, 1)에서 위쪽으로 기둥을 하나 더 설치합니다. (4, 2)에서 오른쪽으로 보를 설치 후, (3, 2)에서 오른쪽으로 보를 설치합니다. 만약 (4, 2)에서 오른쪽으로 보를 먼저 설치하지 않고, (3, 2)에서 오른쪽으로 보를 설치하려 한다면 2번 규칙에 맞지 않으므로 설치가 되지 않습니다. 기둥과 보를 삭제하는 기능도 있는데 기둥과 보를 삭제한 후에 남은 기둥과 보들 또한 위 규칙을 만족해야 합니다. 만약, 작업을 수행한 결과가 조건을 만족하지 않는다면 해당 작업은 무시됩니다. 벽면의 크기 n, 기둥과 보를 설치하거나 삭제하는 작업이 순서대로 담긴 2차원 배열 build_frame이 매개변수로 주어질 때, 모든 명령어를 수행한 후 구조물의 상태를 return 하도록 solution 함수를 완성해주세요.  제한사항 n은 5 이상 100 이하인 자연수입니다.  build_frame의 세로(행) 길이는 1 이상 1,000 이하입니다.  build_frame의 가로(열) 길이는 4입니다.  build_frame의 원소는 [x, y, a, b]형태입니다.  x, y는 기둥, 보를 설치 또는 삭제할 교차점의 좌표이며, [가로 좌표, 세로 좌표] 형태입니다.  a는 설치 또는 삭제할 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다.  b는 구조물을 설치할 지, 혹은 삭제할 지를 나타내며 0은 삭제, 1은 설치를 나타냅니다.  벽면을 벗어나게 기둥, 보를 설치하는 경우는 없습니다.  바닥에 보를 설치 하는 경우는 없습니다.  구조물은 교차점 좌표를 기준으로 보는 오른쪽, 기둥은 위쪽 방향으로 설치 또는 삭제합니다.  구조물이 겹치도록 설치하는 경우와, 없는 구조물을 삭제하는 경우는 입력으로 주어지지 않습니다.  최종 구조물의 상태는 아래 규칙에 맞춰 return 해주세요.  return 하는 배열은 가로(열) 길이가 3인 2차원 배열로, 각 구조물의 좌표를 담고있어야 합니다.  return 하는 배열의 원소는 [x, y, a] 형식입니다.  x, y는 기둥, 보의 교차점 좌표이며, [가로 좌표, 세로 좌표] 형태입니다.  기둥, 보는 교차점 좌표를 기준으로 오른쪽, 또는 위쪽 방향으로 설치되어 있음을 나타냅니다.  a는 구조물의 종류를 나타내며, 0은 기둥, 1은 보를 나타냅니다.  return 하는 배열은 x좌표 기준으로 오름차순 정렬하며, x좌표가 같을 경우 y좌표 기준으로 오름차순 정렬해주세요.    x, y좌표가 모두 같은 경우 기둥이 보보다 앞에 오면 됩니다.   입출력 예 | n | build_frame | result | | 5 | [[1,0,0,1],[1,1,1,1],[2,1,0,1],[2,2,1,1],[5,0,0,1],[5,1,0,1],[4,2,1,1],[3,2,1,1]] | [[1,0,0],[1,1,1],[2,1,0],[2,2,1],[3,2,1],[4,2,1],[5,0,0],[5,1,0]] | | 5 | [[0,0,0,1],[2,0,0,1],[4,0,0,1],[0,1,1,1],[1,1,1,1],[2,1,1,1],[3,1,1,1],[2,0,0,0],[1,1,1,0],[2,2,0,1]] | [[0,0,0],[0,1,1],[1,1,1],[2,1,1],[3,1,1],[4,0,0]] |문제풀이주어진 조건에 맞춰 설계를 할수 있느냐 문제이다. 이 문제는 생각보다 간단했는데, 정답률이 낮은 이유는 아마도 시간이 부족해서 일 것 이다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129function solution(n, build_frame) { var build = []; //debugger; build_frame. forEach(i =&gt; {  if (i[3]) {   if (canBuild(i, build, n)) {     i. pop()    build. push(i);   }  } else {   if (canDelete(i, build, n)) {    i. pop();    var deleteBuild = build. filter(_ =&gt; !(_[0] === i[0] &amp;&amp; _[1] === i[1] &amp;&amp; _[2] === i[2]));    build = deleteBuild;   }  } }) var answer = build. sort( (a,b) =&gt; {  if(a[0] === b[0]) {    if(a[1] === b[1]) {      return a[2]-b[2];    } else {      return a[1]-b[1];    }  } else {    return a[0] - b[0];  }}); if(answer == 0) {  return [[]]; } else {  return answer; }}function canBuild( data, build, n ) { if(data[2]) {  if(data[0]&lt;0 || data[0]&gt;=n) {   return false;  }  if(data[1]&lt;=0 || data[1]&gt;n) {   return false;  }  return checkBeam(data, build); } else {  if(data[0]&lt;0 || data[0]&gt;n) {   return false;  }  if(data[1]&lt;0 || data[1]&gt;=n) {   return false;  }  return checkPillar(data, build); }}function checkPillar (data, build) { if(data[1] === 0){  return true; } else if(build. filter( i =&gt; i[0] === data[0] &amp;&amp; i[1] === data[1]-1 &amp;&amp; i[2] === 0 ) != 0){  return true; } else if(build. filter( i =&gt; (i[0] === data[0] || i[0] === data[0]-1) &amp;&amp; i[1] === data[1] &amp;&amp; i[2] === 1 ) != 0){  return true; }  else {  return false; }}function checkBeam (data, build) { if(build. filter( i =&gt; (i[0] === data[0] || i[0] === data[0]+1) &amp;&amp; i[1] === data[1]-1 &amp;&amp; i[2] === 0 ) != 0) {  return true; } else if( build. filter( i =&gt; i[0] === data[0]-1 &amp;&amp; i[1] === data[1] &amp;&amp; i[2] === 1) != 0 &amp;&amp;  build. filter( j =&gt; j[0] === data[0]+1 &amp;&amp; j[1] === data[1] &amp;&amp; j[2] === 1 ) != 0) {  return true; }  else {  return false; }}function canDelete( data, build, n) { var testBuild = build. filter( i =&gt; !(i[0] === data[0] &amp;&amp; i[1] === data[1] &amp;&amp; i[2] === data[2])); var testData = []; var isData = generateData(data, n); // 삭제하고자 할때, 영향을 받는 값들은 build안에 있는 값들이니 다시 filter! isData. forEach( j =&gt; {  var item = testBuild. filter( k =&gt; k[0] === j[0] &amp;&amp; k[1] === j[1] &amp;&amp; k[2] === j[2] );  if(item != 0) {   testData. push(item[0]);  } }) for(let j=0, len = testData. length; j&lt;len; j++) {  if(testData[j][2]) {   if(!checkBeam(testData[j], testBuild)) {    return false;   }  } else {   if(!checkPillar(testData[j], testBuild)) {    return false;   }  } } return true;}function generateData(data, n) { var result = []; if(data[2]) { //지우고자 하는 값이 보  result. push([data[0]-1,data[1], 1, 1]); //보  result. push([data[0]+1,data[1], 1, 1]); //보  result. push([data[0],data[1], 0, 1]); //기둥  result. push([data[0]+1,data[1], 0, 1]); //기둥 } else { //지우고자 하는 값이 기둥  result. push([data[0],data[1]+1, 1, 1]); //보  result. push([data[0]-1,data[1]+1, 1, 1]); //보  result. push([data[0],data[1]+1, 0, 1]); //기둥 } return result. filter(i =&gt; 0&lt;=i[0] &amp;&amp; i[0]&lt;=n &amp;&amp; 0&lt;=i[1] &amp;&amp; i[1] &lt;= n); //여기서 마지막 값 을 n이 아닌 다른 숫자를 입력해서 테스트 코드에선 맞았는데, 제출한 결과 맞지 않았다. 이런 실수는 다시는 없어야 한다. !!}"
    }, {
    "id": 225,
    "url": "/study_CODE_combination_1/",
    "title": "Combination : 불량 사용자",
    "body": "2020/06/18 - category: 2019 카카오 개발자 겨울 인턴십 문제 설명개발팀 내에서 이벤트 개발을 담당하고 있는 무지는 최근 진행된 카카오이모티콘 이벤트에 비정상적인 방법으로 당첨을 시도한 응모자들을 발견하였습니다. 이런 응모자들을 따로 모아 불량 사용자라는 이름으로 목록을 만들어서 당첨 처리 시 제외하도록 이벤트 당첨자 담당자인 프로도 에게 전달하려고 합니다. 이 때 개인정보 보호을 위해 사용자 아이디 중 일부 문자를 ‘’ 문자로 가려서 전달했습니다. 가리고자 하는 문자 하나에 ‘’ 문자 하나를 사용하였고 아이디 당 최소 하나 이상의 ‘*’ 문자를 사용하였습니다. 무지와 프로도는 불량 사용자 목록에 매핑된 응모자 아이디를 제재 아이디 라고 부르기로 하였습니다. 예를 들어, 이벤트에 응모한 전체 사용자 아이디 목록이 다음과 같다면 응모자 아이디frodofradicrodoabc123frodoc 다음과 같이 불량 사용자 아이디 목록이 전달된 경우, 불량 사용자frdabc1** 불량 사용자에 매핑되어 당첨에서 제외되어야 야 할 제재 아이디 목록은 다음과 같이 두 가지 경우가 있을 수 있습니다. 제재 아이디frodoabc123 제재 아이디fradiabc123 이벤트 응모자 아이디 목록이 담긴 배열 user_id와 불량 사용자 아이디 목록이 담긴 배열 banned_id가 매개변수로 주어질 때, 당첨에서 제외되어야 할 제재 아이디 목록은 몇가지 경우의 수가 가능한 지 return 하도록 solution 함수를 완성해주세요.  제한사항     user_id 배열의 크기는 1 이상 8 이하입니다.    user_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다.    응모한 사용자 아이디들은 서로 중복되지 않습니다.    응모한 사용자 아이디는 알파벳 소문자와 숫자로만으로 구성되어 있습니다.    banned_id 배열의 크기는 1 이상 user_id 배열의 크기 이하입니다.    banned_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다.    불량 사용자 아이디는 알파벳 소문자와 숫자, 가리기 위한 문자 ‘*’ 로만 이루어져 있습니다.    불량 사용자 아이디는 ‘*’ 문자를 하나 이상 포함하고 있습니다.    불량 사용자 아이디 하나는 응모자 아이디 중 하나에 해당하고 같은 응모자 아이디가 중복해서 제재 아이디 목록에 들어가는 경우는 없습니다.    제재 아이디 목록들을 구했을 때 아이디들이 나열된 순서와 관계없이 아이디 목록의 내용이 동일하다면 같은 것으로 처리하여 하나로 세면 됩니다.    123456var user_id = [ frodo ,  fradi ,  crodo ,  abc123 ,  frodoc ];//var banned_id = [ fr*d* ,  abc1** ]; // result : 2var banned_id = [ *rodo ,  *rodo ,  ****** ]; // result : 2//var banned_id = [ fr*d* ,  *rodo ,  ****** ,  ****** ]; //result : 3문제풀이종속적인 두 배열간 조합문제이다. 우선 ban id에 존재하거나, 사용하지 않았다면 picked 배열에 집어넣어 다음 find를 구성하도록 하고 다시 빼낸다음에 나머지 for문을 돌게 하는 방식 banned_id로 인해 종속적인 배열들이 생성될수 있는데,  하나의 배열로 조합을 구성하면서 banned_id 조건을 추가해 주는 방식으로 해결했다. 또한 문자열 배열이지만 간단한 계산을 위해 문자의 index를 값으로 하는 배열로 구성해야 한다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function solution(user_id, banned_id) {  var answer = 0;  const picked = [];  let len = banned_id. length;  const banSets = new Set();  const usedFlag = new Array(user_id. length). fill(false);  function find(picked, banId) {    if(picked. length === len) {      const usedId = [];      picked. forEach( item =&gt; {        usedId. push(item);      })      banSets. add(usedId. sort(). join(''));      return;    } else {      for(let i=0; i&lt;user_id. length; i++) {        if(!usedFlag[i] &amp;&amp; banCompare(user_id[i], banned_id[banId])) {          picked. push(i);          usedFlag[i] = true;          find(picked, banId+1);          //↓↓↓ for문이 돌기 때문에 안뽑은 것을 돌게한다.           picked. pop();          usedFlag[i] = false;        }      }    }  }  find(picked, 0);  return banSets. size;}function banCompare(id, ban) {  var check = (userId, banId) =&gt; {    return userId. reduce((check, cur, idx) =&gt; {      if (cur === banId[idx]) {        check += cur;      } else {        check += '*';      }      return check;    }, '');  }  return check(id. split(''), ban) === ban;}다른 풀이위에선 중속적인 배열 생성 조건을 유지한 채 풀었다면,  배열을 만들어 준 뒤, 조합 문제를 해결하는 방법이다. 12345678910111213141516171819202122232425262728293031323334353637383940414243var u_id = [ frodo ,  fradi ,  crodo ,  abc123 ,  frodoc ];//var b_id = [ fr*d* ,  abc1** ];var b_id = [ *rodo ,  *rodo ,  ****** ];//var b_id = [ fr*d* ,  *rodo ,  ****** ,  ****** ];var test = solution(u_id, b_id);function solution(user_id, banned_id) {  const candidates = [];  const answer = {};  banned_id. forEach(ban =&gt; {    const candidate = [];    user_id. forEach((id, i) =&gt; {      if (comp(ban, id)) candidate. push(i);    });    candidates. push(candidate);  });  function f(i = 0, selected = []) {    if (!candidates[i]) {      selected. sort();      answer[selected. join('')] = true;      return;    }    candidates[i]. filter(e =&gt; !selected. includes(e)). forEach(e =&gt; {      f(i + 1, selected. concat([e]));    });  }    f();  debugger;  return Object. keys(answer). length;}function comp(ban, id) {  if (id. length !== ban. length) return false;  for (let i = 0; i &lt; ban. length; i++) {    if (ban[i] === '*') continue;    if (ban[i] !== id[i]) return false;  }  return true;}"
    }, {
    "id": 226,
    "url": "/study_CODE_bruteForce_4/",
    "title": "완전탐색 : 괄호 변환",
    "body": "2020/06/18 - category: 2020 KAKAO BLIND RECRUITMENT 문제 설명고고학자인 튜브는 고대 유적지에서 보물과 유적이 가득할 것으로 추정되는 비밀의 문을 발견하였습니다. 그런데 문을 열려고 살펴보니 특이한 형태의 자물쇠로 잠겨 있었고 문 앞에는 특이한 형태의 열쇠와 함께 자물쇠를 푸는 방법에 대해 다음과 같이 설명해 주는 종이가 발견되었습니다. 잠겨있는 자물쇠는 격자 한 칸의 크기가 1 x 1인 N x N 크기의 정사각 격자 형태이고 특이한 모양의 열쇠는 M x M 크기인 정사각 격자 형태로 되어 있습니다. 자물쇠에는 홈이 파여 있고 열쇠 또한 홈과 돌기 부분이 있습니다. 열쇠는 회전과 이동이 가능하며 열쇠의 돌기 부분을 자물쇠의 홈 부분에 딱 맞게 채우면 자물쇠가 열리게 되는 구조입니다. 자물쇠 영역을 벗어난 부분에 있는 열쇠의 홈과 돌기는 자물쇠를 여는 데 영향을 주지 않지만, 자물쇠 영역 내에서는 열쇠의 돌기 부분과 자물쇠의 홈 부분이 정확히 일치해야 하며 열쇠의 돌기와 자물쇠의 돌기가 만나서는 안됩니다. 또한 자물쇠의 모든 홈을 채워 비어있는 곳이 없어야 자물쇠를 열 수 있습니다. 열쇠를 나타내는 2차원 배열 key와 자물쇠를 나타내는 2차원 배열 lock이 매개변수로 주어질 때, 열쇠로 자물쇠를 열수 있으면 true를, 열 수 없으면 false를 return 하도록 solution 함수를 완성해주세요.  제한사항     key는 M x M(3 ≤ M ≤ 20, M은 자연수)크기 2차원 배열입니다.    lock은 N x N(3 ≤ N ≤ 20, N은 자연수)크기 2차원 배열입니다.    M은 항상 N 이하입니다.    key와 lock의 원소는 0 또는 1로 이루어져 있습니다.    0은 홈 부분, 1은 돌기 부분을 나타냅니다.     입출력 예 | key | lock | result | | [[0, 0, 0], [1, 0, 0], [0, 1, 1]] | [[1, 1, 1], [1, 1, 0], [1, 0, 1]] | true |문제풀이문제는 배열을 이용한 작업을 할수 있느냐는 문제이다. 보통 이런 문제는 완전 탐색으로 자주 나오는 것 같다. 배열을 잘 사용할수 있는지 확인하는 차원에서 전체를 검색하도록 말이다.  고민하기 까지 상당한 시간이 걸렸는데, 자바스크립트는 각 값이 연결되어 있어서, 자바와는 다르게 독립적으로 값을 변경하면서 다룰수가 없었다. 그래서 객체를 이용했다.  key를 나타내는 객체와 lock에서 비어있는 곳을 나타내는 객체를 만든 뒤, key의 움직임에 따라 lock과 일치할 경우 해결되도록 구현하였다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102function solution(key, lock) {  const keyLen = key. length;  const lockLen = lock. length;  let lockPosition = makePosition(lock, 0); //처음엔 lock은 그냥 배열로 해결하려고 했는데, 배열 값을 따로 받아서 바꾸려니 값이 이어져서 바뀌어 버려서 그냥 이것 또한 객체로 만들었다.   let rotatedKey = rotation(key);  let rotatedKeyPosition;  for(let i=0; i&lt;4; i++) { // 마지막으로 헤멘 포인트, 한번 돌려주면 끝나는게 아니라 네번 모두 돌려줘야 한다. 생각해 보면 당연하다.     rotatedKey = rotation(rotatedKey);    rotatedKeyPosition = makePosition(rotatedKey, 1);        if(moveMatchKey(rotatedKeyPosition, lockPosition, keyLen, lockLen)) {      return true;    }  }  return false;}function moveMatchKey(keyPosition, lockPosition, keyLen, lockLen) { //position으로 받아오니 key의 size와 lock의 size가 필요해졌다.   let checkCount = lockPosition. length;  let count;  for (let i = -keyLen + 1; i &lt; lockLen; i++) { //움직일수 있는 거리를 설정함. (key size)    for (let j = -keyLen + 1; j &lt; lockLen; j++) {      count = 0;      var caliPositionSet = [];      keyPosition. forEach(k =&gt; {        var position = {};        var caliPositionX = k. x + i;        var caliPositionY = k. y + j;        if (validation(caliPositionX, lockLen) &amp;&amp; validation(caliPositionY, lockLen)) { //lockSize 안에 들어와야 하므로 lockSize가 필요          position. x = caliPositionX;          position. y = caliPositionY;          caliPositionSet. push(position);          count++;        }      })      if (checkCount === count) {        if(checkOkay(caliPositionSet, lockPosition)) {          return true;        }      }    }  }  return false;}function validation(point, pivotSize) {  if(point&lt;0 || point&gt;=pivotSize){    return false;  }  if(point&gt;=pivotSize){    return false;  }  return true;} function checkOkay(moveKey, lock) {  var len = lock. length;  for (let i = 0; i &lt; len; i++) {    if(moveKey[i]. x !== lock[i]. x || moveKey[i]. y !== lock[i]. y) { //완벽히 같아야 인정      return false;    }   }  return true;}function rotation(key) {  if(key. length === 1) {    return key;  }  let result = [];  for(let i=key. length-1; i&gt;=0; i--) {    result = key[i]. map( (_, $) =&gt; [. . . (result[$] || []), key[i][$]]); //잘쓰이는 rotation  }  return result; }function makePosition(item, keyOrLock) {  var positionSet = [];  if(item. length ===1) {    var position = {};    position. x =0;    position. y =0;    positionSet. push(position);    return positionSet;  }  item. forEach( (i, rowIdx) =&gt; {    i. forEach( (j, colIdx) =&gt; {      var position = {};      if(j===keyOrLock) {        position. x =rowIdx;        position. y =colIdx;        positionSet. push(position);      }    })  })  return positionSet;}"
    }, {
    "id": 227,
    "url": "/study_CODE_bruteForce_3/",
    "title": "완전탐색 : 문자열 압축",
    "body": "2020/06/17 - category: 2020 KAKAO BLIND RECRUITMENT 문제 설명데이터 처리 전문가가 되고 싶은 어피치는 문자열을 압축하는 방법에 대해 공부를 하고 있습니다. 최근에 대량의 데이터 처리를 위한 간단한 비손실 압축 방법에 대해 공부를 하고 있는데, 문자열에서 같은 값이 연속해서 나타나는 것을 그 문자의 개수와 반복되는 값으로 표현하여 더 짧은 문자열로 줄여서 표현하는 알고리즘을 공부하고 있습니다. 간단한 예로 aabbaccc의 경우 2a2ba3c(문자가 반복되지 않아 한번만 나타난 경우 1은 생략함)와 같이 표현할 수 있는데, 이러한 방식은 반복되는 문자가 적은 경우 압축률이 낮다는 단점이 있습니다. 예를 들면, abcabcdede와 같은 문자열은 전혀 압축되지 않습니다. 어피치는 이러한 단점을 해결하기 위해 문자열을 1개 이상의 단위로 잘라서 압축하여 더 짧은 문자열로 표현할 수 있는지 방법을 찾아보려고 합니다. 예를 들어, ababcdcdababcdcd의 경우 문자를 1개 단위로 자르면 전혀 압축되지 않지만, 2개 단위로 잘라서 압축한다면 2ab2cd2ab2cd로 표현할 수 있습니다. 다른 방법으로 8개 단위로 잘라서 압축한다면 2ababcdcd로 표현할 수 있으며, 이때가 가장 짧게 압축하여 표현할 수 있는 방법입니다. 다른 예로, abcabcdede와 같은 경우, 문자를 2개 단위로 잘라서 압축하면 abcabc2de가 되지만, 3개 단위로 자른다면 2abcdede가 되어 3개 단위가 가장 짧은 압축 방법이 됩니다. 이때 3개 단위로 자르고 마지막에 남는 문자열은 그대로 붙여주면 됩니다. 압축할 문자열 s가 매개변수로 주어질 때, 위에 설명한 방법으로 1개 이상 단위로 문자열을 잘라 압축하여 표현한 문자열 중 가장 짧은 것의 길이를 return 하도록 solution 함수를 완성해주세요.  제한사항 s의 길이는 1 이상 1,000 이하입니다.    s는 알파벳 소문자로만 이루어져 있습니다.   입출력 예 | s | result | | “aabbaccc” | 7 | | “ababcdcdababcdcd” | 9 | | “abcabcdede” | 8 | | “abcabcabcabcdededededede” | 14 | | “xababcdcdababcdcd” | 17 |문제풀이문자열을 비교한 뒤 압축 여부를 판단하고, 가능 하다면 압축 뒤 결과 글자를 비교하여 가장 작은 값을 return 하면 된다. 압축 여부를 판단하는 것이 중요한데, 압축은 모두 동일하게 적용되어야 하며, 제일 앞에서 부터 차례로 적용된다.  즉, 문자열을 일정한 기준으로 자르고, 앞문자와 뒷문자를 비교하여 같으면 압축을 할수 있다는 의미이다. 압축은 문자열의 1/2부터 가능하며, 모든 값을 해 본 뒤 가장 작은 값을 구하는 방법으로 진행하였다. 정답률 25. 9%가 level 2 라니. . 이상하다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function solution(s) {  let answer = 0;  let strLen = s. length; //여러번 쓰이기 때문에 글자수 길이를 따로 저장해준다.   if(strLen == 1) { //중복 길이를 제외    return 1;  }  for (let i = 1, len = parseInt(strLen / 2); i &lt;= len; i++) {     let zipSet = makeZip(s, i);    let restCharNum = strLen - zipSet. reduce((num, cur) =&gt; {      num += cur * i;      return num;    }, 0);    let zipCharNum = restCharNum + zipSet. map(i =&gt; i + ''). reduce((num, cur) =&gt; {      num += cur. length + i; //여기서 만일 압축숫자가 단위수가 증가하면 그만큼 글자수도 증가한다는것을 놓쳐서 꽤 많애 헤멨다. 단순한걸 놓치면 답을 찾기가 어렵다.       return num;    }, 0)    if (answer === 0) {      answer = zipCharNum;    } else if (answer &gt; zipCharNum) {      answer = zipCharNum;    }  }  return answer;}function makeZip(str, sliceNum) {  let len = Math. ceil(str. length / sliceNum);  let start = 0;  let target;  let prevTarget = -1;  let strCount = 0;  let strFlag = []; //처음엔 맵으로 저장을 했는데, 규칙상 바로 오지않으면 압축이 되지 않는다는 것을 이해하지 못했다. 처음 헤멘 포인트.   let flag = false;  let sliceStr = str;  while (start &lt; len) {    prevTarget = target;    target = sliceStr. substring(0, sliceNum);    if (target. length &lt; sliceNum) {      break;    }    if (prevTarget === target) {      if (flag) {        strFlag. push(2)        strCount++;        flag = false;      } else {        strFlag[strCount - 1]++;      }    } else {      flag = true;    }    sliceStr = sliceStr. slice(sliceNum);    start++;  }  return strFlag;}"
    }, {
    "id": 228,
    "url": "/study_CODE_bruteForce_2/",
    "title": "완전탐색 : 소수 찾기",
    "body": "2020/06/16 - 문제 설명한자리 숫자가 적힌 종이 조각이 흩어져있습니다. 흩어진 종이 조각을 붙여 소수를 몇 개 만들 수 있는지 알아내려 합니다. 각 종이 조각에 적힌 숫자가 적힌 문자열 numbers가 주어졌을 때, 종이 조각으로 만들 수 있는 소수가 몇 개인지 return 하도록 solution 함수를 완성해주세요.  제한 조건     numbers는 길이 1 이상 7 이하인 문자열입니다.    numbers는 0~9까지 숫자만으로 이루어져 있습니다.    013은 0, 1, 3 숫자가 적힌 종이 조각이 흩어져있다는 의미입니다.    입출력 예 | participant | return | | “17” | 3 | | “011” | 2 | 문제풀이완전히 Combination 문제이다. "
    }, {
    "id": 229,
    "url": "/study_CODE_bruteForce_1/",
    "title": "완전탐색 : 모의고사",
    "body": "2020/06/16 - 문제 설명수포자는 수학을 포기한 사람의 준말입니다. 수포자 삼인방은 모의고사에 수학 문제를 전부 찍으려 합니다. 수포자는 1번 문제부터 마지막 문제까지 다음과 같이 찍습니다. 1번 수포자가 찍는 방식: 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, … 2번 수포자가 찍는 방식: 2, 1, 2, 3, 2, 4, 2, 5, 2, 1, 2, 3, 2, 4, 2, 5, … 3번 수포자가 찍는 방식: 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, 3, 3, 1, 1, 2, 2, 4, 4, 5, 5, … 1번 문제부터 마지막 문제까지의 정답이 순서대로 들은 배열 answers가 주어졌을 때, 가장 많은 문제를 맞힌 사람이 누구인지 배열에 담아 return 하도록 solution 함수를 작성해주세요.  제한 조건     시험은 최대 10,000 문제로 구성되어있습니다.    문제의 정답은 1, 2, 3, 4, 5중 하나입니다.    가장 높은 점수를 받은 사람이 여럿일 경우, return하는 값을 오름차순 정렬해주세요.    입출력 예 | participant | return | | [1,2,3,4,5] | [1] | | [1,3,2,4,2] | [1,2,3] | 문제풀이단순하다. 순번을 만들어 내고, 해당 순번에 맞는 값이 답과 동일한지 판단하는 것.  순번을 어떻게 만들어 내느냐가 관건. 내가 해결한 방법은 규칙성을 찾고, 규칙에 맞게끔 순번을 만들어 냈다.  2번 수포자의 경우 홀수번 2 고정에 짝수번 1,3,4,5 규칙 3번 수포자의 경우 순번을 2번씩 적용 1234567891011121314151617let idx1, idx2=-1, idx3=-1;let i=0, len=answers. length;while(i&lt;len) {  idx1 = i%5;  if(!(i%2)){    var tmpIdx2 = (idx2+1)%5;    if( tmpIdx2 === 1 ){      idx2 = tmpIdx2+1;    }    else {      idx2 = tmpIdx2;    }    idx3 = (idx3+1)%5;  }   i++;}이 순번에 따라 값을 비교하면 나온다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748let sample1 = [1, 2, 3, 4, 5];let sample2 = [3, 1, 2, 4, 5];let count=[0, 0, 0];let idx2=-1, idx3=-1;let i=0, len=answers. length;while(i&lt;len) {  idx1 = i%5;  if(!(i%2)){    var tmpIdx2 = (idx2+1)%5;    if( tmpIdx2 === 1 ){      idx2 = tmpIdx2+1;    }    else {      idx2 = tmpIdx2;    }    idx3 = (idx3+1)%5;    if(answers[i] === 2) {      count[1]++;    }  } else {    if(answers[i] === sample1[idx2]) {      count[1]++;    }  }  if(answers[i] === sample1[idx1]) {    count[0]++;  }  if(answers[i] === sample2[idx3]) {    count[2]++;  }  i++;}var max=0;count. forEach( i=&gt; {  if(max &lt;= i) {    max = i;  }});var result = count. reduce( (acc, cur, idx) =&gt; {  if(cur === max) {    acc. push(idx+1)  }  return acc}, []);잘 살펴보면 3번 수포자의 idx는 1, 1, 2, 2, 3, 3, 4, 4, 5, 5 … 의 순서이고, sample에 매칭이 되어야 비로소 수포자의 순번이 동일하게 된다. (3, 3, 1, 1, 2, 2, 4, 4, 5, 5) 이는 직관적이지 않다. 찾아보니 직관적으로 풀어낸 답이 존재 하다. 1234567891011let a1 = [1, 2, 3, 4, 5];let a2 = [2, 1, 2, 3, 2, 4, 2, 5];let a3 = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5];let lenA1 = a1. length;let lenA2 = a2. length;let lenA3 = a3. length;let a1c = answers. filter( (v,idx) =&gt; v === a1[idx%lenA1]). length;let a2c = answers. filter( (v,idx) =&gt; v === a2[idx%lenA2]). length;let a3c = answers. filter( (v,idx) =&gt; v === a3[idx%lenA3]). length;filter를 통해 주어진 배열에서 조건에 맞는 값을 뺴낸다. 그러면 a1c, a2c, a3c 은 length로 인해 답을 Count 하게 되며 해당 값의 max를 구해 max와 값이 같으면 순서대로 답에 push 해주면 된다. 12345678910111213141516171819202122function solution(answers) { var answer = []; var a1 = [1, 2, 3, 4, 5]; var a2 = [2, 1, 2, 3, 2, 4, 2, 5] var a3 = [ 3, 3, 1, 1, 2, 2, 4, 4, 5, 5]; let lenA1 = a1. length; let lenA2 = a2. length; let lenA3 = a3. length; var a1c = answers. filter((a,i)=&gt; a === a1[i%lenA1]). length; var a2c = answers. filter((a,i)=&gt; a === a2[i%lenA2]). length; var a3c = answers. filter((a,i)=&gt; a === a3[i%lenA3]). length; var max = Math. max(a1c,a2c,a3c); if (a1c === max) {answer. push(1)}; if (a2c === max) {answer. push(2)}; if (a3c === max) {answer. push(3)}; return answer;}상당히 직관적이다. 이렇게 문제해결하자. "
    }, {
    "id": 230,
    "url": "/study_CODE_binarySearch_3/",
    "title": "이분탐색 : 가사 검색",
    "body": "2020/06/16 - category: 2020 KAKAO BLIND RECRUITMENT 문제 설명친구들로부터 천재 프로그래머로 불리는 프로도는 음악을 하는 친구로부터 자신이 좋아하는 노래 가사에 사용된 단어들 중에 특정 키워드가 몇 개 포함되어 있는지 궁금하니 프로그램으로 개발해 달라는 제안을 받았습니다. 그 제안 사항 중, 키워드는 와일드카드 문자중 하나인 ‘?’가 포함된 패턴 형태의 문자열을 뜻합니다. 와일드카드 문자인 ‘?’는 글자 하나를 의미하며, 어떤 문자에도 매치된다고 가정합니다. 예를 들어 “fro??”는 “frodo”, “front”, “frost” 등에 매치되지만 “frame”, “frozen”에는 매치되지 않습니다. 가사에 사용된 모든 단어들이 담긴 배열 words와 찾고자 하는 키워드가 담긴 배열 queries가 주어질 때, 각 키워드 별로 매치된 단어가 몇 개인지 순서대로 배열에 담아 반환하도록 solution 함수를 완성해 주세요.    가사 단어 제한사항 words의 길이(가사 단어의 개수)는 2 이상 100,000 이하입니다. 각 가사 단어의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다. 전체 가사 단어 길이의 합은 2 이상 1,000,000 이하입니다. 가사에 동일 단어가 여러 번 나올 경우 중복을 제거하고 words에는 하나로만 제공됩니다. 각 가사 단어는 오직 알파벳 소문자로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다.     검색 키워드 제한사항 queries의 길이(검색 키워드 개수)는 2 이상 100,000 이하입니다. 각 검색 키워드의 길이는 1 이상 10,000 이하로 빈 문자열인 경우는 없습니다. 전체 검색 키워드 길이의 합은 2 이상 1,000,000 이하입니다. 검색 키워드는 중복될 수도 있습니다. 각 검색 키워드는 오직 알파벳 소문자와 와일드카드 문자인 ‘?’ 로만 구성되어 있으며, 특수문자나 숫자는 포함하지 않는 것으로 가정합니다. 검색 키워드는 와일드카드 문자인 ‘?’가 하나 이상 포함돼 있으며, ‘?’는 각 검색 키워드의 접두사 아니면 접미사 중 하나로만 주어집니다. 예를 들어 “??odo”, “fro??”, “?????”는 가능한 키워드입니다. 반면에 “frodo”(‘?’가 없음), “fr?do”(‘?’가 중간에 있음), “?ro??”(‘?’가 양쪽에 있음)는 불가능한 키워드입니다.     입출력 예| words | queries | result || [“frodo”, “front”, “frost”, “frozen”, “frame”, “kakao”] | [“fro??”, “????o”, “fr???”, “fro???”, “pro?”] | [3, 2, 4, 1, 0] |  문제풀이정답률 0. 8%에 빛나는 극악의 난이도 문제이다. 정확성 정답률은 34%이나 배점이 100점중 25점인게 함정. 이진탐색을 타이틀로 걸었지만, 사실 이것보다 더 효율적으로 풀 수 있는 방법이 있다. 아래에서 설명하고겠다.  극악의 난이도를 자랑 하는 이유는 단순히 이진 탐색에서 답을 찾는 것아 아닌 upper_bound와 lower_bound를 찾아야 하는 것이었다.  그러나 그것 만으로 부족하다며 이진 탐색 compare 조건이 2중으로 만들어야 해결이 가능했다. (물론 해설에서는 앞서 언급한 이것보다 더 좋은 방법을 해설하였지만. . )  첫 시도 단순 선형 풀이 정확도 100%, 속도 40%  일일히 찾는 방법. 아마도 대부분 이렇게 풀엇을 것으로 추측한다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687function solution(words, queries) {  var result = new Array(queries. length). fill(0);  var querySet = makeQuerySet(queries);  querySet. forEach((i, idx) =&gt; {    words. forEach(j =&gt; {      if (compare(j, i)) {        result[idx]++;      }    })  })  return result;}function makeQuerySet(queries) {  var querySet = [];    queries. forEach( i =&gt; {    var queryInfo = {};    var len = i. length;    queryInfo. length = len;    if(i[0] === '?'){      queryInfo. frontFlag = true;      var num = markNum(i, true);      queryInfo. mark = num;      queryInfo. str = i. slice(num)    } else {      queryInfo. frontFlag = false;      var num = markNum(i, false);      queryInfo. mark = num;      queryInfo. str = i. substring(0,len-num);    }    querySet. push(queryInfo);  })  return querySet;}function markNum(query, frontFlag) {  let count = 1;  var check = query. split('');  if(frontFlag) {    for(let i=1,len=check. length; i&lt;len; i++) {      if(check[i] === '?') {        count++;      } else {        return count;      }    }  } else {    for(let j=check. length-2; j&gt;=0; j--) {      if(check[j] === '?') {        count++;      } else {        return count;      }    }  }}function compare(oneWord, oneQuery) {  if(oneWord. length !== oneQuery. length) {    return false;  }  if(oneQuery. frontFlag) {    if(frontCompare(oneWord, oneQuery)) {      return true;    } else {      return false;    }  } else {    if(backCompare(oneWord, oneQuery)) {      return true;    } else {      return false;    }  }}function frontCompare(oneWord, oneQuery) {  return oneQuery. str === oneWord. slice(oneQuery. mark);}function backCompare(oneWord, oneQuery) {  return oneQuery. str === oneWord. substring(0,oneWord. length-oneQuery. mark);}   다음 여럿 시도 : querySet을 개수별로 다시 묶은 다음, 해당 범위 내에서 다시 찾기. 이진탐색으로 특정 값을 찾은 뒤 양옆으로 앞글자가 바뀔때까지 탐색 재개.     문자열을 우선 길이 순으로 정렬한 뒤, 길이가 같다면 문자순으로 정렬을 하고, 해당 기준을 바탕으로 upper_bound 와 lower_bound를 찾는다. (단순한 bound와 다르니 찾아보자. )  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115function solution(words, queries) { 'use strict'; var answer = []; var reverseWords = []; let wordStart = 0; let wordEnd = words. length-1; words. forEach(i =&gt; reverseWords. push(i. split(  ). reverse(). join(  ))); let sortedWords = words. sort((a, b) =&gt; {  if (a. length &lt; b. length) {   return a. length - b. length  } else if (a. length === b. length) {   return (a &gt; b) - (a &lt; b);  } else {   return a. length - b. length;  } });  let reverseSortedWords = reverseWords. sort((a, b) =&gt; {  if (a. length &lt; b. length) {   return a. length - b. length  } else if (a. length === b. length) {   return (a &gt; b) - (a &lt; b);  } else {   return a. length - b. length;  } });  let len; let left; let right; queries. forEach(_ =&gt; {  len = _. length;  if (_[0] === '?') {   var pivot = _. split(  ). reverse(). join(  );   var leftPivot = pivot. split(  ). map((_, idx) =&gt; _ === '?' ? 'a' : _). join('');   left = lowerBound(reverseSortedWords, wordStart, wordEnd, leftPivot);   var rightPivot = pivot. split(  ). map((_, idx) =&gt; _ === '?' ? 'z' : _). join('');   right = upperBound(reverseSortedWords, wordStart, wordEnd, rightPivot);  } else {   //debugger;   var leftPivot = _. split(  ). map((_, idx) =&gt; _ === '?' ? 'a' : _). join('');   left = lowerBound(sortedWords, wordStart, wordEnd, leftPivot);   var rightPivot = _. split(  ). map((_, idx) =&gt; _ === '?' ? 'z' : _). join('');   right = upperBound(sortedWords, wordStart, wordEnd, rightPivot);  }  answer. push(right - left); }) return answer;}// [ frame ,  frodo ,  front ,  frost ,  kakao ,  frozen ] 에서 [ fro??? ] 를 lower는 5를 upper는 6을 찾는게 핵심이다. function lowerBound(list, start, end, key) { let it; let step; let advance; let first = start; let count = end - start + 1; while (count &gt; 0){  step = Math. floor(count/2);  advance = first+step;  it = list[advance];  if(compare(it,key) &amp;&amp; it !== undefined) {   first = ++advance;   count -= step+1;  } else {   count = step;  } } return first;}function upperBound(list, start, end, key) { let it; let step; let advance; let first = start; let count = end - start + 1; //debugger; while (count &gt; 0){  step = Math. floor(count/2);  advance = first+step;  it = list[advance];  if(!compare(key, it) &amp;&amp; it !== undefined) {   first = ++advance;   count -= step+1;  } else {   count = step;  } } return first;}function compare(a, b) { if(a. length&lt;b. length) {  return true; } else if(a. length === b. length) {  if(a &lt; b) {   return true;  } } return false;}# 트라이 구조 트라이 구조는 다음에 공부하자! "
    }, {
    "id": 231,
    "url": "/study_Programming_binarySearchTree(BST)/",
    "title": "자바스크립트 : 이진탐색트리(BST)",
    "body": "2020/06/16 - BST를 만들어 보자. 우선 Data를 담을 노드. 12345678910 class Node{  constructor(data, left, right){   this. data = data;   this. left = left;   this. right = right;  }  show(){   return this. data;  } }BST, Right Node가 존재해야 Successor를 찾는 것으로 들어가므로 굳이 Successor를 사용해서 중복 제한을 하는 것 보다 Minimum 값을 사용하는게 좋아 보인다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105 class BST{  constructor(){   this. root = null;  }   getRoot(){   return this. root;  }   insert(data){   let n = new Node(data, null, null);   if(this. root == null){    this. root = n;   }   else{    let current = this. root;    let parent;    while(true){     parent = current;     if(data &lt; current. data){      current = current. left;      if(current == null){       parent. left = n;       break;      }     } else {      current = current. right;      if(current == null){       parent. right = n;       break;      }     }    }   }  }   inOrder(node){   if(!(node == null)) {    this. inOrder(node. left);    console. log(node. show());    this. inOrder(node. right);   }  }   find(data){   let current = this. root;   while(current. data != data)   {    if(data &lt; current. data) {     current = current. left;    } else {     current = current. right;    }    if(current == null){     return null;    }   }   return current;  }  remove(data){   this. root = this. removeNode(this. root, data);  }  removeNode(node, data){   if(node == null){    return null;   }   if(data == node. data){    if(node. left == null &amp;&amp; node. right == null){     return null;    }    if(node. left == null){     return node. right;    }    if(node. right == null){     return node. left;    }    let tempNode = this. getMinimum(node. right);    node. data = tempNode. data;    node. right = this. removeNode(node. right, tempNode. data);    return node;   } else if(data &lt; node. data) {    node. left = this. removeNode(node. left, data);    return node;   } else {    node. right = this. removeNode(node. right, data);    return node;   }  }  getMinimum(node){   let current = node;   while(!(current. left == null))   {    current = current. left;   }   return current;  } } 이제 문제 나오면 사용하도록 하자. "
    }, {
    "id": 232,
    "url": "/study_CODE_binarySerch/",
    "title": "이진탐색 : Upper Bound, Lower Bound",
    "body": "2020/06/16 - 이진탐색이진 탐색은 기본적으로 매우 중요한 개념이다.  특히 수학적인 부분에서 미적분과 같은 계산하기 어려운 값을 근사치로 나타내고자 할때, 주로 쓰이는 방법 중 하나라는 점에서 말이다. (수치해석 과목에서 잘 찾아볼수 있다. ) 수학적인 부분에서 잘 쓰인다면 역시 프로그래밍에서도 잘 쓰일 수 있는데, 이유는 방대한 양의 데이터를 찾고, 저장하고, 이용하고자 할때 소요되는 시간 (Big-O)에서 큰 활약을 할수 있기 때문이다. 그렇기 때문에 숙지하고 문제해결에 있어서 잘 사용하도록 하자. 기본 개념정렬된 배열에서 처음값과 끝값을 잡은 다음 (보통 처음 : 0, 끝 : 배열의 끝) 중간값을 (처음값 + 끝값)/2 로 잡는다. 중간값에 해당하는 값을 찾은 뒤 해당값이 찾고자 하는 값과 비교하여 크거나 작을때 처음값 또는 끝값을 중간값으로 조정하면서 다시 중간값을 잡는다. 값을 찾거나 처음값이 끝값보다 커질때까지 반복 123456789101112131415161718function binarySeach(list, key) { let low = 0; let high = list. length-1; let mid; while(low &lt;= high) {  mid = parseInt((low + high)/2);  if(key&gt;list[mid]) {   low = mid+1;  } else if (key&lt;list[mid]) {   high = mid-1;  } else {   return mid;  } }  return -(low+1);}# 찾고자 하는 값이 여러개일 경우 이 문제를 해결하기위해 Upper_Bound와 Lower_Bound가 필요하다. 물론 기본 개념에서 약간 조정한 정도이나, 어쨌든 다르다.  C++같은 경우 stl에서 내장된 메소드로 지원을 해주지만 자바에서는 제공을 해주지 않기 때문에 여기서 구현해 놓고자 한다. Upper_Bound와 Lower_Bound를 구분짓는 장치는 key값과 찾고자 하는 값이 같을 경우 처리방법이다.  Upper 같은 경우 해당 값이 나오면 mid+1값으로 low값을 정하며 Lower 같은 경우 mid 값을 high값으로 정한다. 잘 생각해 보면, 이 차이로 Upper는 key 값보다 큰 직후값을 Lower는 key값이 시작되는 값을 갖게된다.   (찾고하 하는 값의 index : Lower &lt;= index &lt; Upper)  Lower_Bound12345678910111213141516function lowerBound(list, key) { let low = 0; let high = list. length-1; let mid; while(low &lt; high) {  mid = parseInt((low + high)/2);  if(key &lt;= list[mid]) {   high = mid;  } else {   low = mid+1;  } }  return low;} Upper_Bound12345678910111213141516function upperBound(list, key) { let low = 0; let high = list. length-1; let mid; while(low &lt; high) {  mid = parseInt((low + high)/2);  if(key &gt;= list[mid]) {   low = mid+1;  } else {   high = mid;  } }  return low;}# 샘플 123456789101112131415161718192021222324252627282930313233343536373839 /* * Javascript version of C++ equal_range via lower_bound and upper_bound * * Input: The array A in ascending order and a target T * Output: The tightly bound indices [i, j] where A[i] &lt;= T &lt; A[j] if T exists in A * otherwise [-1, -1] is returned if T does not exist in A */let lowerBound = (A, T) =&gt; {  let N = A. length,    i = 0,    j = N - 1;  while (i &lt; j) {    let k = Math. floor((i + j) / 2);    if (A[k] &lt; T)      i = k + 1;    else      j = k;  }  return A[i] == T ? i : -1;};let upperBound = (A, T) =&gt; {  let N = A. length,    i = 0,    j = N - 1;  while (i &lt; j) {    let k = Math. floor((i + j + 1) / 2);    if (A[k] &lt;= T)      i = k;    else      j = k - 1;  }  return A[j] == T ? j + 1 : -1;};let equalRange = (A, T) =&gt; {  return [lowerBound(A, T), upperBound(A, T)];};# C++ Std: Upper_Bound 와 Lower_Bound를 구현해 보자 숫자로만 된 배열 같은 경우 그냥 위에 있는것을 써도 되는데, 예를 들어 length와 value를 함께 비교해야 하는 경우 위의 배열은 통하지가 않는다. (이진탐색문제 3 참조) 그런데 C++ Std에서 제공하는 Upper_Bound와 Lower_Bound는 다중 제한 조건의 탐색이 가능한데, 자바에서는 제공하지 않는다. 따라서 구현해서 사용하자. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var test = [10, 10, 10, 20, 20, 20, 30, 30, 40, 40, 40];var lo = lower1Bound(test,0,10,40);var up = upper1Bound(test,0,10,40);console. log( lower:   + lo +  , upper:   + up);function lowerBound(list, start, end, key) { let it; let step; let advance; let first = start; let count = end - start + 1; //debugger; while (count &gt; 0){  step = Math. floor(count/2);  advance = first+step;  it = list[advance];  if(it &lt; key &amp;&amp; it !== undefined) { //advance의 값이 0보다 작게 되면 false를 가리켜야 한다.    first = ++advance;   count -= step+1;  } else {   count = step;  } } return first;}function upperBound(list, start, end, key) { let it; let step; let advance; let first = start; let count = end - start + 1; //debugger; while (count &gt; 0){  step = Math. floor(count/2);  advance = first+step;  it = list[advance];  if(!(key &lt; it) &amp;&amp; it !== undefined) {   first = ++advance;   count -= step+1;  } else {   count = step;  } } return first;}"
    }, {
    "id": 233,
    "url": "/study_CODE_binarySearch_2/",
    "title": "이분탐색 : 징검다리 건너기",
    "body": "2020/06/15 - category: 2019 카카오 개발자 겨울 인턴십 문제 설명[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다. ] 카카오 초등학교의 니니즈 친구들이 라이언 선생님과 함께 가을 소풍을 가는 중에 징검다리가 있는 개울을 만나서 건너편으로 건너려고 합니다. 라이언 선생님은 니니즈 친구들이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다. 징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.  디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.  단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.  니니즈 친구들은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다.  니니즈 친구들은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다. 디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.  제한사항     징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.    stones 배열의 크기는 1 이상 200,000 이하입니다.    stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.    k는 1 이상 stones의 길이 이하인 자연수입니다.    문제풀이문제 사고력이 가장 큰 영향을 주는것 같다.  stones index의 값이 연속으로 0이 되는 개수가 k값보다 커지기 직전의 건넌 횟수 핵심 포인트는 결국 stones에 있는 값에서 return 값이 나온다! 라는 것.  (stones에 있는 값 보다 1보다 클수도 작을수도 없다. ) 처음은 문제 설명을 문자 그대로 이용하여 문제해결하고자 하였다.  그러다 보니 설계를 다행히 핵심 포인트는 잡았지만 각 stone별 해당 값을 빼고 값 중 현재값이 양수이면서 0보다 작아지는 index를 바탕으로 k값보다 커지는 순간을 측정하였다. 정확도도 해결해야 했으나, 속도도 같으 병행하며 문제 해결을 해 나갔는데, 조금 더 생각해 보면 stones의 값 중 중복된 값을 제외하고 정렬을 한뒤 작은 값부터 빼내면  해당 값들이 각 index 별 0이 되는 값이기 때문에 (stone이 사라지는 값) 더 빠르게 사용할수 있었다. 여기까지가 할 수 있었던 최대한의 해결. 처음 문제 풀이 : 정확도는 100%, 속도: 0%, 공간: 속도로 인한 측정 불가. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758 function solution(stones, k) {  let countStone = 0;  var check;  const fadeStoneSet = [];  let countSet = new Set();  stones. forEach(i =&gt; countSet. add(i));  let stoneSet = [. . . countSet]. sort((a, b) =&gt; b - a);  let curStone = 0;  curStone = stoneSet. pop();  if(k===1) {    return curStone;  }  while (curStone !== undefined) {    let fadeStone = [];    stones. forEach((item, idx) =&gt; {      if (item === curStone) {        fadeStone. push(idx);        countStone++;      }    });    fadeStoneSet. push(. . . fadeStone);    fadeStoneSet. sort( (a, b) =&gt; a-b);    let size = fadeStoneSet. length;    if (countStone &gt;= k) {      var item = fadeStone. pop();      while (item !== undefined) {        check = 1;        let idx = fadeStoneSet. indexOf(item);        let start=idx-k;        if(start&lt;0) {           start=0;        }        let end = idx+k;        if(end&gt;size) {          end = size;        }        for(let i=start, len=end; i&lt;len; i++){          if(check ===2) {            debugger;          }          if((fadeStoneSet[i+1]-fadeStoneSet[i]) === 1) {            check++;            if(check===k) {              return curStone;            }          } else {            check = 1;          }        }        item = fadeStone. pop();      }    }    curStone = stoneSet. pop();  }  return curStone;}위 같이 해결하고 찾아보니 위의 방법은 사실상 완전탐색과 다름이 없고 이분탐색을 한다면 문제 해결은 매우 빨라짐을 알게 되었다. 그래도 stones 내에 있는 값이 결국은 return 값이 된다는 사실을 통해 정렬된 stones 값을 기준으로 left mid right 값을 확인하도록 할 수 있었던 부분에 위안을 삼아야 했다. (다른 풀이를 보니 0과 최대값을 기준으로 이분탐색시도) 최종 풀이 1234567891011121314151617181920212223242526272829303132333435363738function checkStone(stones, mid, k) {  let now = 0;  for(let i = 0; i &lt; stones. length; i++) {    if(stones[i] &lt; mid) {       now += 1;    }    else {      now = 0;    }    if(now &gt;= k) {      return false;    }   }   return true;}function solution(stones, k) {  let countSet = new Set();  stones. forEach(i =&gt; countSet. add(i));  let stoneSet = [. . . countSet]. sort((a, b) =&gt; a-b);  let right=stoneSet. length-1;  let left=0;  let mid;  while(left &lt;= right) {    mid = parseInt((left+right)/2);    if(checkStone(stones, stoneSet[mid], k)) {      left = mid+1;    } else {      right = mid-1;    }  }  return stoneSet[left-1];}"
    }, {
    "id": 234,
    "url": "/study_CODE_binarySearch_1/",
    "title": "이분탐색 : 예산",
    "body": "2020/06/14 - 문제 설명국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것입니다. 국가예산의 총액은 미리 정해져 있어서 모든 예산요청을 배정해 주기는 어려울 수도 있습니다. 그래서 정해진 총액 이하에서 가능한 한 최대의 총 예산을 다음과 같은 방법으로 배정합니다.  모든 요청이 배정될 수 있는 경우에는 요청한 금액을 그대로 배정합니다.  모든 요청이 배정될 수 없는 경우에는 특정한 정수 상한액을 계산하여 그 이상인 예산요청에는 모두 상한액을 배정합니다.   상한액 이하의 예산요청에 대해서는 요청한 금액을 그대로 배정합니다. 입출력 예 | budgets | M | return | | — | — | — | |[120, 110, 140, 150] | 485 | 127 | 문제풀이단순히 BST를 사용해서 문제를 해결하는 것이 아닌 BST의 컨셉을 이용해 가장 근사치 값을 찾는 것이다. (수치해석. . ) 계산적으로 budgets의 상한값의 MAX값은 150이며, MIN 값은 0이다.  이를 시작점을 삼아 middle 값을 정해서, result를 계산하고 해당 result 값과 근사치를 비교하여 크면 middle point를 right로, 작으면 middle point를 left로 기준을 잡고 다시 middle 값을 구한다. (가장 근사치가 나오는 left가 right를 넘어서는 직전 종료) 따라서 풀이는 단순하다. 123456789101112131415161718192021222324252627282930313233343536 function solution(budgets, M) {     let left = 0;  let right = 0;  var answer = 0;    budgets. forEach( (i) =&gt; {   if(i&gt;right) {    right = i;   }  })  let middle = 0;  while (left &lt;= right) {   let sum = 0;   middle = parseInt((left + right)/2);   budgets. forEach( (i) =&gt; {    if (i &gt;= middle) {     sum += middle;    } else {     sum += i;    }   })   if (sum &gt; M) {    right = middle-1;   }   else {    answer = middle;    left = middle+1;   }  }   return answer; }"
    }, {
    "id": 235,
    "url": "/study_CODE_BFS_1/",
    "title": "BFS : 블록 이동하기",
    "body": "2020/06/13 - 문제 설명로봇개발자 무지는 한 달 앞으로 다가온 카카오배 로봇경진대회에 출품할 로봇을 준비하고 있습니다. 준비 중인 로봇은 2 x 1 크기의 로봇으로 무지는 0과 1로 이루어진 N x N 크기의 지도에서 2 x 1 크기인 로봇을 움직여 (N, N) 위치까지 이동 할 수 있도록 프로그래밍을 하려고 합니다. 로봇이 이동하는 지도는 가장 왼쪽, 상단의 좌표를 (1, 1)로 하며 지도 내에 표시된 숫자 0은 빈칸을 1은 벽을 나타냅니다. 로봇은 벽이 있는 칸 또는 지도 밖으로는 이동할 수 없습니다. 로봇은 처음에 아래 그림과 같이 좌표 (1, 1) 위치에서 가로방향으로 놓여있는 상태로 시작하며, 앞뒤 구분없이 움직일 수 있습니다. 로봇이 움직일 때는 현재 놓여있는 상태를 유지하면서 이동합니다. 예를 들어, 오른쪽으로 한 칸 이동한다면 (1, 2), (1, 3) 두 칸을 차지하게 되며, 아래로 이동한다면 (2, 1), (2, 2) 두 칸을 차지하게 됩니다. 로봇이 차지하는 두 칸 중 어느 한 칸이라도 (N, N) 위치에 도착하면 됩니다. 로봇은 다음과 같이 조건에 따라 회전이 가능합니다. 로봇은 90도씩 회전할 수 있습니다. 단, 로봇이 차지하는 두 칸 중, 어느 칸이든 축이 될 수 있지만, 회전하는 방향(축이 되는 칸으로부터 대각선 방향에 있는 칸)에는 벽이 없어야 합니다. 로봇이 한 칸 이동하거나 90도 회전하는 데는 걸리는 시간은 정확히 1초 입니다. 0과 1로 이루어진 지도인 board가 주어질 때, 로봇이 (N, N) 위치까지 이동하는데 필요한 최소 시간을 return 하도록 solution 함수를 완성해주세요.  제한사항     board의 한 변의 길이는 5 이상 100 이하입니다.    board의 원소는 0 또는 1입니다.    로봇이 처음에 놓여 있는 칸 (1, 1), (1, 2)는 항상 0으로 주어집니다.    로봇이 항상 목적지에 도착할 수 있는 경우만 입력으로 주어집니다.     입출력 예      board   result       [[0, 0, 0, 1, 1],[0, 0, 0, 1, 0],[0, 1, 0, 1, 1],[1, 1, 0, 0, 1],[0, 0, 0, 0, 0]]   7   문제풀이어떤방식으로 설계를 해야할지 부터가 고민이었다.  상하 좌우 이동은 단순히 해당 point로부터 각각 옮기면 되었지만, 2개의 축을 두고 회전하는 것을 표현하는 방법을 설계하기가 어려웠다. 해결책은 생각보다 간단한데, 그냥 기준점을 하나의 point로 가지고 진행을 하면 된다.  가로상태일때 기준점은 좌측, 세로일때 기준점을 위측 으로 잡는다.  그렇게 되면 상하좌우는 단순히 기준점만 옮기면 되며, 2개의 축을 가지고 회전하는 경우 각각의 상태를 그냥 표현해 주면 된다.  좌측기준 위로 옮기기 =&gt; 기준점을 상향, 우측 기준 위로 옮기기 =&gt; 기준점을 우측 이동 후 상향 또한 rotate 조건은 기준점을 상하좌우로 옮기는 조건과 동일하다. 이 기준을 가지고 해결해 주면 된다. 위와 같이 기준점이 바뀌는 복잡한 경우 그냥 하나의 기준점을 잡아주고 그 기준을 바탕으로 조건을 설정해주면 해결할 수 있다. 또한 가장 빠른 시간(가장 낮은 걸음수)에 도착하는 문제 같은 경우 해당 point에 시간(걸음수)를 간직한채 방문을 해주면, 해당 값을 update하면서 풀어 주면 된다. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160function solution(map) { const n = map. length,  dx = [0, 0, 1, -1], //direction x, y 상 하 좌 우 를 나타낸다.   dy = [1, -1, 0, 0],  rowToColDx = [-1, -1, 0, 0], //가로에서 세로로 변경할 좌표. 좌측 up, 우측 up, 좌측 down, 우측 down.   rowToColDy = [0, 1, 0, 1],  colToRowDx = [0, 1, 0, 1], // 세로에서 가로로 변경할 좌표. 위와 동일.   colToRowDy = [0, 0, -1, -1],  q = [   [0, 0, 0, 0] //starting point, BFS의 Queue를 받는다. //이렇게 BFS를 사용할 수 있다.   ],  visited = []; // 방문할때마다, 방문자의 시간을 보고 가장 낮은 값을 간직.  for (let i = 0; i &lt; n; i++) {  visited. push([]);  for (let j = 0; j &lt; n; j++) {   visited[i]. push([Infinity, Infinity]); //가장 낮은값을 간직하기 위해 Infinity 설정  } } visited[0][0][0] = 0; //처음은 0초 let min = Infinity; const canGoRight = (x, y, p) =&gt; { //x,y는 좌표 p는 상태 (가로 상태, 세로 상태)  if (p === 0) {   if (y + 2 &gt;= n || map[x][y + 1] === 1 || map[x][y + 2] === 1)    return false;  } else {   if (y + 1 &gt;= n || x + 1 &gt;= n || map[x][y + 1] === 1 || map[x + 1][y + 1] === 1)    return false;  }  return true; }; const canGoLeft = (x, y, p) =&gt; {  if (p === 0) {   if (y - 1 &lt; 0 || map[x][y - 1] === 1)    return false;  } else {   if (y - 1 &lt; 0 || x + 1 &gt;= n || map[x][y - 1] === 1 || map[x + 1][y - 1] === 1)    return false;  }  return true; }; const canGoDown = (x, y, p) =&gt; {  if (p === 0) {   if (x + 1 &gt;= n || y + 1 &gt;= n || map[x + 1][y] === 1 || map[x + 1][y + 1] === 1)    return false;  } else {   if (x + 2 &gt;= n || map[x + 1][y] === 1 || map[x + 2][y] === 1) {    return false;   }  }  return true; }; const canGoUp = (x, y, p) =&gt; {  if (p === 0) {   if (x - 1 &lt; 0 || y + 1 &gt;= n || map[x - 1][y] === 1 || map[x - 1][y + 1] === 1)    return false;  } else {   if (x - 1 &lt; 0 || map[x - 1][y] === 1) {    return false;   }  }  return true; }; const canRotateUp = (x, y) =&gt;  !(x - 1 &lt; 0 || y + 1 &gt;= n || map[x - 1][y] === 1 || map[x - 1][y + 1] === 1); const canRotateDown = (x, y) =&gt;  !(x + 1 &gt;= n || y + 1 &gt;= n || map[x + 1][y] === 1 || map[x + 1][y + 1] === 1); const canRotateRight = (x, y) =&gt;  !(y + 1 &gt;= n || x + 1 &gt;= n || map[x][y + 1] === 1 || map[x + 1][y + 1] === 1); const canRotateLeft = (x, y) =&gt;  !(y - 1 &lt; 0 || x + 1 &gt;= n || map[x][y - 1] === 1 || map[x + 1][y - 1] === 1); const canGoMap = [ //한번에 이동 및 rotate를 해주기 위한 작업. canGoMap[0] =&gt; canGoRight  canGoRight,  canGoLeft,  canGoDown,  canGoUp ],  canRotateMap = [   [    canRotateUp,    canRotateUp,    canRotateDown,    canRotateDown   ], [    canRotateRight,    canRotateRight,    canRotateLeft,    canRotateLeft   ],  ],  deltaMap = [   [rowToColDx, rowToColDy],   [colToRowDx, colToRowDy]  ]; while (q. length) {  debugger;  const [x, y, t, p] = q. shift();  // 만일 (n,n)에 도착했다면 최소시간을 갱신합니다  if (   (x === n - 1 &amp;&amp; y === n - 2 &amp;&amp; p === 0)   || (x === n - 2 &amp;&amp; y === n - 1 &amp;&amp; p === 1)  ) {   debugger;   min = Math. min(min, t);  }  // 회전 없이 우좌하상으로 움직일때  for (let k = 0; k &lt; 4; k++) {   if (!canGoMap[k](x, y, p)) {    continue;   }   const nx = x + dx[k],    ny = y + dy[k];   if (visited[nx][ny][p] &gt; t + 1) {    visited[nx][ny][p] = t + 1;    q. push([nx, ny, t + 1, p]);   }  }  for (let k = 0; k &lt; 4; k++) {   // 가로로 놓인 상황인 경우 세로로 돌려보자   // 세로로 놓인 상황인 경우 가로로 돌려보자   if (!canRotateMap[p][k](x, y)) continue;   const nx = x + deltaMap[p][0][k],    ny = y + deltaMap[p][1][k],    _p = p ? 0 : 1;   if (visited[nx][ny][_p] &gt; t + 1) {    visited[nx][ny][_p] = t + 1;    q. push([nx, ny, t + 1, _p]);   }  } } return min;}"
    }, {
    "id": 236,
    "url": "/study_BE_WebApi/",
    "title": "Spring : Web-Api",
    "body": "2020/06/12 - Web-Api개요: Api가 무엇인지에 대해서 보다 Web-Api에서 도움을 주는 라이브러리에 대해 살펴보고자 한다. javax. servlet: Http 통신을 위한 라이브러리. 현재 WAS Runtime을 Tomcat으로 지정했고, Tomcat에는 서블릿 라이브러리가 있기 때문에 바로 Tomcat에 올릴경우 없어도 되지만, 올리지 않을 경우 컴파일 단계에서 필요하다. 따라서 scope는 provided javax. jstl: jstl 문법과 EL 표기법을 사용하게 도와주는 라이브러리. (EL표기법은 다이나믹 웹 모듈 2. 4 이후부터 지원)  웹 모듈 3. 1이 되도록 하는 방법  web. xml :  1  &lt;!DOCTYPE web-app PUBLIC  -//Sun Microsystems, Inc. //DTD Web Application 2. 3//EN   http://java. sun. com/dtd/web-app_2_3. dtd  &gt;    ↓   1  &lt;?xml version= 1. 0  encoding= UTF-8 ?&gt;    . settings/org. eclipse. wst. common. project. facet. core. xml : version 변경.  mysql-connector-java: JDBC를 사용할 수 있게 해준다. jDBC: Java Database Connectivity MySQL 사이트에서 가지고 올수 있으며, 자바를 이용한 데이터베이스 접속 및 쿼리 실행 데이터 핸들링을 제공한다. jackson-databind: json 라이브러리이다.  json 데이터를 사용할수 있게 해준다. javax. servlet. jsp: jsp api를 만들수 있게 해준다. "
    }, {
    "id": 237,
    "url": "/study_BE_SpringMVC/",
    "title": "SPRING : Mvc",
    "body": "2020/06/12 - Spring MVC개요: 서블릿과 같은 웹 구현을 위한 작업물을 관리하며 도와준다. 구체적으로 어떤 도움을 주는지 알아보자. WEB: spring-webmvc에서 다루고 있다.  org. springframework. web. servlet. DispatcherServlet : 프론트 컨트롤러에 해당한다. 초기화함께 @EnableWebMvc 를 찾는다.  xml에서 parameter로 AnnotationConfigWebApplicationContext와 FrontController를 도와줄 Main에 해당하는 클래스(보통 WebMvcContextConfiguration) 을 받는다.      WebMvcConfigurerAdapter : 초기 기본 설정 이외 필요한 동작을 할수 있게 해준다.          addResourceHandlers(__) : http 같은 경우 css와 js이 있는 곳을 연결해 준다. ResourceHandlerRegistry 객체를 받아 입력.      configureDefaultServletHandling(__) : //Mapping 정보가 없는 url을 defaultservlet이 처리하게끔 enable! -&gt; was에서 static한 자원을 읽어서 보여준다. DefaultServletHandlerConfigurer 객체를 받아 enable 사용.      addViewControllers(__) : Controller annotation 하지 않아도 특정 url에 대해 Mapping 해준다.  addViewControllers에서 주소값을 설정해주고, setViewName에서 해당 view 파일을 보여준다.      getInternalResourceViewResolver(__) : view 파일의 위치를 정해준다. InternalResourceViewResolver 할당하여 해당 객체에 prefix로 주소를 serffix에 확장자를 더해서 반환한다.            ModelMap : Request scope을 직접 사용하기 보다 Spring이 제공하는 데이터 전달 객체. Spring이 알아서 Request scope로 전달해준다. (여러 객체 존재 Model, ModelView 등등)"
    }, {
    "id": 238,
    "url": "/study_BE_SpringJDBC/",
    "title": "Spring : JDBC",
    "body": "2020/06/11 - Spring JDBC개요: Database와 연결하는 동작을 도와준다.  구체적으로 어떤 도움을 주는지 알아보자. Data Access: DataBase와 연결 부분을 도와준다. spring-jdbc에서 다루고 있다. spring-tx에서 다루고 있다. 또한 추가로 db 연결을 위해 mysql-connector-java가 필요하다. basic data source를 다루기 위해 apache 제공하는 commons-dbcp2 사용한다.  javax. sql. DataSource 객체(이 객체는 다음에 공부하도록 하자. )에 apache에서 제공하는 basicDataSource를 사용하여 데이터를 저장하여 관리한다. jdbcTemplate. queryForInt : 쿼리문을 작성해서 결과 데이터 수를 return jdbcTemplate. queryForObject : 쿼리 결과를 원하는 객체로 받을 수 있다. 이때 new Object[]{1212L}를 사용하는 이유를 잘 모르겠다.  NamedparameterJdbcTemplate : jdbcTempate에서 인자를 ?로 받는 대신 파라미터명을 사용하여 작성하는 것을 지원한다.  NamedparameterJdbcTemplate   query Method : query(Sql문, 바인딩 할 Parameter를 위한 빈 객체- collection. empty객체, dto에서 가져온 rowMapper)   RowMapper : Dto 클래스를 가져와 해당 필드를 parameter로 바꿔준다. (BeanpropertyRowMapper =&gt; 카멜 표기법 &lt;-&gt; 언더스코어 표기법) 즉, 반환을 Dto 객체로 하고 싶을 경우 해당 틀을 RowMapper가 제공하는 것 같다. 와 신기하네 그렇다면 (NamedparameterJdbcTemplate)query(쿼리문, 빈객체, rowMapper) = Dto 객체 이렇단 소린데 자동으로 연결해준단 소리인건가?  update Method : 쿼리문과 바인딩할 parameter 객체를 받아 datebase값을 변경한다. (UPDATE, DELETE) 성공시 1, 실패시 0 반환 UPDATE시 SqlparameterSource에 BeanPropertSqlParameterSource에서 Dto를 받아 각 parameter를 전달한다. 전달된 parameter를 Query문에 바인딩 하여 실행.    DELETE시 Map에 parameter와 값을 가진 singletonMap(1개를 지우는데 사용!)으로 parameter 전달한다. 전달된 parameter를 Query문에 바인딩 하여 실행.     queryForObject Method : queryForObject(SQL 문 , Map에 parameter와 값을 가진 singletonMap으로 parameter 전달한다. , Dto 객체로 반환하기 위해 RowMapper) 전달된 parameter를 Query문에 바인딩 하여 실행. 이떄 해당 parameter에 값이 없을 경우를 대비(Exception)     SimpleJdbcInsert : insert 쿼리를 생성해준다. dataSource에 객체를 생성할때 whtiTableName에 table명을 넣어주면 생성 되며, 객체 안 execute를 통해 쿼리를 실행한다. usingGeneratedKeyColumns(“파라미터”)을 통해 자동으로 파라미터의 값을 가진다. (보통 id) 그리고 excuteAndReturnKey를 통해 반환한다.   TransactionManagementConfigurer : 보통 transaction 하기 위해 DBConfig에서 implements 받아 사용한다.      annotationDrivenTrasactionManager() : transaction을 하기 위해 PlatformTransactionManager의 transactionManager()를 사용하여 DataSourceTransactionManager를 DataSource로 할당시키며, PlatformTransactionManager을 반환한다.    "
    }, {
    "id": 239,
    "url": "/study_BE_SpringFramework/",
    "title": "SPRING : Framework",
    "body": "2020/06/10 - Spring개요: 전문적이다. 처음 Spring을 접할때 느낀 생각이다. 사실 이전에 Spring없이 간단한 dao, dto를 만드는 공부를 할 때, 이 두개의 작업물과 함께 매 프로젝트에는 동일한 용도로 사용되는 과정물이 많을 것 예상되었고, 실무에서는 이같은 중복 작업을 최소한 줄이는 형태로 작업을 진행하고 있곘다로 생각을 했다. 더 편하고, 빠르면서, 유지보수에 그리고 협업하기에도 용이하도록 위와 같은 목적에 부합한 형태에 맞게 framework가 만들어 졌고 그중 Spring은 여러 개발자들이 위와 같은 목적에 부합하다고 판단을 했기 때문에 여전히 인기가 있다고 생각을 한다. 따라서 그와 같은 맥락에서 Spring을 공부하고자 한다. Spring Framework Module: 이제까지 배운 내용을 토대로 정리한다. 웹개발을 크게 3가지로 나누자면 웹구현 - 메모리 할당 및 관리 - 데이터 관련 작업 이 될수 있겠다. Sping은 요소를 각각 Web - Core Container - Data Access/Integration로 나눴다. 각각의 요소를 차차 살펴보고자 한다. Core Container: Data Access: "
    }, {
    "id": 240,
    "url": "/study_BE_Spring-Layered-Architecture/",
    "title": "Spring : Layerd Achitecture",
    "body": "2020/06/09 - Spring - Layered Achitectur개요: 처음 Spring Framework Module에서 볼 때, 아마도 web 개발을 MVC를 통해서. DB관리를 data Access를 통해서 독자적으로 하도록 나누고자 할때 이 둘을 체계적으로 관리할 필요에 의해 존재하는 것 같다. 그와 동시에 각 부분에서 전문화 되도록 관리 하도록 도와주는 것 같다. Layered Achitectur: 우선 xml에서 listener를 통해 MVC와 Data Access를 Data Access가 root, MVC는 그 밑으로 정의 한다    listener : 특정한 이벤트가 발생할 때 동작한다.     ContextLodaerListener : listener에 의해 Context가 Loading 될때 수행 하는데 parameter로 AnnotationConfigWebApplicationContext와 Data Access의 Main Configuration을 가지고 온다. (보통 ApplicationConfig)     filter : 요청이 수행되기 전 응답이 나가기 전 한번 씩 걸쳐나갈수 있게 해준다.  "
    }, {
    "id": 241,
    "url": "/study_BE_Spring-Container/",
    "title": "Spring : Container",
    "body": "2020/06/09 - Spring - Container개요: Core Container: Been: 프로젝트시 대표적인 반복작업인 new 메소드를 통한 메모리 할당을 Spring에서는 해당 작업을 Bean을 통해 도와준다. 그리고 Bean을 spring-context에서 다루고 있다. 아마도 메모리 할당을 위한 클래스를 만들 때 다음과 같은 약속은 당연한것 같다.  자유도가 넓어야 한다. 즉, 기본 생성자를 가지고 있어야 한다.  보안 측면에서 필드는 private로 선언.  필드가 private이기 떄문에 getter, setter 메소드는 필수. 그렇기 때문에 위와 같은 약속이 Bean의 조건인건 자연스럽다. 위와 같은 조건을 만족한 Class를 Bean Class로 사용할수 있다. 추가로 Bean에서 아마도 확장성의 이유로 각각의 getter, setter를 프로퍼티라고 약속하고 관리한다. (ex setName =&gt; name이란 name을 가진 프로퍼티) Bean Class로 사용할수 있는 Class를 사용하기 위해선 ‘사용하겠다!’라고 선언(Bean 선언)을 해야한다.  그리고 Spring은 Bean 선언을 확인하고 getBean()을 통해 메모리 할당을 한다.  할당은 SingleTon. 즉, 여러번 getBean()을 하더라도 결국 인스턴스는 하나인 방식이다. 선언하는 방법은 여러 방법이 있다.    Xml에 선언 Bean 선언을 Xml에 선언하여 따로 관리한다. 보통 src/main/resources에 applicationContext. xml로 관리한다. 이때, Spring:ApplicationContext가 Spring:ClassPathXmlApplicationContext 에서 ‘xml파일 이름’을 받아 src파일 내에 받은 xml 파일 이름에 xml 파일을 찾아 작성된 선언을 확인한다. 프로퍼티를 활용하여 Bean Class를 객체로 가진 Bean Class를 다룰수도 있다.     Class에 선언 (annotation 이용) Class에 선언하여 따로 관리한다. ‘@annotation’과 같이 Spring에서는 단순 Bean 선언과 더불어 더 많은 annotation을 지원하여 각 annotation에 맞는 다양한 동작을 도와준다.          @configuration : Xml을 Class로 가져온 것이라고 할수 있는데, 선언문을 가진 class임을 나타낸다. 보통 configuration이기 때문에 config라는 패키지에 각 목적에 맞는 Config. class로 관리한다. Main config는 ApplicationConfig이때, Spring:ApplicationContext가 Spring:AnnotationConfigApplicationContext 에서 (이름. class) 또는 (“이름”) 을 받아 해당 클래스에 annotation이 있는지 확인하고 선언을 다룬다. 클래스를 가지고 오기 때문에 method이름이 달라서 생기는 error를 걱정할 필요가 없다.           @Bean : Bean Class를 메모리 할당을 해주는 method임을 나타낸다. @configuration클레스에서 실제 메모리 할당하는 작업을 작성한다.           @Import : 두개 이상의 Configuration을 나눠서 다루고자 할때 사용한다. import할 클래스 이름을 받아 해당 클래스의 Configuration을 가져다 쓴다.       @ComponenetScan : annotation 선헌 할때 root를 받아[(프로젝트 전체), 패키지를 받으려면 (basePackages - {“패키지”})] root에 속해있는 Class 중 ComponenetScan이 Scan할수 있는 annotation을 찾고 찾은 Class에서 각 annotation에 맞는 동작을 한다. (@Component, @Repository, @Controller, @Service)         @Component : Bean Class로 사용안 Class안에 있으며 Bean Class임을 나타낸다.              @Autowired : Bean Class에서 다른 Bean 객체를 받게 될 경우 자동으로 해주도록 나타낸다.                 @Repository : 저장소의 역할을 나타낸다.           @EnableTransactionManagement : transaction과 관련된 설정을 자동으로 해준다. 단 TransactionManagementConfigurer를 implements 받아 구현해야 하며, annotationDrivenTransactionManager()를 오버라이딩 해야 한다. 그리고 spring-jdbc에서 다루고 있다. 왜 그런지는 모르겟는데, 사실 transaction은 spring-tx에서 관리할것 처럼 이지만 jdbc에서 관리하고 있다. 여하튼 jdbc를 사용하려면 tx와 같이 사용하고 있다.          @Primary          MVC: 웹에서 서블릿 반복 작업을 Spring에서는 WebMvc을 통해 도와준다. 그리고 WebMvc는 spring-webmvc에서 다루고 있다.  @EnableWebMvc생각해 보자.  웹에서 어떤 주소를 입력을 하면 Http에서 해당 주소에 Request를 보낸다. 그렇다면 그 주소에 해당하는 곳에서 2가지 방법으로 받을수 있는데, xml방식과 자바 class(annotation) 방법이다.    xml  xml에서 해당주소를  주소 - sevlet name : sevlet name - sevlet class 로 매핑을 시킨다.   그러면 해당 sevlet 클래스가 나오는 것이다.     class  서블릿 경우 @WebServlet  컨트롤러의 경우도 있으나 이 경우는 Xml을 사용하지 않고 쓸 장점이 별로 없어서 xml을 사용한다.  여하튼 두가지 방법으로 받아오면 servlet class로 org. springframework. web. servlet. DispatcherServlet를 연결시키고 Main Controller를 parameter로 가지고 오는데(보통 WebMvcContextConfiguration) 해당 클래스에서 @EnableWebMvc을 선언하면 초기화 해준다.  @ComponenetScan : 앞서 설명함.      @Controller : 서블릿으로 사용할 Class를 나타낸다.          @RequestMapping : Http 요창과 이를 다루기 위한 Controller의 메소드를 연결한다.              @GetMapping : @RequestMapping(path=””, method=RequestMethod. Get)       @PostMapping : @RequestMapping(path=””, method=RequestMethod. Post)       @PutMapping       @DeleteMapping       @PatchMapping                @RequestParam : Mapping된 Method의 Argument에 붙일수 있게한다. required는 필수 여부 판단.              defaultValue – This is the default value as a fallback mechanism if request is not having the value or it is empty.        name – Name of the parameter to bind       required – Whether the parameter is mandatory or not. If it is true, failing to send that parameter will fail.        value – This is an alias for the name attribute                @PathVariable : 상위 Mapping의 path에 변수명을 받아와 사용할 수 있게 한다.      @RequestHeader : 요청정보의 헤더 받아온다.      @ModelAttribute : Dto 객체 앞에 붙여서 해당 Dto를 parameter로 사용할 수 있게 해준다.            @Service : 서비스 Class임을 나타낸다.    @Transactional : Default는 ReadOnly이다. 해당 ReadOnly를 false를 해주게 되면 동시성으로 안될 떄 rollback해주게 된다.   @RestController : Controller를 Rest API로 만들게 해준다. 하나의 url에 각각의 작업을 해준다. "
    }, {
    "id": 242,
    "url": "/study_BE_MySQLUTF8/",
    "title": "MySqlUTF8",
    "body": "2020/06/08 - MySQL개요: MySQL 윈도우작업시 한글 입력하지 못하는 현상을 혹시 몰라 작성해둔다. UTF-8 적용여부 확인: show variables like ‘c%’; stauts; 사실 하나씩 테이블 alter로 변경하는 방법이 있으나, 매우 귀찮기 때문에 새로 my. ini를 만들어 변경하는 방법을 사용한다. basedir 경로: show variables where variable_name like ‘%dir’; 해당 경로에 my. ini파일을 집어 넣어야 한다. my. ini: 메모장을 열어 my. ini파일을 만들어 보자. MySQL utf-8 적용하기: MySQL이 설치된 폴도에 가면 my-default. ini 파일을 복사하여 my. ini 파일을 만든다. 들어갈 내용은 show variables where variable_name like ‘%dir’;에서 basedir datadir 그리고 port port 번호는 status 또는 show global variables like ‘port’;로 확인 가능하다.  이때 인코딩을 ANSI로 저장하자.  저장한 my. ini는 basedir에 저장하자. mysql 서비스 종료 후 재시작. 다시 show variables where variable_name like ‘%dir’; 를 통해 basedir datadir port 값이 이상이 없을 경우 123456789101112131415 [client] default-character-set = utf8  [mysqld] character-set-client-handshake=FALSE init_connect=&amp;quot;SET collation_connection = utf8_general_ci&amp;quot; init_connect=&amp;quot;SET NAMES utf8&amp;quot; character-set-server = utf8 collation-server = utf8_general_ci  [mysqldump] default-character-set = utf8  [mysql] default-character-set = utf8추가 후 저장 mysql 서비스 종료 후 재시작. 해결. "
    }, {
    "id": 243,
    "url": "/study_BE_MySQLQuery/",
    "title": "MySQL Query",
    "body": "2020/06/07 - MySQL개요: Database Query문에 대해 알아보자. Table Join: 기본 명렁어는 ~ FROM 기준테이블 JOIN join할테이블 ON 조건 Cross Join: Table A의 모든 레코드들에 대해 Table B가 모두 Mapping 되는 것.  Table A 레코드 10개 Table B 레코드 5개 = 10 X 5 = 50개 출력 단순하 From절에 복수의 테이블 지정 SELECT * FROM table_a, table_b Inner Join: Table A의 특정 컬럼값이 Table B의 지정 컬럼값과 일치하는 레코드만을 선별. ~ FROM table_a INNER JOIN table_b ON table_a. Col = table_b. Col ~ FROM table_a, table_b WHERE table_a. Col = table_b. Col SELECT table_a. ID, table_b. * FROM table_a INNER JOIN table_b ON table_a. ID = table_b. ID WHERE Table_a. Date &gt;= ‘1/1/2012’ Alias를 사용하여 간략히 SELECT a. ID, b. * FROM table_a a INNER JOIN table_b b ON a. ID = b. ID WHERE a. Date &gt;= ‘1/1/2012’ Outer Join: Inner Join + 매칭이 되지 않는 나머지 레코드 또한 출력(NULL) (원하는 레코드에 따라 left, right, full로 나뉜다. ) SELECT a. Name, SUM(b. Total) ‘합계’ FROM table_a a LEFT OUTER JOIN table_b b ON a. Code = b. CityCode GROUP BY a. Name ### Self Join 자신을 Join함 SELECT a. EmpID, a. Name, b. Name AS Boss FROM table_a a, table_b b WHERE a. MgrId = b. EmpId AND b. Name = ‘Kim’ "
    }, {
    "id": 244,
    "url": "/study_BE_MysqlPractice/",
    "title": "MySql",
    "body": "2020/06/02 - MySQL개요: 알아두면 좋을 MySQL을 사용해보며 잊기 전에 명령어 등을 작성해두자. MySQL 유저 생성 및 삭제: root계정으로 접속하여 유저를 생성한다.    생성  create user ‘아이디’@’%’ identified by ‘비밀번호’;     삭제  drop user ‘아이디’;  delete from user whrer user =’아이디’;  권한 부여: grant all privileges on . to ‘아이디’@’%’; // 모든 데이터베이스의 모든 테이블에 대한 권한 부여(. 이 모든 테이블이란 뜻이다. ) grant all privileges on DB이름. * to ‘아이디’@’%’; // 특정 DB에 대한 모든 권한 부여. grant select, insert, update on DB이름. * to ‘아이디’@’%’; // 특정 DB에 대한 특정 권한(select,insert,update) 부여. FLUSH PRIVILEGES; // 변경한 권한을 즉시 반영시켜주는 명령어 SQL문 실행하기:    예시. sql 이 있는 폴더로 이동한 후, 아래와 같은 명령 수행. 명령 수행 후 계정 암호 입력.  mysql -u user아이디 -p 대상database &lt; 예시. sql     MySQL에 접속 후 해당 database에서 아래와 같은 명령문 실행  mysql&gt; source C:/. . (파일주소). . /예시. sql  MySQL utf-8 적용하기: MySQL이 설치된 폴더에 가면 my-default. ini 파일을 복사하여 my. ini 파일을 만든다. "
    }, {
    "id": 245,
    "url": "/study_BE_GitCommand/",
    "title": "Git",
    "body": "2020/06/02 - Linux Command개요: 알아두면 좋을 Linux 명령어와 git 명령어를 사용해보며 잊기 전에 작성해두자. GIT:  git diff 주소1. . 주소2 : 주소 1과 주소 2간 정보차이를 본다. (branch이름도 가능) git 명령어 –help : 도움말 git tag 이름 branch이름 : tag를 달아준다. (Light weight tag)     -a : git tag -a 이름 -m “annotation” branch이름 으로 anntated tag를 달아준다. (git tag -a 1. 0 -m “first release” master)    git push –tags : 태그를 원격저장소에 올려준다. (Release)Reset:  git reset –hard 돌아가려는커밋주소 : 커밋을 뒤로 돌려준다. (복원지점을 건드리는 거라 잘 생각하고 하자. )     –soft : repository에 있는 값을 지우고 해당 커밋 주소의 repository 값으로 바꿈   –mixed : repository, index(add)에 있는 값을 지우고 해당 커밋 주소의 repository 값으로 둘다 바꿈   –hard : repository, index(add), work directory에 있는 값을 지우고 해당 커밋 주소의 repository 값으로 셋다 바꿈   Log:  git log : git 의 log기록을 알려준다.      -p : git의 commit 로그기록과 차이를 알려준다.    –branches : 현재 저장소에 있는 모든 branch들을 보여준다.    –decorate : git의 log에서 branch정보를 알려주는데, 최근버전부터 default값이 된거 같다. 사용 안해도 됨.    –graph : git의 branch의 구도를 graph로 보여준다.    –oneline : graph와 함께 쓰이면서 더 간결하게 graph를 보여준다.    branch이름1. . branch이름2 : branch 간 로그차이를 보여준다.    –reverse : 역순으로 보여준다.    Merge:  git merge 들어가려는 대상(Starting Point) : 받아들이려는 branch로(Destination) checkout하여 Starting Point를 입력하여 병합한다.          Fast-forward : 만일 병합하려는 두 대상이 하나의 대상 목적지에 종속적이라면 merge하는 것 자체가 사실상 단순히 commit을 대상 목적지로 이동시키는 것이기 때문에 별도의 commit을 발생하지 아니하는데 이를 Fast-forward라고 한다.           Merge made by the ‘recursive’ strategy. : 병합하려는 두 대상이 하나의 뿌리를 둔 다른 가지 형태로 구성되어 있다면 해당 가지의 마지막 지점을 병합하여 새로운 commit을(merge commit) 만든다. 해당 commit은 Destination이 가지고 있다.                             CONFLICT (content) : merge하려는 대상 중 서로 같은 내용이 동시에 수정될 경우 해당 문구를 발생하며 해당branch status 에서 해당branch       MERGING status로 변하게 된다. (당연히 어떤 branch가 진짜인지는 기계가 판단할수 없기 때문) 이때 명령어 status를 입력하여 Unmerged 된 공간을 확인후 수정하도록 한뒤 commit을 하면 자동으로 merge commit이 진행되게 된다.                      Branch:  git branch 이름 : 새로운 branch를 만듬 git checkout 목적지 : 목적지로 이동(commit의 주소로도 갈 수 있다. )     -b : 새로운 branch를 만들고 그 branch로 이동   -d : branch를 삭제한다. (삭제하고자 하는 branch에서 사용불가하다. )   -D : 해당 branch가 어떤 branch에도 종속적이지 않는 자료를 가지고 있다면, -d로 명령할 경우, 정말 삭제할 것이냐고 묻는다. 이때 강제로 지워준다.    Stash:  git stash : git stash save와 동일한 작업이며, work space에 지장이 있을 파일을 commit하지 않고 어딘가에 잠시 두게 해준다. 해당 명령은 여러번 하게 되고 stack에 저장된다. 단, 해당파일은 추적되고 있어야 한다. 다시 말해 적어도 한번 git에 add가 되어있어야 한다.  git stash apply : 어딘가에 잠시 둔 파일을 팝업해준다.  git stash list : stash로 저장을 해두면 해당 저장 log는 명시적으로 지우지 않는 이상 reset –hard 를 하더라도 남아있는데 이를 보는 명령어이다.  git stash drop : 저장된 로그 중 가장 최근 로그 1개를 지워준다.      동시에 하려면 git stash apply; git stash drop;    git stash pop : git stash apply; git stash drop;와 같은 작업을 해주는 명령어. Linux:  cd : 디렉토리 이동     cd / : root directory 이동   cd ~ : home directory 이동    Ctrl + insert : 복사 Shift + insert : 붙여넣기MAN:  p : 나가기 h : man 사용법 확인 (help) 방향키 &amp; 엔터 : 한줄씩 넘기기 page Up &amp; Down, Space Bar : 한페이지 씩 넘기기 /검색어 (enter) : 검색     n : 다음문자   N : 이전문자   "
    }, {
    "id": 246,
    "url": "/study_BE_Filter/",
    "title": "Spring : Filter",
    "body": "2020/06/02 - Filter개요: 간단하지만, 남겨두면 좋을 것 같아 작성한다. encoding: Spring에서 제공하는 CharacterEncodingFilter를 사용해 한글 지원이 가능하도록 한다. parameter value로 UTF-8로 한다. url-pattern은 전체로 적용 "
    }, {
    "id": 247,
    "url": "/study_BE_codeConvention/",
    "title": "코드 컨벤션",
    "body": "2020/06/01 - 코드 컨벤션코드 컨벤션은 읽고, 관리하기 쉬운 코드를 작성하기 위한 일종의 코딩 스타일 규약이다. 코딩을 할때 일정한 규칙을 가지게 되면, 해당 코드에 대해 나를 포함한 다른 누가 오게 되더라도 상대적으로 이해하기 편하도록 도와줄 수 있다. 특히 실무에서는 협업하기 때문에 코드 컨벤션은 필수라고 할수 있다. 다만 어디까지나 스타일이기 때문에 해당 프로젝트에 대해 동일한 규칙으로 약속만 되어 있다면, 다른 스타일을 가지고 있는 회사도 있을 수 있다. 지금은 코드 컨벤션 중 여러가지 표기법이 있다는 정도로 이해하고 나 또한 개발할 때, 동일한 규칙으로 개발하려고 한다. 아래는 표기법에 대해 설명하려고 한다. 간단한 내용이기에 설명에는 예시만 할것이며, 개발 하며 잊을 때 마다 참고할 예정이다. my + first + item 파스칼 표기법 -&gt; 클래스, 인터페이스 등: MyFirstItem 카멜 표기법 -&gt; 일반 변수, 함수명 등: myFirstItem 언더스코어 표기법: my_first_item 헝가리언 표기법: 설명을 가진 접두어 + MyFirstItem (동적 타입 언어에는 맞지가 않으므로 있다는 정도로 알아두자. ) 변수 선언:  숫자로 시작하면 안된다.  if와 같은 키워드 사용할 수 없다 보통 카멜표기법을 사용한다. (대소문자를 가리지 않는 환경 - MySQL 에서는 언더스코어 표기법을 사용한다. )"
    }, {
    "id": 248,
    "url": "/web_service_clone/",
    "title": "웹 예약 서비스 클론 코딩",
    "body": "2020/05/10 - "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});